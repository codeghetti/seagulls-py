{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"api/seagulls-devtools/seagulls/","text":"seagulls \u00b6","title":"seagulls"},{"location":"api/seagulls-devtools/seagulls/#seagulls","text":"","title":"seagulls"},{"location":"api/seagulls-devtools/seagulls/app/","text":"seagulls .app \u00b6 View Source from ._app_interfaces import ISeagullsApplication from ._plugin_client import SeagullsEntryPointsPluginsClient from ._plugin_interfaces import ( ApplicationType , PluginType , ISeagullsApplicationPlugin , IPluggableSeagullsApplication , ISeagullsPluginClient , ISeagullsApplicationPluginRegistrant , ) from ._plugin_exceptions import DuplicatePluginError __all__ = [ # App \"ISeagullsApplication\" , # Plugin Client \"SeagullsEntryPointsPluginsClient\" , # App Plugins \"ApplicationType\" , \"PluginType\" , \"ISeagullsApplicationPlugin\" , \"IPluggableSeagullsApplication\" , \"ISeagullsPluginClient\" , \"ISeagullsApplicationPluginRegistrant\" , # Exceptions \"DuplicatePluginError\" , ] ISeagullsApplication \u00b6 class ISeagullsApplication ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class ISeagullsApplication ( Protocol ): @abstractmethod def execute ( self ) -> None : ... execute() \u00b6 @abstractmethod def execute ( self ) -> None : View Source @abstractmethod def execute ( self ) -> None : ... SeagullsEntryPointsPluginsClient \u00b6 class SeagullsEntryPointsPluginsClient ( seagulls . app . _plugin_interfaces . ISeagullsPluginClient ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class SeagullsEntryPointsPluginsClient ( ISeagullsPluginClient ): _entrypoint_name : str def __init__ ( self , entrypoint_name : str ): self . _entrypoint_name = entrypoint_name def register_plugins ( self , application : ApplicationType ) -> None : plugins = entry_points ( group = self . _entrypoint_name ) for plugin in plugins : plugin_ref : Type [ ISeagullsApplicationPluginRegistrant ] = plugin . load () if not issubclass ( plugin_ref , ISeagullsApplicationPluginRegistrant ): raise InvalidPluginError ( plugin ) plugin_ref . register_plugins ( application ) # type: ignore SeagullsEntryPointsPluginsClient() \u00b6 SeagullsEntryPointsPluginsClient ( entrypoint_name : str ): View Source def __init__ ( self , entrypoint_name : str ): self . _entrypoint_name = entrypoint_name register_plugins() \u00b6 def register_plugins ( self , application : - ApplicationType ) -> None : Find all plugins and let them register plugins to the running application. View Source def register_plugins ( self , application : ApplicationType ) -> None : plugins = entry_points ( group = self . _entrypoint_name ) for plugin in plugins : plugin_ref : Type [ ISeagullsApplicationPluginRegistrant ] = plugin . load () if not issubclass ( plugin_ref , ISeagullsApplicationPluginRegistrant ): raise InvalidPluginError ( plugin ) plugin_ref . register_plugins ( application ) # type: ignore ApplicationType \u00b6 ApplicationType = - ApplicationType PluginType \u00b6 PluginType = ~ PluginType ISeagullsApplicationPlugin \u00b6 class ISeagullsApplicationPlugin ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class ISeagullsApplicationPlugin ( Protocol ): @abstractmethod def on_registration ( self ) -> None : \"\"\" Called when the plugin is first registered with the application. \"\"\" on_registration() \u00b6 @abstractmethod def on_registration ( self ) -> None : Called when the plugin is first registered with the application. View Source @abstractmethod def on_registration ( self ) -> None : \"\"\" Called when the plugin is first registered with the application. \"\"\" IPluggableSeagullsApplication \u00b6 class IPluggableSeagullsApplication ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class IPluggableSeagullsApplication ( Protocol ): @abstractmethod def register_plugin ( self , plugin : ISeagullsApplicationPlugin ) -> None : ... @abstractmethod def get_plugin ( self , plugin : Type [ PluginType ]) -> PluginType : ... register_plugin() \u00b6 @abstractmethod def register_plugin ( self , plugin : seagulls . app . _plugin_interfaces . ISeagullsApplicationPlugin ) -> None : View Source @abstractmethod def register_plugin ( self , plugin : ISeagullsApplicationPlugin ) -> None : ... get_plugin() \u00b6 @abstractmethod def get_plugin ( self , plugin : Type [ ~ PluginType ]) -> ~ PluginType : View Source @abstractmethod def get_plugin ( self , plugin : Type [ PluginType ]) -> PluginType : ... ISeagullsPluginClient \u00b6 class ISeagullsPluginClient ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class ISeagullsPluginClient ( Protocol ): @abstractmethod def register_plugins ( self , application : ApplicationType ) -> None : \"\"\" Find all plugins and let them register plugins to the running application. \"\"\" register_plugins() \u00b6 @abstractmethod def register_plugins ( self , application : - ApplicationType ) -> None : Find all plugins and let them register plugins to the running application. View Source @abstractmethod def register_plugins ( self , application : ApplicationType ) -> None : \"\"\" Find all plugins and let them register plugins to the running application. \"\"\" ISeagullsApplicationPluginRegistrant \u00b6 @runtime_checkable class ISeagullsApplicationPluginRegistrant ( typing . Protocol [ - ApplicationType ]): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source @runtime_checkable class ISeagullsApplicationPluginRegistrant ( Protocol [ ApplicationType ]): @staticmethod @abstractmethod def register_plugins ( application : ApplicationType ) -> None : \"\"\" Called at the start of the process for plugin devs to register their plugins in the app. \"\"\" register_plugins() \u00b6 @staticmethod @abstractmethod def register_plugins ( application : - ApplicationType ) -> None : Called at the start of the process for plugin devs to register their plugins in the app. View Source @staticmethod @abstractmethod def register_plugins ( application : ApplicationType ) -> None : \"\"\" Called at the start of the process for plugin devs to register their plugins in the app. \"\"\" DuplicatePluginError \u00b6 class DuplicatePluginError ( builtins . RuntimeError ): Unspecified run-time error. View Source class DuplicatePluginError ( RuntimeError ): plugin : ISeagullsApplicationPlugin def __init__ ( self , plugin : ISeagullsApplicationPlugin ): super () . __init__ ( f \"Duplicate plugin registration detected: { type ( plugin ) } \" ) self . plugin = plugin DuplicatePluginError() \u00b6 DuplicatePluginError ( plugin : seagulls . app . _plugin_interfaces . ISeagullsApplicationPlugin ): View Source def __init__ ( self , plugin : ISeagullsApplicationPlugin ): super () . __init__ ( f \"Duplicate plugin registration detected: { type ( plugin ) } \" ) self . plugin = plugin Inherited Members \u00b6 taken from: builtins:BaseException with_traceback () args","title":"seagulls.app"},{"location":"api/seagulls-devtools/seagulls/app/#seagullsapp","text":"View Source from ._app_interfaces import ISeagullsApplication from ._plugin_client import SeagullsEntryPointsPluginsClient from ._plugin_interfaces import ( ApplicationType , PluginType , ISeagullsApplicationPlugin , IPluggableSeagullsApplication , ISeagullsPluginClient , ISeagullsApplicationPluginRegistrant , ) from ._plugin_exceptions import DuplicatePluginError __all__ = [ # App \"ISeagullsApplication\" , # Plugin Client \"SeagullsEntryPointsPluginsClient\" , # App Plugins \"ApplicationType\" , \"PluginType\" , \"ISeagullsApplicationPlugin\" , \"IPluggableSeagullsApplication\" , \"ISeagullsPluginClient\" , \"ISeagullsApplicationPluginRegistrant\" , # Exceptions \"DuplicatePluginError\" , ]","title":"seagulls.app"},{"location":"api/seagulls-devtools/seagulls/app/#iseagullsapplication","text":"class ISeagullsApplication ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class ISeagullsApplication ( Protocol ): @abstractmethod def execute ( self ) -> None : ...","title":"ISeagullsApplication"},{"location":"api/seagulls-devtools/seagulls/app/#execute","text":"@abstractmethod def execute ( self ) -> None : View Source @abstractmethod def execute ( self ) -> None : ...","title":"execute()"},{"location":"api/seagulls-devtools/seagulls/app/#seagullsentrypointspluginsclient","text":"class SeagullsEntryPointsPluginsClient ( seagulls . app . _plugin_interfaces . ISeagullsPluginClient ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class SeagullsEntryPointsPluginsClient ( ISeagullsPluginClient ): _entrypoint_name : str def __init__ ( self , entrypoint_name : str ): self . _entrypoint_name = entrypoint_name def register_plugins ( self , application : ApplicationType ) -> None : plugins = entry_points ( group = self . _entrypoint_name ) for plugin in plugins : plugin_ref : Type [ ISeagullsApplicationPluginRegistrant ] = plugin . load () if not issubclass ( plugin_ref , ISeagullsApplicationPluginRegistrant ): raise InvalidPluginError ( plugin ) plugin_ref . register_plugins ( application ) # type: ignore","title":"SeagullsEntryPointsPluginsClient"},{"location":"api/seagulls-devtools/seagulls/app/#seagullsentrypointspluginsclient_1","text":"SeagullsEntryPointsPluginsClient ( entrypoint_name : str ): View Source def __init__ ( self , entrypoint_name : str ): self . _entrypoint_name = entrypoint_name","title":"SeagullsEntryPointsPluginsClient()"},{"location":"api/seagulls-devtools/seagulls/app/#register_plugins","text":"def register_plugins ( self , application : - ApplicationType ) -> None : Find all plugins and let them register plugins to the running application. View Source def register_plugins ( self , application : ApplicationType ) -> None : plugins = entry_points ( group = self . _entrypoint_name ) for plugin in plugins : plugin_ref : Type [ ISeagullsApplicationPluginRegistrant ] = plugin . load () if not issubclass ( plugin_ref , ISeagullsApplicationPluginRegistrant ): raise InvalidPluginError ( plugin ) plugin_ref . register_plugins ( application ) # type: ignore","title":"register_plugins()"},{"location":"api/seagulls-devtools/seagulls/app/#applicationtype","text":"ApplicationType = - ApplicationType","title":"ApplicationType"},{"location":"api/seagulls-devtools/seagulls/app/#plugintype","text":"PluginType = ~ PluginType","title":"PluginType"},{"location":"api/seagulls-devtools/seagulls/app/#iseagullsapplicationplugin","text":"class ISeagullsApplicationPlugin ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class ISeagullsApplicationPlugin ( Protocol ): @abstractmethod def on_registration ( self ) -> None : \"\"\" Called when the plugin is first registered with the application. \"\"\"","title":"ISeagullsApplicationPlugin"},{"location":"api/seagulls-devtools/seagulls/app/#on_registration","text":"@abstractmethod def on_registration ( self ) -> None : Called when the plugin is first registered with the application. View Source @abstractmethod def on_registration ( self ) -> None : \"\"\" Called when the plugin is first registered with the application. \"\"\"","title":"on_registration()"},{"location":"api/seagulls-devtools/seagulls/app/#ipluggableseagullsapplication","text":"class IPluggableSeagullsApplication ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class IPluggableSeagullsApplication ( Protocol ): @abstractmethod def register_plugin ( self , plugin : ISeagullsApplicationPlugin ) -> None : ... @abstractmethod def get_plugin ( self , plugin : Type [ PluginType ]) -> PluginType : ...","title":"IPluggableSeagullsApplication"},{"location":"api/seagulls-devtools/seagulls/app/#register_plugin","text":"@abstractmethod def register_plugin ( self , plugin : seagulls . app . _plugin_interfaces . ISeagullsApplicationPlugin ) -> None : View Source @abstractmethod def register_plugin ( self , plugin : ISeagullsApplicationPlugin ) -> None : ...","title":"register_plugin()"},{"location":"api/seagulls-devtools/seagulls/app/#get_plugin","text":"@abstractmethod def get_plugin ( self , plugin : Type [ ~ PluginType ]) -> ~ PluginType : View Source @abstractmethod def get_plugin ( self , plugin : Type [ PluginType ]) -> PluginType : ...","title":"get_plugin()"},{"location":"api/seagulls-devtools/seagulls/app/#iseagullspluginclient","text":"class ISeagullsPluginClient ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class ISeagullsPluginClient ( Protocol ): @abstractmethod def register_plugins ( self , application : ApplicationType ) -> None : \"\"\" Find all plugins and let them register plugins to the running application. \"\"\"","title":"ISeagullsPluginClient"},{"location":"api/seagulls-devtools/seagulls/app/#register_plugins_1","text":"@abstractmethod def register_plugins ( self , application : - ApplicationType ) -> None : Find all plugins and let them register plugins to the running application. View Source @abstractmethod def register_plugins ( self , application : ApplicationType ) -> None : \"\"\" Find all plugins and let them register plugins to the running application. \"\"\"","title":"register_plugins()"},{"location":"api/seagulls-devtools/seagulls/app/#iseagullsapplicationpluginregistrant","text":"@runtime_checkable class ISeagullsApplicationPluginRegistrant ( typing . Protocol [ - ApplicationType ]): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source @runtime_checkable class ISeagullsApplicationPluginRegistrant ( Protocol [ ApplicationType ]): @staticmethod @abstractmethod def register_plugins ( application : ApplicationType ) -> None : \"\"\" Called at the start of the process for plugin devs to register their plugins in the app. \"\"\"","title":"ISeagullsApplicationPluginRegistrant"},{"location":"api/seagulls-devtools/seagulls/app/#register_plugins_2","text":"@staticmethod @abstractmethod def register_plugins ( application : - ApplicationType ) -> None : Called at the start of the process for plugin devs to register their plugins in the app. View Source @staticmethod @abstractmethod def register_plugins ( application : ApplicationType ) -> None : \"\"\" Called at the start of the process for plugin devs to register their plugins in the app. \"\"\"","title":"register_plugins()"},{"location":"api/seagulls-devtools/seagulls/app/#duplicatepluginerror","text":"class DuplicatePluginError ( builtins . RuntimeError ): Unspecified run-time error. View Source class DuplicatePluginError ( RuntimeError ): plugin : ISeagullsApplicationPlugin def __init__ ( self , plugin : ISeagullsApplicationPlugin ): super () . __init__ ( f \"Duplicate plugin registration detected: { type ( plugin ) } \" ) self . plugin = plugin","title":"DuplicatePluginError"},{"location":"api/seagulls-devtools/seagulls/app/#duplicatepluginerror_1","text":"DuplicatePluginError ( plugin : seagulls . app . _plugin_interfaces . ISeagullsApplicationPlugin ): View Source def __init__ ( self , plugin : ISeagullsApplicationPlugin ): super () . __init__ ( f \"Duplicate plugin registration detected: { type ( plugin ) } \" ) self . plugin = plugin","title":"DuplicatePluginError()"},{"location":"api/seagulls-devtools/seagulls/app/#inherited-members","text":"taken from: builtins:BaseException with_traceback () args","title":"Inherited Members"},{"location":"api/seagulls-devtools/seagulls/assets/","text":"seagulls .assets \u00b6 View Source from ._manager import AssetManager __all__ = [ \"AssetManager\" ] AssetManager \u00b6 class AssetManager : Provides basic functionality for loading assets from disk. View Source class AssetManager : \"\"\"Provides basic functionality for loading assets from disk.\"\"\" _assets_path : Path def __init__ ( self , assets_path : Path ): self . _assets_path = assets_path def load_sprite ( self , name : str ) -> Surface : return self . load_png ( f \"sprites/ { name } \" ) def load_png ( self , name : str ) -> Surface : path = self . _assets_path / f \" { name } .png\" loaded_sprite = load ( path . resolve ()) if loaded_sprite . get_alpha () is None : return loaded_sprite . convert () else : return loaded_sprite . convert_alpha () AssetManager() \u00b6 AssetManager ( assets_path : pathlib . Path ): View Source def __init__ ( self , assets_path : Path ): self . _assets_path = assets_path load_sprite() \u00b6 def load_sprite ( self , name : str ) -> pygame . Surface : View Source def load_sprite ( self , name : str ) -> Surface : return self . load_png ( f \"sprites/ { name } \" ) load_png() \u00b6 def load_png ( self , name : str ) -> pygame . Surface : View Source def load_png ( self , name : str ) -> Surface : path = self . _assets_path / f \" { name } .png\" loaded_sprite = load ( path . resolve ()) if loaded_sprite . get_alpha () is None : return loaded_sprite . convert () else : return loaded_sprite . convert_alpha ()","title":"seagulls.assets"},{"location":"api/seagulls-devtools/seagulls/assets/#seagullsassets","text":"View Source from ._manager import AssetManager __all__ = [ \"AssetManager\" ]","title":"seagulls.assets"},{"location":"api/seagulls-devtools/seagulls/assets/#assetmanager","text":"class AssetManager : Provides basic functionality for loading assets from disk. View Source class AssetManager : \"\"\"Provides basic functionality for loading assets from disk.\"\"\" _assets_path : Path def __init__ ( self , assets_path : Path ): self . _assets_path = assets_path def load_sprite ( self , name : str ) -> Surface : return self . load_png ( f \"sprites/ { name } \" ) def load_png ( self , name : str ) -> Surface : path = self . _assets_path / f \" { name } .png\" loaded_sprite = load ( path . resolve ()) if loaded_sprite . get_alpha () is None : return loaded_sprite . convert () else : return loaded_sprite . convert_alpha ()","title":"AssetManager"},{"location":"api/seagulls-devtools/seagulls/assets/#assetmanager_1","text":"AssetManager ( assets_path : pathlib . Path ): View Source def __init__ ( self , assets_path : Path ): self . _assets_path = assets_path","title":"AssetManager()"},{"location":"api/seagulls-devtools/seagulls/assets/#load_sprite","text":"def load_sprite ( self , name : str ) -> pygame . Surface : View Source def load_sprite ( self , name : str ) -> Surface : return self . load_png ( f \"sprites/ { name } \" )","title":"load_sprite()"},{"location":"api/seagulls-devtools/seagulls/assets/#load_png","text":"def load_png ( self , name : str ) -> pygame . Surface : View Source def load_png ( self , name : str ) -> Surface : path = self . _assets_path / f \" { name } .png\" loaded_sprite = load ( path . resolve ()) if loaded_sprite . get_alpha () is None : return loaded_sprite . convert () else : return loaded_sprite . convert_alpha ()","title":"load_png()"},{"location":"api/seagulls-devtools/seagulls/cli/","text":"seagulls .cli \u00b6 View Source from ._request import ( CliRequest , ICliCommand , RequestEnvironment , CliRequestRegistrationEvent , ) __all__ = [ \"CliRequest\" , \"ICliCommand\" , \"RequestEnvironment\" , \"CliRequestRegistrationEvent\" , ] CliRequest \u00b6 class CliRequest : View Source class CliRequest : _file : Path _args : Tuple [ str , ... ] _env : RequestEnvironment def __init__ ( self , file : Path , args : Tuple [ str , ... ], env : RequestEnvironment ): self . _file = file self . _args = args self . _env = env def execute ( self , event_dispatcher : IDispatchEvents ) -> None : # Build the CLI Command Interface parser = ArgumentParser ( description = \"Seagulls CLI Command\" , ) event = CliRequestRegistrationEvent ( parser ) event_dispatcher . trigger_event ( event ) def default_execute () -> None : parser . print_help () parser . set_defaults ( cmd = default_execute ) args = parser . parse_args ( self . _args ) args . cmd () CliRequest() \u00b6 CliRequest ( file : pathlib . Path , args : Tuple [ str , ... ], env : seagulls . cli . _request . RequestEnvironment ): View Source def __init__ ( self , file : Path , args : Tuple [ str , ... ], env : RequestEnvironment ): self . _file = file self . _args = args self . _env = env execute() \u00b6 def execute ( self , event_dispatcher : seagulls . eventing . _interfaces . IDispatchEvents ) -> None : View Source def execute ( self , event_dispatcher : IDispatchEvents ) -> None : # Build the CLI Command Interface parser = ArgumentParser ( description = \"Seagulls CLI Command\" , ) event = CliRequestRegistrationEvent ( parser ) event_dispatcher . trigger_event ( event ) def default_execute () -> None : parser . print_help () parser . set_defaults ( cmd = default_execute ) args = parser . parse_args ( self . _args ) args . cmd () ICliCommand \u00b6 class ICliCommand ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class ICliCommand ( Protocol ): @abstractmethod def configure_parser ( self , parser : ArgumentParser ) -> None : ... @abstractmethod def execute ( self ) -> None : ... configure_parser() \u00b6 @abstractmethod def configure_parser ( self , parser : argparse . ArgumentParser ) -> None : View Source @abstractmethod def configure_parser ( self , parser : ArgumentParser ) -> None : ... execute() \u00b6 @abstractmethod def execute ( self ) -> None : View Source @abstractmethod def execute ( self ) -> None : ... RequestEnvironment \u00b6 class RequestEnvironment : View Source class RequestEnvironment : _values : Dict [ str , str ] def __init__ ( self , values : Tuple [ EnvironmentTuple , ... ]): self . _values = { k : v for k , v in values } def get ( self , name : str , default : str = None ) -> Optional [ str ]: return self . _values . get ( name , default ) def as_dict ( self ) -> Dict [ str , str ]: return self . _values . copy () RequestEnvironment() \u00b6 RequestEnvironment ( values : Tuple [ Tuple [ str , str ], ... ]): View Source def __init__ ( self , values : Tuple [ EnvironmentTuple , ... ]): self . _values = { k : v for k , v in values } get() \u00b6 def get ( self , name : str , default : str = None ) -> Optional [ str ]: View Source def get ( self , name : str , default : str = None ) -> Optional [ str ]: return self . _values . get ( name , default ) as_dict() \u00b6 def as_dict ( self ) -> Dict [ str , str ]: View Source def as_dict ( self ) -> Dict [ str , str ]: return self . _values . copy () CliRequestRegistrationEvent \u00b6 class CliRequestRegistrationEvent : View Source class CliRequestRegistrationEvent : _parser : ArgumentParser def __init__ ( self , parser : ArgumentParser ): self . _parser = parser def register_command ( self , name : str , command : ICliCommand ) -> None : def callback () -> None : command . execute () subparser = self . _get_subparsers () . add_parser ( name = name ) command . configure_parser ( subparser ) subparser . set_defaults ( cmd = callback ) @lru_cache () def _get_subparsers ( self ): return self . _parser . add_subparsers ( title = \"subcommands\" , metavar = None , help = \"\" ) CliRequestRegistrationEvent() \u00b6 CliRequestRegistrationEvent ( parser : argparse . ArgumentParser ): View Source def __init__ ( self , parser : ArgumentParser ): self . _parser = parser register_command() \u00b6 def register_command ( self , name : str , command : seagulls . cli . _request . ICliCommand ) -> None : View Source def register_command ( self , name : str , command : ICliCommand ) -> None : def callback () -> None : command . execute () subparser = self . _get_subparsers () . add_parser ( name = name ) command . configure_parser ( subparser ) subparser . set_defaults ( cmd = callback )","title":"seagulls.cli"},{"location":"api/seagulls-devtools/seagulls/cli/#seagullscli","text":"View Source from ._request import ( CliRequest , ICliCommand , RequestEnvironment , CliRequestRegistrationEvent , ) __all__ = [ \"CliRequest\" , \"ICliCommand\" , \"RequestEnvironment\" , \"CliRequestRegistrationEvent\" , ]","title":"seagulls.cli"},{"location":"api/seagulls-devtools/seagulls/cli/#clirequest","text":"class CliRequest : View Source class CliRequest : _file : Path _args : Tuple [ str , ... ] _env : RequestEnvironment def __init__ ( self , file : Path , args : Tuple [ str , ... ], env : RequestEnvironment ): self . _file = file self . _args = args self . _env = env def execute ( self , event_dispatcher : IDispatchEvents ) -> None : # Build the CLI Command Interface parser = ArgumentParser ( description = \"Seagulls CLI Command\" , ) event = CliRequestRegistrationEvent ( parser ) event_dispatcher . trigger_event ( event ) def default_execute () -> None : parser . print_help () parser . set_defaults ( cmd = default_execute ) args = parser . parse_args ( self . _args ) args . cmd ()","title":"CliRequest"},{"location":"api/seagulls-devtools/seagulls/cli/#clirequest_1","text":"CliRequest ( file : pathlib . Path , args : Tuple [ str , ... ], env : seagulls . cli . _request . RequestEnvironment ): View Source def __init__ ( self , file : Path , args : Tuple [ str , ... ], env : RequestEnvironment ): self . _file = file self . _args = args self . _env = env","title":"CliRequest()"},{"location":"api/seagulls-devtools/seagulls/cli/#execute","text":"def execute ( self , event_dispatcher : seagulls . eventing . _interfaces . IDispatchEvents ) -> None : View Source def execute ( self , event_dispatcher : IDispatchEvents ) -> None : # Build the CLI Command Interface parser = ArgumentParser ( description = \"Seagulls CLI Command\" , ) event = CliRequestRegistrationEvent ( parser ) event_dispatcher . trigger_event ( event ) def default_execute () -> None : parser . print_help () parser . set_defaults ( cmd = default_execute ) args = parser . parse_args ( self . _args ) args . cmd ()","title":"execute()"},{"location":"api/seagulls-devtools/seagulls/cli/#iclicommand","text":"class ICliCommand ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class ICliCommand ( Protocol ): @abstractmethod def configure_parser ( self , parser : ArgumentParser ) -> None : ... @abstractmethod def execute ( self ) -> None : ...","title":"ICliCommand"},{"location":"api/seagulls-devtools/seagulls/cli/#configure_parser","text":"@abstractmethod def configure_parser ( self , parser : argparse . ArgumentParser ) -> None : View Source @abstractmethod def configure_parser ( self , parser : ArgumentParser ) -> None : ...","title":"configure_parser()"},{"location":"api/seagulls-devtools/seagulls/cli/#execute_1","text":"@abstractmethod def execute ( self ) -> None : View Source @abstractmethod def execute ( self ) -> None : ...","title":"execute()"},{"location":"api/seagulls-devtools/seagulls/cli/#requestenvironment","text":"class RequestEnvironment : View Source class RequestEnvironment : _values : Dict [ str , str ] def __init__ ( self , values : Tuple [ EnvironmentTuple , ... ]): self . _values = { k : v for k , v in values } def get ( self , name : str , default : str = None ) -> Optional [ str ]: return self . _values . get ( name , default ) def as_dict ( self ) -> Dict [ str , str ]: return self . _values . copy ()","title":"RequestEnvironment"},{"location":"api/seagulls-devtools/seagulls/cli/#requestenvironment_1","text":"RequestEnvironment ( values : Tuple [ Tuple [ str , str ], ... ]): View Source def __init__ ( self , values : Tuple [ EnvironmentTuple , ... ]): self . _values = { k : v for k , v in values }","title":"RequestEnvironment()"},{"location":"api/seagulls-devtools/seagulls/cli/#get","text":"def get ( self , name : str , default : str = None ) -> Optional [ str ]: View Source def get ( self , name : str , default : str = None ) -> Optional [ str ]: return self . _values . get ( name , default )","title":"get()"},{"location":"api/seagulls-devtools/seagulls/cli/#as_dict","text":"def as_dict ( self ) -> Dict [ str , str ]: View Source def as_dict ( self ) -> Dict [ str , str ]: return self . _values . copy ()","title":"as_dict()"},{"location":"api/seagulls-devtools/seagulls/cli/#clirequestregistrationevent","text":"class CliRequestRegistrationEvent : View Source class CliRequestRegistrationEvent : _parser : ArgumentParser def __init__ ( self , parser : ArgumentParser ): self . _parser = parser def register_command ( self , name : str , command : ICliCommand ) -> None : def callback () -> None : command . execute () subparser = self . _get_subparsers () . add_parser ( name = name ) command . configure_parser ( subparser ) subparser . set_defaults ( cmd = callback ) @lru_cache () def _get_subparsers ( self ): return self . _parser . add_subparsers ( title = \"subcommands\" , metavar = None , help = \"\" )","title":"CliRequestRegistrationEvent"},{"location":"api/seagulls-devtools/seagulls/cli/#clirequestregistrationevent_1","text":"CliRequestRegistrationEvent ( parser : argparse . ArgumentParser ): View Source def __init__ ( self , parser : ArgumentParser ): self . _parser = parser","title":"CliRequestRegistrationEvent()"},{"location":"api/seagulls-devtools/seagulls/cli/#register_command","text":"def register_command ( self , name : str , command : seagulls . cli . _request . ICliCommand ) -> None : View Source def register_command ( self , name : str , command : ICliCommand ) -> None : def callback () -> None : command . execute () subparser = self . _get_subparsers () . add_parser ( name = name ) command . configure_parser ( subparser ) subparser . set_defaults ( cmd = callback )","title":"register_command()"},{"location":"api/seagulls-devtools/seagulls/devtools/","text":"seagulls .devtools \u00b6 View Source from ._cli_entry_point import DevtoolsCliPluginEntryPoint __all__ = [ \"DevtoolsCliPluginEntryPoint\" , ] DevtoolsCliPluginEntryPoint \u00b6 class DevtoolsCliPluginEntryPoint ( seagulls . app . _plugin_interfaces . ISeagullsApplicationPluginRegistrant [ seagulls . seagulls_cli . _application . SeagullsCliApplication ]): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class DevtoolsCliPluginEntryPoint ( ISeagullsApplicationPluginRegistrant [ SeagullsCliApplication ]): @staticmethod def register_plugins ( application : SeagullsCliApplication ) -> None : di_container = SeagullsDevtoolsDiContainer ( application = application ) application . register_plugin ( di_container . plugin ()) register_plugins() \u00b6 @staticmethod def register_plugins ( application : seagulls . seagulls_cli . _application . SeagullsCliApplication ) -> None : Called at the start of the process for plugin devs to register their plugins in the app. View Source @staticmethod def register_plugins ( application : SeagullsCliApplication ) -> None : di_container = SeagullsDevtoolsDiContainer ( application = application ) application . register_plugin ( di_container . plugin ()) Inherited Members \u00b6 taken from: seagulls.app._plugin_interfaces:ISeagullsApplicationPluginRegistrant ISeagullsApplicationPluginRegistrant ( * args , ** kwargs )","title":"seagulls.devtools"},{"location":"api/seagulls-devtools/seagulls/devtools/#seagullsdevtools","text":"View Source from ._cli_entry_point import DevtoolsCliPluginEntryPoint __all__ = [ \"DevtoolsCliPluginEntryPoint\" , ]","title":"seagulls.devtools"},{"location":"api/seagulls-devtools/seagulls/devtools/#devtoolsclipluginentrypoint","text":"class DevtoolsCliPluginEntryPoint ( seagulls . app . _plugin_interfaces . ISeagullsApplicationPluginRegistrant [ seagulls . seagulls_cli . _application . SeagullsCliApplication ]): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class DevtoolsCliPluginEntryPoint ( ISeagullsApplicationPluginRegistrant [ SeagullsCliApplication ]): @staticmethod def register_plugins ( application : SeagullsCliApplication ) -> None : di_container = SeagullsDevtoolsDiContainer ( application = application ) application . register_plugin ( di_container . plugin ())","title":"DevtoolsCliPluginEntryPoint"},{"location":"api/seagulls-devtools/seagulls/devtools/#register_plugins","text":"@staticmethod def register_plugins ( application : seagulls . seagulls_cli . _application . SeagullsCliApplication ) -> None : Called at the start of the process for plugin devs to register their plugins in the app. View Source @staticmethod def register_plugins ( application : SeagullsCliApplication ) -> None : di_container = SeagullsDevtoolsDiContainer ( application = application ) application . register_plugin ( di_container . plugin ())","title":"register_plugins()"},{"location":"api/seagulls-devtools/seagulls/devtools/#inherited-members","text":"taken from: seagulls.app._plugin_interfaces:ISeagullsApplicationPluginRegistrant ISeagullsApplicationPluginRegistrant ( * args , ** kwargs )","title":"Inherited Members"},{"location":"api/seagulls-devtools/seagulls/engine/","text":"seagulls .engine \u00b6 Core Engine Components View Source \"\"\"Core Engine Components\"\"\" from ._collisions import CollidableObject , flag_from_string from ._game_clock import GameClock from ._game_controls import GameControls from ._game_object import GameObject , GameObjectsCollection from ._game_scene import IGameScene from ._game_scene_manager import IProvideGameScenes from ._game_session import IGameSession from ._game_session_manager import IProvideGameSessions from ._game_settings import GameSettings from ._pygame import Color , PixelArray , Rect , Surface , Vector2 , Vector3 from ._surface_renderer import SurfaceRenderer __all__ = [ \"flag_from_string\" , \"CollidableObject\" , \"IGameScene\" , \"IProvideGameScenes\" , \"IProvideGameSessions\" , \"IGameSession\" , \"SurfaceRenderer\" , \"GameClock\" , \"GameControls\" , \"GameObject\" , \"GameObjectsCollection\" , \"GameSettings\" , \"Rect\" , \"Surface\" , \"Color\" , \"PixelArray\" , \"Vector2\" , \"Vector3\" , ] flag_from_string() \u00b6 def flag_from_string ( value : str ) -> int : View Source def flag_from_string ( value : str ) -> int : if not isinstance ( value , str ): raise ValueError ( f \"Value must be a string of 0s and 1s: { value } \" ) return int ( value , 2 ) CollidableObject \u00b6 @dataclass ( frozen = True ) class CollidableObject : CollidableObject(layer: int, mask: int) View Source @dataclass ( frozen = True ) class CollidableObject : layer : int mask : int def filter_by_mask ( self , targets : Tuple [ \"CollidableObject\" , ... ]) -> Tuple [ \"CollidableObject\" , ... ]: result = [] for t in targets : if self . is_in_mask ( t ): result . append ( t ) return tuple ( result ) def is_in_mask ( self , target : \"CollidableObject\" ) -> bool : logger . debug ( f \"targeting items located in mask: { self . mask : b } \" ) logger . debug ( f \"target is located in layer: { target . layer : b } \" ) logger . debug ( f \"& result: { self . mask & target . layer : b } \" ) return self . mask & target . layer > 0 def __repr__ ( self ) -> str : return f \" { self . __class__ . __name__ } (layer= { self . layer : b } , mask= { self . mask : b } )\" CollidableObject() \u00b6 CollidableObject ( layer : int , mask : int ): filter_by_mask() \u00b6 def filter_by_mask ( self , targets : Tuple [ seagulls . engine . _collisions . CollidableObject , ... ] ) -> Tuple [ seagulls . engine . _collisions . CollidableObject , ... ]: View Source def filter_by_mask ( self , targets : Tuple [ \"CollidableObject\" , ... ]) -> Tuple [ \"CollidableObject\" , ... ]: result = [] for t in targets : if self . is_in_mask ( t ): result . append ( t ) return tuple ( result ) is_in_mask() \u00b6 def is_in_mask ( self , target : seagulls . engine . _collisions . CollidableObject ) -> bool : View Source def is_in_mask ( self , target : \"CollidableObject\" ) -> bool : logger . debug ( f \"targeting items located in mask: { self . mask : b } \" ) logger . debug ( f \"target is located in layer: { target . layer : b } \" ) logger . debug ( f \"& result: { self . mask & target . layer : b } \" ) return self . mask & target . layer > 0 IGameScene \u00b6 class IGameScene ( abc . ABC ): This class is for X and Y. View Source class IGameScene ( ABC ): \"\"\" This class is for X and Y. \"\"\" @abstractmethod def start ( self ) -> None : pass @abstractmethod def should_quit ( self ) -> bool : pass @abstractmethod def tick ( self ) -> None : pass start() \u00b6 @abstractmethod def start ( self ) -> None : View Source @abstractmethod def start ( self ) -> None : pass should_quit() \u00b6 @abstractmethod def should_quit ( self ) -> bool : View Source @abstractmethod def should_quit ( self ) -> bool : pass tick() \u00b6 @abstractmethod def tick ( self ) -> None : View Source @abstractmethod def tick ( self ) -> None : pass IProvideGameScenes \u00b6 class IProvideGameScenes ( abc . ABC ): Helper class that provides a standard way to create an ABC using inheritance. View Source class IProvideGameScenes ( ABC ): @abstractmethod def get_scene ( self ) -> IGameScene : pass get_scene() \u00b6 @abstractmethod def get_scene ( self ) -> seagulls . engine . _game_scene . IGameScene : View Source @abstractmethod def get_scene ( self ) -> IGameScene : pass IProvideGameSessions \u00b6 class IProvideGameSessions ( abc . ABC ): Helper class that provides a standard way to create an ABC using inheritance. View Source class IProvideGameSessions ( ABC ): @abstractmethod def get_session ( self , scene : str ) -> IGameSession : pass get_session() \u00b6 @abstractmethod def get_session ( self , scene : str ) -> seagulls . engine . _game_session . IGameSession : View Source @abstractmethod def get_session ( self , scene : str ) -> IGameSession : pass IGameSession \u00b6 class IGameSession ( abc . ABC ): Helper class that provides a standard way to create an ABC using inheritance. View Source class IGameSession ( ABC ): @abstractmethod def start ( self ) -> None : pass @abstractmethod def wait_for_completion ( self ) -> None : pass @abstractmethod def stop ( self ) -> None : pass start() \u00b6 @abstractmethod def start ( self ) -> None : View Source @abstractmethod def start ( self ) -> None : pass wait_for_completion() \u00b6 @abstractmethod def wait_for_completion ( self ) -> None : View Source @abstractmethod def wait_for_completion ( self ) -> None : pass stop() \u00b6 @abstractmethod def stop ( self ) -> None : View Source @abstractmethod def stop ( self ) -> None : pass SurfaceRenderer \u00b6 class SurfaceRenderer : View Source class SurfaceRenderer : def start ( self ) -> None : self . _get_surface () def render ( self , surface : Surface ) -> None : self . _get_surface () . blit ( surface , ( 0 , 0 )) pygame . display . flip () @lru_cache () def _get_surface ( self ) -> Surface : return pygame . display . set_mode (( 1024 , 600 )) SurfaceRenderer() \u00b6 SurfaceRenderer (): start() \u00b6 def start ( self ) -> None : View Source def start ( self ) -> None : self . _get_surface () render() \u00b6 def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : Surface ) -> None : self . _get_surface () . blit ( surface , ( 0 , 0 )) pygame . display . flip () GameClock \u00b6 class GameClock ( seagulls . engine . _game_object . GameObject ): Interface for anything representing an object in the scene. View Source class GameClock ( GameObject ): _clock : Clock _ticks : int _delta : int def __init__ ( self ): self . _clock = Clock () self . _ticks = 0 self . _delta = 0 def tick ( self ) -> None : self . _delta = self . _clock . tick () def render ( self , surface : Surface ) -> None : pass def get_time ( self ) -> int : return self . _delta def get_fps ( self ) -> float : return self . _clock . get_fps () GameClock() \u00b6 GameClock (): View Source def __init__ ( self ): self . _clock = Clock () self . _ticks = 0 self . _delta = 0 tick() \u00b6 def tick ( self ) -> None : View Source def tick ( self ) -> None : self . _delta = self . _clock . tick () render() \u00b6 def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : Surface ) -> None : pass get_time() \u00b6 def get_time ( self ) -> int : View Source def get_time ( self ) -> int : return self . _delta get_fps() \u00b6 def get_fps ( self ) -> float : View Source def get_fps ( self ) -> float : return self . _clock . get_fps () GameControls \u00b6 class GameControls ( seagulls . engine . _game_object . GameObject ): Interface for anything representing an object in the scene. View Source class GameControls ( GameObject ): _events : List [ Event ] def __init__ ( self ): self . _events = [] def tick ( self ): self . _events = pygame . event . get () def should_quit ( self ) -> bool : for event in self . _events : if event . type == pygame . QUIT : return True if self . _is_key_down_event ( event , pygame . K_ESCAPE ): return True return False def should_fire ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_SPACE ): return True return False def is_left_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_LEFT ] def is_right_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_RIGHT ] def is_up_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_UP ] def is_down_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_DOWN ] def should_toggle_debug_hud ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_BACKQUOTE ): return True return False def is_click_initialized ( self ) -> bool : for event in self . _events : if not event . type == pygame . MOUSEBUTTONDOWN : continue return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] return False def is_mouse_down ( self ) -> bool : return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] def _is_key_down_event ( self , event : Event , key : int ) -> bool : return event . type == pygame . KEYDOWN and event . key == key def _is_key_up_event ( self , event : Event , key : int ) -> bool : return event . type == pygame . KEYUP and event . key == key def render ( self , surface : Surface ) -> None : pass GameControls() \u00b6 GameControls (): View Source def __init__ ( self ): self . _events = [] tick() \u00b6 def tick ( self ): View Source def tick ( self ): self . _events = pygame . event . get () should_quit() \u00b6 def should_quit ( self ) -> bool : View Source def should_quit ( self ) -> bool : for event in self . _events : if event . type == pygame . QUIT : return True if self . _is_key_down_event ( event , pygame . K_ESCAPE ): return True return False should_fire() \u00b6 def should_fire ( self ) -> bool : View Source def should_fire ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_SPACE ): return True return False is_left_moving() \u00b6 def is_left_moving ( self ) -> bool : View Source def is_left_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_LEFT ] is_right_moving() \u00b6 def is_right_moving ( self ) -> bool : View Source def is_right_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_RIGHT ] is_up_moving() \u00b6 def is_up_moving ( self ) -> bool : View Source def is_up_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_UP ] is_down_moving() \u00b6 def is_down_moving ( self ) -> bool : View Source def is_down_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_DOWN ] should_toggle_debug_hud() \u00b6 def should_toggle_debug_hud ( self ) -> bool : View Source def should_toggle_debug_hud ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_BACKQUOTE ): return True return False is_click_initialized() \u00b6 def is_click_initialized ( self ) -> bool : View Source def is_click_initialized ( self ) -> bool : for event in self . _events : if not event . type == pygame . MOUSEBUTTONDOWN : continue return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] return False is_mouse_down() \u00b6 def is_mouse_down ( self ) -> bool : View Source def is_mouse_down ( self ) -> bool : return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] render() \u00b6 def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : Surface ) -> None : pass GameObject \u00b6 class GameObject ( abc . ABC ): Interface for anything representing an object in the scene. View Source class GameObject ( ABC ): \"\"\" Interface for anything representing an object in the scene. \"\"\" @abstractmethod def tick ( self ) -> None : pass @abstractmethod def render ( self , surface : Surface ) -> None : pass tick() \u00b6 @abstractmethod def tick ( self ) -> None : View Source @abstractmethod def tick ( self ) -> None : pass render() \u00b6 @abstractmethod def render ( self , surface : pygame . Surface ) -> None : View Source @abstractmethod def render ( self , surface : Surface ) -> None : pass GameObjectsCollection \u00b6 class GameObjectsCollection : Data structure that allows you to keep track of objects in the scene. View Source class GameObjectsCollection : \"\"\" Data structure that allows you to keep track of objects in the scene. \"\"\" _game_objects : List [ GameObject ] def __init__ ( self ) -> None : self . _game_objects = [] def add ( self , game_object : GameObject ) -> None : self . _game_objects . append ( game_object ) def apply ( self , func : Callable [[ GameObject ], None ]) -> None : for game_object in self . _game_objects : func ( game_object ) GameObjectsCollection() \u00b6 GameObjectsCollection (): View Source def __init__ ( self ) -> None : self . _game_objects = [] add() \u00b6 def add ( self , game_object : seagulls . engine . _game_object . GameObject ) -> None : View Source def add ( self , game_object : GameObject ) -> None : self . _game_objects . append ( game_object ) apply() \u00b6 def apply ( self , func : Callable [[ seagulls . engine . _game_object . GameObject ], NoneType ] ) -> None : View Source def apply ( self , func : Callable [[ GameObject ], None ]) -> None : for game_object in self . _game_objects : func ( game_object ) GameSettings \u00b6 class GameSettings : View Source class GameSettings : def get_setting ( self , name , default = None ) -> Any : data = self . _load_yaml () return data . get ( name , default ) @lru_cache () def _load_yaml ( self ) -> Dict [ str , Any ]: file = Path . home () / \".config/seagulls.yaml\" if not file . exists (): file . touch () return yaml . safe_load ( file . read_text ()) or {} GameSettings() \u00b6 GameSettings (): get_setting() \u00b6 def get_setting ( self , name , default = None ) -> Any : View Source def get_setting ( self , name , default = None ) -> Any : data = self . _load_yaml () return data . get ( name , default ) Rect \u00b6 class Rect : Rect(left, top, width, height) -> Rect Rect((left, top), (width, height)) -> Rect Rect(object) -> Rect pygame object for storing rectangular coordinates Rect() \u00b6 Rect ( * args , ** kwargs ): normalize() \u00b6 def normalize ( unknown ): normalize() -> None correct negative sizes clip() \u00b6 def clip ( unknown ): clip(Rect) -> Rect crops a rectangle inside another clipline() \u00b6 def clipline ( unknown ): clipline(x1, y1, x2, y2) -> ((cx1, cy1), (cx2, cy2)) clipline(x1, y1, x2, y2) -> () clipline((x1, y1), (x2, y2)) -> ((cx1, cy1), (cx2, cy2)) clipline((x1, y1), (x2, y2)) -> () clipline((x1, y1, x2, y2)) -> ((cx1, cy1), (cx2, cy2)) clipline((x1, y1, x2, y2)) -> () clipline(((x1, y1), (x2, y2))) -> ((cx1, cy1), (cx2, cy2)) clipline(((x1, y1), (x2, y2))) -> () crops a line inside a rectangle clamp() \u00b6 def clamp ( unknown ): clamp(Rect) -> Rect moves the rectangle inside another clamp_ip() \u00b6 def clamp_ip ( unknown ): clamp_ip(Rect) -> None moves the rectangle inside another, in place copy() \u00b6 def copy ( unknown ): copy() -> Rect copy the rectangle fit() \u00b6 def fit ( unknown ): fit(Rect) -> Rect resize and move a rectangle with aspect ratio move() \u00b6 def move ( unknown ): move(x, y) -> Rect moves the rectangle update() \u00b6 def update ( unknown ): update(left, top, width, height) -> None update((left, top), (width, height)) -> None update(object) -> None sets the position and size of the rectangle inflate() \u00b6 def inflate ( unknown ): inflate(x, y) -> Rect grow or shrink the rectangle size union() \u00b6 def union ( unknown ): union(Rect) -> Rect joins two rectangles into one unionall() \u00b6 def unionall ( unknown ): unionall(Rect_sequence) -> Rect the union of many rectangles move_ip() \u00b6 def move_ip ( unknown ): move_ip(x, y) -> None moves the rectangle, in place inflate_ip() \u00b6 def inflate_ip ( unknown ): inflate_ip(x, y) -> None grow or shrink the rectangle size, in place union_ip() \u00b6 def union_ip ( unknown ): union_ip(Rect) -> None joins two rectangles into one, in place unionall_ip() \u00b6 def unionall_ip ( unknown ): unionall_ip(Rect_sequence) -> None the union of many rectangles, in place collidepoint() \u00b6 def collidepoint ( unknown ): collidepoint(x, y) -> bool collidepoint((x,y)) -> bool test if a point is inside a rectangle colliderect() \u00b6 def colliderect ( unknown ): colliderect(Rect) -> bool test if two rectangles overlap collidelist() \u00b6 def collidelist ( unknown ): collidelist(list) -> index test if one rectangle in a list intersects collidelistall() \u00b6 def collidelistall ( unknown ): collidelistall(list) -> indices test if all rectangles in a list intersect collidedict() \u00b6 def collidedict ( unknown ): collidedict(dict) -> (key, value) collidedict(dict) -> None collidedict(dict, use_values=0) -> (key, value) collidedict(dict, use_values=0) -> None test if one rectangle in a dictionary intersects collidedictall() \u00b6 def collidedictall ( unknown ): collidedictall(dict) -> [(key, value), ...] collidedictall(dict, use_values=0) -> [(key, value), ...] test if all rectangles in a dictionary intersect contains() \u00b6 def contains ( unknown ): contains(Rect) -> bool test if one rectangle is inside another x \u00b6 x y \u00b6 y w \u00b6 w h \u00b6 h width \u00b6 width height \u00b6 height top \u00b6 top left \u00b6 left bottom \u00b6 bottom right \u00b6 right centerx \u00b6 centerx centery \u00b6 centery topleft \u00b6 topleft topright \u00b6 topright bottomleft \u00b6 bottomleft bottomright \u00b6 bottomright midtop \u00b6 midtop midleft \u00b6 midleft midbottom \u00b6 midbottom midright \u00b6 midright size \u00b6 size center \u00b6 center Surface \u00b6 class Surface : Surface((width, height), flags=0, depth=0, masks=None) -> Surface Surface((width, height), flags=0, Surface) -> Surface pygame object for representing images Surface() \u00b6 Surface ( * args , ** kwargs ): get_at() \u00b6 def get_at ( unknown ): get_at((x, y)) -> Color get the color value at a single pixel set_at() \u00b6 def set_at ( unknown ): set_at((x, y), Color) -> None set the color value for a single pixel get_at_mapped() \u00b6 def get_at_mapped ( unknown ): get_at_mapped((x, y)) -> Color get the mapped color value at a single pixel map_rgb() \u00b6 def map_rgb ( unknown ): map_rgb(Color) -> mapped_int convert a color into a mapped color value unmap_rgb() \u00b6 def unmap_rgb ( unknown ): unmap_rgb(mapped_int) -> Color convert a mapped integer color value into a Color get_palette() \u00b6 def get_palette ( unknown ): get_palette() -> [RGB, RGB, RGB, ...] get the color index palette for an 8-bit Surface get_palette_at() \u00b6 def get_palette_at ( unknown ): get_palette_at(index) -> RGB get the color for a single entry in a palette set_palette() \u00b6 def set_palette ( unknown ): set_palette([RGB, RGB, RGB, ...]) -> None set the color palette for an 8-bit Surface set_palette_at() \u00b6 def set_palette_at ( unknown ): set_palette_at(index, RGB) -> None set the color for a single index in an 8-bit Surface palette lock() \u00b6 def lock ( unknown ): lock() -> None lock the Surface memory for pixel access unlock() \u00b6 def unlock ( unknown ): unlock() -> None unlock the Surface memory from pixel access mustlock() \u00b6 def mustlock ( unknown ): mustlock() -> bool test if the Surface requires locking get_locked() \u00b6 def get_locked ( unknown ): get_locked() -> bool test if the Surface is current locked get_locks() \u00b6 def get_locks ( unknown ): get_locks() -> tuple Gets the locks for the Surface set_colorkey() \u00b6 def set_colorkey ( unknown ): set_colorkey(Color, flags=0) -> None set_colorkey(None) -> None Set the transparent colorkey get_colorkey() \u00b6 def get_colorkey ( unknown ): get_colorkey() -> RGB or None Get the current transparent colorkey set_alpha() \u00b6 def set_alpha ( unknown ): set_alpha(value, flags=0) -> None set_alpha(None) -> None set the alpha value for the full Surface image get_alpha() \u00b6 def get_alpha ( unknown ): get_alpha() -> int_value get the current Surface transparency value get_blendmode() \u00b6 def get_blendmode ( unknown ): Return the surface's SDL 2 blend mode copy() \u00b6 def copy ( unknown ): copy() -> Surface create a new copy of a Surface convert() \u00b6 def convert ( unknown ): convert(Surface=None) -> Surface convert(depth, flags=0) -> Surface convert(masks, flags=0) -> Surface change the pixel format of an image convert_alpha() \u00b6 def convert_alpha ( unknown ): convert_alpha(Surface) -> Surface convert_alpha() -> Surface change the pixel format of an image including per pixel alphas set_clip() \u00b6 def set_clip ( unknown ): set_clip(rect) -> None set_clip(None) -> None set the current clipping area of the Surface get_clip() \u00b6 def get_clip ( unknown ): get_clip() -> Rect get the current clipping area of the Surface fill() \u00b6 def fill ( unknown ): fill(color, rect=None, special_flags=0) -> Rect fill Surface with a solid color blit() \u00b6 def blit ( unknown ): blit(source, dest, area=None, special_flags=0) -> Rect draw one image onto another blits() \u00b6 def blits ( unknown ): blits(blit_sequence=((source, dest), ...), doreturn=1) -> [Rect, ...] or None blits(((source, dest, area), ...)) -> [Rect, ...] blits(((source, dest, area, special_flags), ...)) -> [Rect, ...] draw many images onto another scroll() \u00b6 def scroll ( unknown ): scroll(dx=0, dy=0) -> None Shift the surface image in place get_flags() \u00b6 def get_flags ( unknown ): get_flags() -> int get the additional flags used for the Surface get_size() \u00b6 def get_size ( unknown ): get_size() -> (width, height) get the dimensions of the Surface get_width() \u00b6 def get_width ( unknown ): get_width() -> width get the width of the Surface get_height() \u00b6 def get_height ( unknown ): get_height() -> height get the height of the Surface get_rect() \u00b6 def get_rect ( unknown ): get_rect(**kwargs) -> Rect get the rectangular area of the Surface get_pitch() \u00b6 def get_pitch ( unknown ): get_pitch() -> int get the number of bytes used per Surface row get_bitsize() \u00b6 def get_bitsize ( unknown ): get_bitsize() -> int get the bit depth of the Surface pixel format get_bytesize() \u00b6 def get_bytesize ( unknown ): get_bytesize() -> int get the bytes used per Surface pixel get_masks() \u00b6 def get_masks ( unknown ): get_masks() -> (R, G, B, A) the bitmasks needed to convert between a color and a mapped integer get_shifts() \u00b6 def get_shifts ( unknown ): get_shifts() -> (R, G, B, A) the bit shifts needed to convert between a color and a mapped integer set_masks() \u00b6 def set_masks ( unknown ): set_masks((r,g,b,a)) -> None set the bitmasks needed to convert between a color and a mapped integer set_shifts() \u00b6 def set_shifts ( unknown ): set_shifts((r,g,b,a)) -> None sets the bit shifts needed to convert between a color and a mapped integer get_losses() \u00b6 def get_losses ( unknown ): get_losses() -> (R, G, B, A) the significant bits used to convert between a color and a mapped integer subsurface() \u00b6 def subsurface ( unknown ): subsurface(Rect) -> Surface create a new surface that references its parent get_offset() \u00b6 def get_offset ( unknown ): get_offset() -> (x, y) find the position of a child subsurface inside a parent get_abs_offset() \u00b6 def get_abs_offset ( unknown ): get_abs_offset() -> (x, y) find the absolute position of a child subsurface inside its top level parent get_parent() \u00b6 def get_parent ( unknown ): get_parent() -> Surface find the parent of a subsurface get_abs_parent() \u00b6 def get_abs_parent ( unknown ): get_abs_parent() -> Surface find the top level parent of a subsurface get_bounding_rect() \u00b6 def get_bounding_rect ( unknown ): get_bounding_rect(min_alpha = 1) -> Rect find the smallest rect containing data get_view() \u00b6 def get_view ( unknown ): get_view(<kind>='2') -> BufferProxy return a buffer view of the Surface's pixels. get_buffer() \u00b6 def get_buffer ( unknown ): get_buffer() -> BufferProxy acquires a buffer object for the pixels of the Surface. Color \u00b6 class Color : Color(r, g, b) -> Color Color(r, g, b, a=255) -> Color Color(color_value) -> Color pygame object for color representations Color() \u00b6 Color ( * args , ** kwargs ): normalize() \u00b6 def normalize ( unknown ): normalize() -> tuple Returns the normalized RGBA values of the Color. correct_gamma() \u00b6 def correct_gamma ( unknown ): correct_gamma (gamma) -> Color Applies a certain gamma value to the Color. set_length() \u00b6 def set_length ( unknown ): set_length(len) -> None Set the number of elements in the Color to 1,2,3, or 4. lerp() \u00b6 def lerp ( unknown ): lerp(Color, float) -> Color returns a linear interpolation to the given Color. premul_alpha() \u00b6 def premul_alpha ( unknown ): premul_alpha() -> Color returns a Color where the r,g,b components have been multiplied by the alpha. update() \u00b6 def update ( unknown ): update(r, g, b) -> None update(r, g, b, a=255) -> None update(color_value) -> None Sets the elements of the color r \u00b6 r r -> int Gets or sets the red value of the Color. g \u00b6 g g -> int Gets or sets the green value of the Color. b \u00b6 b b -> int Gets or sets the blue value of the Color. a \u00b6 a a -> int Gets or sets the alpha value of the Color. hsva \u00b6 hsva hsva -> tuple Gets or sets the HSVA representation of the Color. hsla \u00b6 hsla hsla -> tuple Gets or sets the HSLA representation of the Color. i1i2i3 \u00b6 i1i2i3 i1i2i3 -> tuple Gets or sets the I1I2I3 representation of the Color. cmy \u00b6 cmy cmy -> tuple Gets or sets the CMY representation of the Color. PixelArray \u00b6 class PixelArray : PixelArray(Surface) -> PixelArray pygame object for direct pixel access of surfaces PixelArray() \u00b6 PixelArray (): compare() \u00b6 def compare ( unknown ): compare(array, distance=0, weights=(0.299, 0.587, 0.114)) -> PixelArray Compares the PixelArray with another one. extract() \u00b6 def extract ( unknown ): extract(color, distance=0, weights=(0.299, 0.587, 0.114)) -> PixelArray Extracts the passed color from the PixelArray. make_surface() \u00b6 def make_surface ( unknown ): make_surface() -> Surface Creates a new Surface from the current PixelArray. close() \u00b6 def close ( unknown ): transpose() -> PixelArray Closes the PixelArray, and releases Surface lock. replace() \u00b6 def replace ( unknown ): replace(color, repcolor, distance=0, weights=(0.299, 0.587, 0.114)) -> None Replaces the passed color in the PixelArray with another one. transpose() \u00b6 def transpose ( unknown ): transpose() -> PixelArray Exchanges the x and y axis. surface \u00b6 surface surface -> Surface Gets the Surface the PixelArray uses. itemsize \u00b6 itemsize itemsize -> int Returns the byte size of a pixel array item shape \u00b6 shape shape -> tuple of int's Returns the array size. strides \u00b6 strides strides -> tuple of int's Returns byte offsets for each array dimension. ndim \u00b6 ndim ndim -> int Returns the number of dimensions. Vector2 \u00b6 class Vector2 : Vector2() -> Vector2 Vector2(int) -> Vector2 Vector2(float) -> Vector2 Vector2(Vector2) -> Vector2 Vector2(x, y) -> Vector2 Vector2((x, y)) -> Vector2 a 2-Dimensional Vector Vector2() \u00b6 Vector2 ( * args , ** kwargs ): length() \u00b6 def length ( unknown ): length() -> float returns the Euclidean length of the vector. length_squared() \u00b6 def length_squared ( unknown ): length_squared() -> float returns the squared Euclidean length of the vector. magnitude() \u00b6 def magnitude ( unknown ): magnitude() -> float returns the Euclidean magnitude of the vector. magnitude_squared() \u00b6 def magnitude_squared ( unknown ): magnitude_squared() -> float returns the squared magnitude of the vector. rotate() \u00b6 def rotate ( unknown ): rotate(angle) -> Vector2 rotates a vector by a given angle in degrees. rotate_ip() \u00b6 def rotate_ip ( unknown ): rotate_ip(angle) -> None rotates the vector by a given angle in degrees in place. rotate_rad() \u00b6 def rotate_rad ( unknown ): rotate_rad(angle) -> Vector2 rotates a vector by a given angle in radians. rotate_rad_ip() \u00b6 def rotate_rad_ip ( unknown ): rotate_rad_ip(angle) -> None rotates the vector by a given angle in radians in place. rotate_ip_rad() \u00b6 def rotate_ip_rad ( unknown ): rotate_ip_rad(angle) -> None rotates the vector by a given angle in radians in place. slerp() \u00b6 def slerp ( unknown ): slerp(Vector2, float) -> Vector2 returns a spherical interpolation to the given vector. lerp() \u00b6 def lerp ( unknown ): lerp(Vector2, float) -> Vector2 returns a linear interpolation to the given vector. normalize() \u00b6 def normalize ( unknown ): normalize() -> Vector2 returns a vector with the same direction but length 1. normalize_ip() \u00b6 def normalize_ip ( unknown ): normalize_ip() -> None normalizes the vector in place so that its length is 1. is_normalized() \u00b6 def is_normalized ( unknown ): is_normalized() -> Bool tests if the vector is normalized i.e. has length == 1. cross() \u00b6 def cross ( unknown ): cross(Vector2) -> Vector2 calculates the cross- or vector-product dot() \u00b6 def dot ( unknown ): dot(Vector2) -> float calculates the dot- or scalar-product with the other vector angle_to() \u00b6 def angle_to ( unknown ): angle_to(Vector2) -> float calculates the angle to a given vector in degrees. update() \u00b6 def update ( unknown ): update() -> None update(int) -> None update(float) -> None update(Vector2) -> None update(x, y) -> None update((x, y)) -> None Sets the coordinates of the vector. scale_to_length() \u00b6 def scale_to_length ( unknown ): scale_to_length(float) -> None scales the vector to a given length. reflect() \u00b6 def reflect ( unknown ): reflect(Vector2) -> Vector2 returns a vector reflected of a given normal. reflect_ip() \u00b6 def reflect_ip ( unknown ): reflect_ip(Vector2) -> None reflect the vector of a given normal in place. distance_to() \u00b6 def distance_to ( unknown ): distance_to(Vector2) -> float calculates the Euclidean distance to a given vector. distance_squared_to() \u00b6 def distance_squared_to ( unknown ): distance_squared_to(Vector2) -> float calculates the squared Euclidean distance to a given vector. elementwise() \u00b6 def elementwise ( unknown ): elementwise() -> VectorElementwiseProxy The next operation will be performed elementwise. as_polar() \u00b6 def as_polar ( unknown ): as_polar() -> (r, phi) returns a tuple with radial distance and azimuthal angle. from_polar() \u00b6 def from_polar ( unknown ): from_polar((r, phi)) -> None Sets x and y from a polar coordinates tuple. project() \u00b6 def project ( unknown ): project(Vector2) -> Vector2 projects a vector onto another. copy() \u00b6 def copy ( unknown ): copy() -> Vector2 Returns a copy of itself. epsilon \u00b6 epsilon small value used in comparisons x \u00b6 x y \u00b6 y Vector3 \u00b6 class Vector3 : Vector3() -> Vector3 Vector3(int) -> Vector3 Vector3(float) -> Vector3 Vector3(Vector3) -> Vector3 Vector3(x, y, z) -> Vector3 Vector3((x, y, z)) -> Vector3 a 3-Dimensional Vector Vector3() \u00b6 Vector3 ( * args , ** kwargs ): length() \u00b6 def length ( unknown ): length() -> float returns the Euclidean length of the vector. length_squared() \u00b6 def length_squared ( unknown ): length_squared() -> float returns the squared Euclidean length of the vector. magnitude() \u00b6 def magnitude ( unknown ): magnitude() -> float returns the Euclidean magnitude of the vector. magnitude_squared() \u00b6 def magnitude_squared ( unknown ): magnitude_squared() -> float returns the squared Euclidean magnitude of the vector. rotate() \u00b6 def rotate ( unknown ): rotate(angle, Vector3) -> Vector3 rotates a vector by a given angle in degrees. rotate_ip() \u00b6 def rotate_ip ( unknown ): rotate_ip(angle, Vector3) -> None rotates the vector by a given angle in degrees in place. rotate_rad() \u00b6 def rotate_rad ( unknown ): rotate_rad(angle, Vector3) -> Vector3 rotates a vector by a given angle in radians. rotate_rad_ip() \u00b6 def rotate_rad_ip ( unknown ): rotate_rad_ip(angle, Vector3) -> None rotates the vector by a given angle in radians in place. rotate_ip_rad() \u00b6 def rotate_ip_rad ( unknown ): rotate_ip_rad(angle, Vector3) -> None rotates the vector by a given angle in radians in place. rotate_x() \u00b6 def rotate_x ( unknown ): rotate_x(angle) -> Vector3 rotates a vector around the x-axis by the angle in degrees. rotate_x_ip() \u00b6 def rotate_x_ip ( unknown ): rotate_x_ip(angle) -> None rotates the vector around the x-axis by the angle in degrees in place. rotate_x_rad() \u00b6 def rotate_x_rad ( unknown ): rotate_x_rad(angle) -> Vector3 rotates a vector around the x-axis by the angle in radians. rotate_x_rad_ip() \u00b6 def rotate_x_rad_ip ( unknown ): rotate_x_rad_ip(angle) -> None rotates the vector around the x-axis by the angle in radians in place. rotate_x_ip_rad() \u00b6 def rotate_x_ip_rad ( unknown ): rotate_x_ip_rad(angle) -> None rotates the vector around the x-axis by the angle in radians in place. rotate_y() \u00b6 def rotate_y ( unknown ): rotate_y(angle) -> Vector3 rotates a vector around the y-axis by the angle in degrees. rotate_y_ip() \u00b6 def rotate_y_ip ( unknown ): rotate_y_ip(angle) -> None rotates the vector around the y-axis by the angle in degrees in place. rotate_y_rad() \u00b6 def rotate_y_rad ( unknown ): rotate_y_rad(angle) -> Vector3 rotates a vector around the y-axis by the angle in radians. rotate_y_rad_ip() \u00b6 def rotate_y_rad_ip ( unknown ): rotate_y_rad_ip(angle) -> None rotates the vector around the y-axis by the angle in radians in place. rotate_y_ip_rad() \u00b6 def rotate_y_ip_rad ( unknown ): rotate_y_ip_rad(angle) -> None rotates the vector around the y-axis by the angle in radians in place. rotate_z() \u00b6 def rotate_z ( unknown ): rotate_z(angle) -> Vector3 rotates a vector around the z-axis by the angle in degrees. rotate_z_ip() \u00b6 def rotate_z_ip ( unknown ): rotate_z_ip(angle) -> None rotates the vector around the z-axis by the angle in degrees in place. rotate_z_rad() \u00b6 def rotate_z_rad ( unknown ): rotate_z_rad(angle) -> Vector3 rotates a vector around the z-axis by the angle in radians. rotate_z_rad_ip() \u00b6 def rotate_z_rad_ip ( unknown ): rotate_z_rad_ip(angle) -> None rotates the vector around the z-axis by the angle in radians in place. rotate_z_ip_rad() \u00b6 def rotate_z_ip_rad ( unknown ): rotate_z_ip_rad(angle) -> None rotates the vector around the z-axis by the angle in radians in place. slerp() \u00b6 def slerp ( unknown ): slerp(Vector3, float) -> Vector3 returns a spherical interpolation to the given vector. lerp() \u00b6 def lerp ( unknown ): lerp(Vector3, float) -> Vector3 returns a linear interpolation to the given vector. normalize() \u00b6 def normalize ( unknown ): normalize() -> Vector3 returns a vector with the same direction but length 1. normalize_ip() \u00b6 def normalize_ip ( unknown ): normalize_ip() -> None normalizes the vector in place so that its length is 1. is_normalized() \u00b6 def is_normalized ( unknown ): is_normalized() -> Bool tests if the vector is normalized i.e. has length == 1. cross() \u00b6 def cross ( unknown ): cross(Vector3) -> Vector3 calculates the cross- or vector-product dot() \u00b6 def dot ( unknown ): dot(Vector3) -> float calculates the dot- or scalar-product with the other vector angle_to() \u00b6 def angle_to ( unknown ): angle_to(Vector3) -> float calculates the angle to a given vector in degrees. update() \u00b6 def update ( unknown ): update() -> None update(int) -> None update(float) -> None update(Vector3) -> None update(x, y, z) -> None update((x, y, z)) -> None Sets the coordinates of the vector. scale_to_length() \u00b6 def scale_to_length ( unknown ): scale_to_length(float) -> None scales the vector to a given length. reflect() \u00b6 def reflect ( unknown ): reflect(Vector3) -> Vector3 returns a vector reflected of a given normal. reflect_ip() \u00b6 def reflect_ip ( unknown ): reflect_ip(Vector3) -> None reflect the vector of a given normal in place. distance_to() \u00b6 def distance_to ( unknown ): distance_to(Vector3) -> float calculates the Euclidean distance to a given vector. distance_squared_to() \u00b6 def distance_squared_to ( unknown ): distance_squared_to(Vector3) -> float calculates the squared Euclidean distance to a given vector. elementwise() \u00b6 def elementwise ( unknown ): elementwise() -> VectorElementwiseProxy The next operation will be performed elementwise. as_spherical() \u00b6 def as_spherical ( unknown ): as_spherical() -> (r, theta, phi) returns a tuple with radial distance, inclination and azimuthal angle. from_spherical() \u00b6 def from_spherical ( unknown ): from_spherical((r, theta, phi)) -> None Sets x, y and z from a spherical coordinates 3-tuple. project() \u00b6 def project ( unknown ): project(Vector3) -> Vector3 projects a vector onto another. copy() \u00b6 def copy ( unknown ): copy() -> Vector3 Returns a copy of itself. epsilon \u00b6 epsilon small value used in comparisons x \u00b6 x y \u00b6 y z \u00b6 z","title":"seagulls.engine"},{"location":"api/seagulls-devtools/seagulls/engine/#seagullsengine","text":"Core Engine Components View Source \"\"\"Core Engine Components\"\"\" from ._collisions import CollidableObject , flag_from_string from ._game_clock import GameClock from ._game_controls import GameControls from ._game_object import GameObject , GameObjectsCollection from ._game_scene import IGameScene from ._game_scene_manager import IProvideGameScenes from ._game_session import IGameSession from ._game_session_manager import IProvideGameSessions from ._game_settings import GameSettings from ._pygame import Color , PixelArray , Rect , Surface , Vector2 , Vector3 from ._surface_renderer import SurfaceRenderer __all__ = [ \"flag_from_string\" , \"CollidableObject\" , \"IGameScene\" , \"IProvideGameScenes\" , \"IProvideGameSessions\" , \"IGameSession\" , \"SurfaceRenderer\" , \"GameClock\" , \"GameControls\" , \"GameObject\" , \"GameObjectsCollection\" , \"GameSettings\" , \"Rect\" , \"Surface\" , \"Color\" , \"PixelArray\" , \"Vector2\" , \"Vector3\" , ]","title":"seagulls.engine"},{"location":"api/seagulls-devtools/seagulls/engine/#flag_from_string","text":"def flag_from_string ( value : str ) -> int : View Source def flag_from_string ( value : str ) -> int : if not isinstance ( value , str ): raise ValueError ( f \"Value must be a string of 0s and 1s: { value } \" ) return int ( value , 2 )","title":"flag_from_string()"},{"location":"api/seagulls-devtools/seagulls/engine/#collidableobject","text":"@dataclass ( frozen = True ) class CollidableObject : CollidableObject(layer: int, mask: int) View Source @dataclass ( frozen = True ) class CollidableObject : layer : int mask : int def filter_by_mask ( self , targets : Tuple [ \"CollidableObject\" , ... ]) -> Tuple [ \"CollidableObject\" , ... ]: result = [] for t in targets : if self . is_in_mask ( t ): result . append ( t ) return tuple ( result ) def is_in_mask ( self , target : \"CollidableObject\" ) -> bool : logger . debug ( f \"targeting items located in mask: { self . mask : b } \" ) logger . debug ( f \"target is located in layer: { target . layer : b } \" ) logger . debug ( f \"& result: { self . mask & target . layer : b } \" ) return self . mask & target . layer > 0 def __repr__ ( self ) -> str : return f \" { self . __class__ . __name__ } (layer= { self . layer : b } , mask= { self . mask : b } )\"","title":"CollidableObject"},{"location":"api/seagulls-devtools/seagulls/engine/#collidableobject_1","text":"CollidableObject ( layer : int , mask : int ):","title":"CollidableObject()"},{"location":"api/seagulls-devtools/seagulls/engine/#filter_by_mask","text":"def filter_by_mask ( self , targets : Tuple [ seagulls . engine . _collisions . CollidableObject , ... ] ) -> Tuple [ seagulls . engine . _collisions . CollidableObject , ... ]: View Source def filter_by_mask ( self , targets : Tuple [ \"CollidableObject\" , ... ]) -> Tuple [ \"CollidableObject\" , ... ]: result = [] for t in targets : if self . is_in_mask ( t ): result . append ( t ) return tuple ( result )","title":"filter_by_mask()"},{"location":"api/seagulls-devtools/seagulls/engine/#is_in_mask","text":"def is_in_mask ( self , target : seagulls . engine . _collisions . CollidableObject ) -> bool : View Source def is_in_mask ( self , target : \"CollidableObject\" ) -> bool : logger . debug ( f \"targeting items located in mask: { self . mask : b } \" ) logger . debug ( f \"target is located in layer: { target . layer : b } \" ) logger . debug ( f \"& result: { self . mask & target . layer : b } \" ) return self . mask & target . layer > 0","title":"is_in_mask()"},{"location":"api/seagulls-devtools/seagulls/engine/#igamescene","text":"class IGameScene ( abc . ABC ): This class is for X and Y. View Source class IGameScene ( ABC ): \"\"\" This class is for X and Y. \"\"\" @abstractmethod def start ( self ) -> None : pass @abstractmethod def should_quit ( self ) -> bool : pass @abstractmethod def tick ( self ) -> None : pass","title":"IGameScene"},{"location":"api/seagulls-devtools/seagulls/engine/#start","text":"@abstractmethod def start ( self ) -> None : View Source @abstractmethod def start ( self ) -> None : pass","title":"start()"},{"location":"api/seagulls-devtools/seagulls/engine/#should_quit","text":"@abstractmethod def should_quit ( self ) -> bool : View Source @abstractmethod def should_quit ( self ) -> bool : pass","title":"should_quit()"},{"location":"api/seagulls-devtools/seagulls/engine/#tick","text":"@abstractmethod def tick ( self ) -> None : View Source @abstractmethod def tick ( self ) -> None : pass","title":"tick()"},{"location":"api/seagulls-devtools/seagulls/engine/#iprovidegamescenes","text":"class IProvideGameScenes ( abc . ABC ): Helper class that provides a standard way to create an ABC using inheritance. View Source class IProvideGameScenes ( ABC ): @abstractmethod def get_scene ( self ) -> IGameScene : pass","title":"IProvideGameScenes"},{"location":"api/seagulls-devtools/seagulls/engine/#get_scene","text":"@abstractmethod def get_scene ( self ) -> seagulls . engine . _game_scene . IGameScene : View Source @abstractmethod def get_scene ( self ) -> IGameScene : pass","title":"get_scene()"},{"location":"api/seagulls-devtools/seagulls/engine/#iprovidegamesessions","text":"class IProvideGameSessions ( abc . ABC ): Helper class that provides a standard way to create an ABC using inheritance. View Source class IProvideGameSessions ( ABC ): @abstractmethod def get_session ( self , scene : str ) -> IGameSession : pass","title":"IProvideGameSessions"},{"location":"api/seagulls-devtools/seagulls/engine/#get_session","text":"@abstractmethod def get_session ( self , scene : str ) -> seagulls . engine . _game_session . IGameSession : View Source @abstractmethod def get_session ( self , scene : str ) -> IGameSession : pass","title":"get_session()"},{"location":"api/seagulls-devtools/seagulls/engine/#igamesession","text":"class IGameSession ( abc . ABC ): Helper class that provides a standard way to create an ABC using inheritance. View Source class IGameSession ( ABC ): @abstractmethod def start ( self ) -> None : pass @abstractmethod def wait_for_completion ( self ) -> None : pass @abstractmethod def stop ( self ) -> None : pass","title":"IGameSession"},{"location":"api/seagulls-devtools/seagulls/engine/#start_1","text":"@abstractmethod def start ( self ) -> None : View Source @abstractmethod def start ( self ) -> None : pass","title":"start()"},{"location":"api/seagulls-devtools/seagulls/engine/#wait_for_completion","text":"@abstractmethod def wait_for_completion ( self ) -> None : View Source @abstractmethod def wait_for_completion ( self ) -> None : pass","title":"wait_for_completion()"},{"location":"api/seagulls-devtools/seagulls/engine/#stop","text":"@abstractmethod def stop ( self ) -> None : View Source @abstractmethod def stop ( self ) -> None : pass","title":"stop()"},{"location":"api/seagulls-devtools/seagulls/engine/#surfacerenderer","text":"class SurfaceRenderer : View Source class SurfaceRenderer : def start ( self ) -> None : self . _get_surface () def render ( self , surface : Surface ) -> None : self . _get_surface () . blit ( surface , ( 0 , 0 )) pygame . display . flip () @lru_cache () def _get_surface ( self ) -> Surface : return pygame . display . set_mode (( 1024 , 600 ))","title":"SurfaceRenderer"},{"location":"api/seagulls-devtools/seagulls/engine/#surfacerenderer_1","text":"SurfaceRenderer ():","title":"SurfaceRenderer()"},{"location":"api/seagulls-devtools/seagulls/engine/#start_2","text":"def start ( self ) -> None : View Source def start ( self ) -> None : self . _get_surface ()","title":"start()"},{"location":"api/seagulls-devtools/seagulls/engine/#render","text":"def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : Surface ) -> None : self . _get_surface () . blit ( surface , ( 0 , 0 )) pygame . display . flip ()","title":"render()"},{"location":"api/seagulls-devtools/seagulls/engine/#gameclock","text":"class GameClock ( seagulls . engine . _game_object . GameObject ): Interface for anything representing an object in the scene. View Source class GameClock ( GameObject ): _clock : Clock _ticks : int _delta : int def __init__ ( self ): self . _clock = Clock () self . _ticks = 0 self . _delta = 0 def tick ( self ) -> None : self . _delta = self . _clock . tick () def render ( self , surface : Surface ) -> None : pass def get_time ( self ) -> int : return self . _delta def get_fps ( self ) -> float : return self . _clock . get_fps ()","title":"GameClock"},{"location":"api/seagulls-devtools/seagulls/engine/#gameclock_1","text":"GameClock (): View Source def __init__ ( self ): self . _clock = Clock () self . _ticks = 0 self . _delta = 0","title":"GameClock()"},{"location":"api/seagulls-devtools/seagulls/engine/#tick_1","text":"def tick ( self ) -> None : View Source def tick ( self ) -> None : self . _delta = self . _clock . tick ()","title":"tick()"},{"location":"api/seagulls-devtools/seagulls/engine/#render_1","text":"def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : Surface ) -> None : pass","title":"render()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_time","text":"def get_time ( self ) -> int : View Source def get_time ( self ) -> int : return self . _delta","title":"get_time()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_fps","text":"def get_fps ( self ) -> float : View Source def get_fps ( self ) -> float : return self . _clock . get_fps ()","title":"get_fps()"},{"location":"api/seagulls-devtools/seagulls/engine/#gamecontrols","text":"class GameControls ( seagulls . engine . _game_object . GameObject ): Interface for anything representing an object in the scene. View Source class GameControls ( GameObject ): _events : List [ Event ] def __init__ ( self ): self . _events = [] def tick ( self ): self . _events = pygame . event . get () def should_quit ( self ) -> bool : for event in self . _events : if event . type == pygame . QUIT : return True if self . _is_key_down_event ( event , pygame . K_ESCAPE ): return True return False def should_fire ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_SPACE ): return True return False def is_left_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_LEFT ] def is_right_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_RIGHT ] def is_up_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_UP ] def is_down_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_DOWN ] def should_toggle_debug_hud ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_BACKQUOTE ): return True return False def is_click_initialized ( self ) -> bool : for event in self . _events : if not event . type == pygame . MOUSEBUTTONDOWN : continue return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] return False def is_mouse_down ( self ) -> bool : return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] def _is_key_down_event ( self , event : Event , key : int ) -> bool : return event . type == pygame . KEYDOWN and event . key == key def _is_key_up_event ( self , event : Event , key : int ) -> bool : return event . type == pygame . KEYUP and event . key == key def render ( self , surface : Surface ) -> None : pass","title":"GameControls"},{"location":"api/seagulls-devtools/seagulls/engine/#gamecontrols_1","text":"GameControls (): View Source def __init__ ( self ): self . _events = []","title":"GameControls()"},{"location":"api/seagulls-devtools/seagulls/engine/#tick_2","text":"def tick ( self ): View Source def tick ( self ): self . _events = pygame . event . get ()","title":"tick()"},{"location":"api/seagulls-devtools/seagulls/engine/#should_quit_1","text":"def should_quit ( self ) -> bool : View Source def should_quit ( self ) -> bool : for event in self . _events : if event . type == pygame . QUIT : return True if self . _is_key_down_event ( event , pygame . K_ESCAPE ): return True return False","title":"should_quit()"},{"location":"api/seagulls-devtools/seagulls/engine/#should_fire","text":"def should_fire ( self ) -> bool : View Source def should_fire ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_SPACE ): return True return False","title":"should_fire()"},{"location":"api/seagulls-devtools/seagulls/engine/#is_left_moving","text":"def is_left_moving ( self ) -> bool : View Source def is_left_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_LEFT ]","title":"is_left_moving()"},{"location":"api/seagulls-devtools/seagulls/engine/#is_right_moving","text":"def is_right_moving ( self ) -> bool : View Source def is_right_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_RIGHT ]","title":"is_right_moving()"},{"location":"api/seagulls-devtools/seagulls/engine/#is_up_moving","text":"def is_up_moving ( self ) -> bool : View Source def is_up_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_UP ]","title":"is_up_moving()"},{"location":"api/seagulls-devtools/seagulls/engine/#is_down_moving","text":"def is_down_moving ( self ) -> bool : View Source def is_down_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_DOWN ]","title":"is_down_moving()"},{"location":"api/seagulls-devtools/seagulls/engine/#should_toggle_debug_hud","text":"def should_toggle_debug_hud ( self ) -> bool : View Source def should_toggle_debug_hud ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_BACKQUOTE ): return True return False","title":"should_toggle_debug_hud()"},{"location":"api/seagulls-devtools/seagulls/engine/#is_click_initialized","text":"def is_click_initialized ( self ) -> bool : View Source def is_click_initialized ( self ) -> bool : for event in self . _events : if not event . type == pygame . MOUSEBUTTONDOWN : continue return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] return False","title":"is_click_initialized()"},{"location":"api/seagulls-devtools/seagulls/engine/#is_mouse_down","text":"def is_mouse_down ( self ) -> bool : View Source def is_mouse_down ( self ) -> bool : return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ]","title":"is_mouse_down()"},{"location":"api/seagulls-devtools/seagulls/engine/#render_2","text":"def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : Surface ) -> None : pass","title":"render()"},{"location":"api/seagulls-devtools/seagulls/engine/#gameobject","text":"class GameObject ( abc . ABC ): Interface for anything representing an object in the scene. View Source class GameObject ( ABC ): \"\"\" Interface for anything representing an object in the scene. \"\"\" @abstractmethod def tick ( self ) -> None : pass @abstractmethod def render ( self , surface : Surface ) -> None : pass","title":"GameObject"},{"location":"api/seagulls-devtools/seagulls/engine/#tick_3","text":"@abstractmethod def tick ( self ) -> None : View Source @abstractmethod def tick ( self ) -> None : pass","title":"tick()"},{"location":"api/seagulls-devtools/seagulls/engine/#render_3","text":"@abstractmethod def render ( self , surface : pygame . Surface ) -> None : View Source @abstractmethod def render ( self , surface : Surface ) -> None : pass","title":"render()"},{"location":"api/seagulls-devtools/seagulls/engine/#gameobjectscollection","text":"class GameObjectsCollection : Data structure that allows you to keep track of objects in the scene. View Source class GameObjectsCollection : \"\"\" Data structure that allows you to keep track of objects in the scene. \"\"\" _game_objects : List [ GameObject ] def __init__ ( self ) -> None : self . _game_objects = [] def add ( self , game_object : GameObject ) -> None : self . _game_objects . append ( game_object ) def apply ( self , func : Callable [[ GameObject ], None ]) -> None : for game_object in self . _game_objects : func ( game_object )","title":"GameObjectsCollection"},{"location":"api/seagulls-devtools/seagulls/engine/#gameobjectscollection_1","text":"GameObjectsCollection (): View Source def __init__ ( self ) -> None : self . _game_objects = []","title":"GameObjectsCollection()"},{"location":"api/seagulls-devtools/seagulls/engine/#add","text":"def add ( self , game_object : seagulls . engine . _game_object . GameObject ) -> None : View Source def add ( self , game_object : GameObject ) -> None : self . _game_objects . append ( game_object )","title":"add()"},{"location":"api/seagulls-devtools/seagulls/engine/#apply","text":"def apply ( self , func : Callable [[ seagulls . engine . _game_object . GameObject ], NoneType ] ) -> None : View Source def apply ( self , func : Callable [[ GameObject ], None ]) -> None : for game_object in self . _game_objects : func ( game_object )","title":"apply()"},{"location":"api/seagulls-devtools/seagulls/engine/#gamesettings","text":"class GameSettings : View Source class GameSettings : def get_setting ( self , name , default = None ) -> Any : data = self . _load_yaml () return data . get ( name , default ) @lru_cache () def _load_yaml ( self ) -> Dict [ str , Any ]: file = Path . home () / \".config/seagulls.yaml\" if not file . exists (): file . touch () return yaml . safe_load ( file . read_text ()) or {}","title":"GameSettings"},{"location":"api/seagulls-devtools/seagulls/engine/#gamesettings_1","text":"GameSettings ():","title":"GameSettings()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_setting","text":"def get_setting ( self , name , default = None ) -> Any : View Source def get_setting ( self , name , default = None ) -> Any : data = self . _load_yaml () return data . get ( name , default )","title":"get_setting()"},{"location":"api/seagulls-devtools/seagulls/engine/#rect","text":"class Rect : Rect(left, top, width, height) -> Rect Rect((left, top), (width, height)) -> Rect Rect(object) -> Rect pygame object for storing rectangular coordinates","title":"Rect"},{"location":"api/seagulls-devtools/seagulls/engine/#rect_1","text":"Rect ( * args , ** kwargs ):","title":"Rect()"},{"location":"api/seagulls-devtools/seagulls/engine/#normalize","text":"def normalize ( unknown ): normalize() -> None correct negative sizes","title":"normalize()"},{"location":"api/seagulls-devtools/seagulls/engine/#clip","text":"def clip ( unknown ): clip(Rect) -> Rect crops a rectangle inside another","title":"clip()"},{"location":"api/seagulls-devtools/seagulls/engine/#clipline","text":"def clipline ( unknown ): clipline(x1, y1, x2, y2) -> ((cx1, cy1), (cx2, cy2)) clipline(x1, y1, x2, y2) -> () clipline((x1, y1), (x2, y2)) -> ((cx1, cy1), (cx2, cy2)) clipline((x1, y1), (x2, y2)) -> () clipline((x1, y1, x2, y2)) -> ((cx1, cy1), (cx2, cy2)) clipline((x1, y1, x2, y2)) -> () clipline(((x1, y1), (x2, y2))) -> ((cx1, cy1), (cx2, cy2)) clipline(((x1, y1), (x2, y2))) -> () crops a line inside a rectangle","title":"clipline()"},{"location":"api/seagulls-devtools/seagulls/engine/#clamp","text":"def clamp ( unknown ): clamp(Rect) -> Rect moves the rectangle inside another","title":"clamp()"},{"location":"api/seagulls-devtools/seagulls/engine/#clamp_ip","text":"def clamp_ip ( unknown ): clamp_ip(Rect) -> None moves the rectangle inside another, in place","title":"clamp_ip()"},{"location":"api/seagulls-devtools/seagulls/engine/#copy","text":"def copy ( unknown ): copy() -> Rect copy the rectangle","title":"copy()"},{"location":"api/seagulls-devtools/seagulls/engine/#fit","text":"def fit ( unknown ): fit(Rect) -> Rect resize and move a rectangle with aspect ratio","title":"fit()"},{"location":"api/seagulls-devtools/seagulls/engine/#move","text":"def move ( unknown ): move(x, y) -> Rect moves the rectangle","title":"move()"},{"location":"api/seagulls-devtools/seagulls/engine/#update","text":"def update ( unknown ): update(left, top, width, height) -> None update((left, top), (width, height)) -> None update(object) -> None sets the position and size of the rectangle","title":"update()"},{"location":"api/seagulls-devtools/seagulls/engine/#inflate","text":"def inflate ( unknown ): inflate(x, y) -> Rect grow or shrink the rectangle size","title":"inflate()"},{"location":"api/seagulls-devtools/seagulls/engine/#union","text":"def union ( unknown ): union(Rect) -> Rect joins two rectangles into one","title":"union()"},{"location":"api/seagulls-devtools/seagulls/engine/#unionall","text":"def unionall ( unknown ): unionall(Rect_sequence) -> Rect the union of many rectangles","title":"unionall()"},{"location":"api/seagulls-devtools/seagulls/engine/#move_ip","text":"def move_ip ( unknown ): move_ip(x, y) -> None moves the rectangle, in place","title":"move_ip()"},{"location":"api/seagulls-devtools/seagulls/engine/#inflate_ip","text":"def inflate_ip ( unknown ): inflate_ip(x, y) -> None grow or shrink the rectangle size, in place","title":"inflate_ip()"},{"location":"api/seagulls-devtools/seagulls/engine/#union_ip","text":"def union_ip ( unknown ): union_ip(Rect) -> None joins two rectangles into one, in place","title":"union_ip()"},{"location":"api/seagulls-devtools/seagulls/engine/#unionall_ip","text":"def unionall_ip ( unknown ): unionall_ip(Rect_sequence) -> None the union of many rectangles, in place","title":"unionall_ip()"},{"location":"api/seagulls-devtools/seagulls/engine/#collidepoint","text":"def collidepoint ( unknown ): collidepoint(x, y) -> bool collidepoint((x,y)) -> bool test if a point is inside a rectangle","title":"collidepoint()"},{"location":"api/seagulls-devtools/seagulls/engine/#colliderect","text":"def colliderect ( unknown ): colliderect(Rect) -> bool test if two rectangles overlap","title":"colliderect()"},{"location":"api/seagulls-devtools/seagulls/engine/#collidelist","text":"def collidelist ( unknown ): collidelist(list) -> index test if one rectangle in a list intersects","title":"collidelist()"},{"location":"api/seagulls-devtools/seagulls/engine/#collidelistall","text":"def collidelistall ( unknown ): collidelistall(list) -> indices test if all rectangles in a list intersect","title":"collidelistall()"},{"location":"api/seagulls-devtools/seagulls/engine/#collidedict","text":"def collidedict ( unknown ): collidedict(dict) -> (key, value) collidedict(dict) -> None collidedict(dict, use_values=0) -> (key, value) collidedict(dict, use_values=0) -> None test if one rectangle in a dictionary intersects","title":"collidedict()"},{"location":"api/seagulls-devtools/seagulls/engine/#collidedictall","text":"def collidedictall ( unknown ): collidedictall(dict) -> [(key, value), ...] collidedictall(dict, use_values=0) -> [(key, value), ...] test if all rectangles in a dictionary intersect","title":"collidedictall()"},{"location":"api/seagulls-devtools/seagulls/engine/#contains","text":"def contains ( unknown ): contains(Rect) -> bool test if one rectangle is inside another","title":"contains()"},{"location":"api/seagulls-devtools/seagulls/engine/#x","text":"x","title":"x"},{"location":"api/seagulls-devtools/seagulls/engine/#y","text":"y","title":"y"},{"location":"api/seagulls-devtools/seagulls/engine/#w","text":"w","title":"w"},{"location":"api/seagulls-devtools/seagulls/engine/#h","text":"h","title":"h"},{"location":"api/seagulls-devtools/seagulls/engine/#width","text":"width","title":"width"},{"location":"api/seagulls-devtools/seagulls/engine/#height","text":"height","title":"height"},{"location":"api/seagulls-devtools/seagulls/engine/#top","text":"top","title":"top"},{"location":"api/seagulls-devtools/seagulls/engine/#left","text":"left","title":"left"},{"location":"api/seagulls-devtools/seagulls/engine/#bottom","text":"bottom","title":"bottom"},{"location":"api/seagulls-devtools/seagulls/engine/#right","text":"right","title":"right"},{"location":"api/seagulls-devtools/seagulls/engine/#centerx","text":"centerx","title":"centerx"},{"location":"api/seagulls-devtools/seagulls/engine/#centery","text":"centery","title":"centery"},{"location":"api/seagulls-devtools/seagulls/engine/#topleft","text":"topleft","title":"topleft"},{"location":"api/seagulls-devtools/seagulls/engine/#topright","text":"topright","title":"topright"},{"location":"api/seagulls-devtools/seagulls/engine/#bottomleft","text":"bottomleft","title":"bottomleft"},{"location":"api/seagulls-devtools/seagulls/engine/#bottomright","text":"bottomright","title":"bottomright"},{"location":"api/seagulls-devtools/seagulls/engine/#midtop","text":"midtop","title":"midtop"},{"location":"api/seagulls-devtools/seagulls/engine/#midleft","text":"midleft","title":"midleft"},{"location":"api/seagulls-devtools/seagulls/engine/#midbottom","text":"midbottom","title":"midbottom"},{"location":"api/seagulls-devtools/seagulls/engine/#midright","text":"midright","title":"midright"},{"location":"api/seagulls-devtools/seagulls/engine/#size","text":"size","title":"size"},{"location":"api/seagulls-devtools/seagulls/engine/#center","text":"center","title":"center"},{"location":"api/seagulls-devtools/seagulls/engine/#surface","text":"class Surface : Surface((width, height), flags=0, depth=0, masks=None) -> Surface Surface((width, height), flags=0, Surface) -> Surface pygame object for representing images","title":"Surface"},{"location":"api/seagulls-devtools/seagulls/engine/#surface_1","text":"Surface ( * args , ** kwargs ):","title":"Surface()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_at","text":"def get_at ( unknown ): get_at((x, y)) -> Color get the color value at a single pixel","title":"get_at()"},{"location":"api/seagulls-devtools/seagulls/engine/#set_at","text":"def set_at ( unknown ): set_at((x, y), Color) -> None set the color value for a single pixel","title":"set_at()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_at_mapped","text":"def get_at_mapped ( unknown ): get_at_mapped((x, y)) -> Color get the mapped color value at a single pixel","title":"get_at_mapped()"},{"location":"api/seagulls-devtools/seagulls/engine/#map_rgb","text":"def map_rgb ( unknown ): map_rgb(Color) -> mapped_int convert a color into a mapped color value","title":"map_rgb()"},{"location":"api/seagulls-devtools/seagulls/engine/#unmap_rgb","text":"def unmap_rgb ( unknown ): unmap_rgb(mapped_int) -> Color convert a mapped integer color value into a Color","title":"unmap_rgb()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_palette","text":"def get_palette ( unknown ): get_palette() -> [RGB, RGB, RGB, ...] get the color index palette for an 8-bit Surface","title":"get_palette()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_palette_at","text":"def get_palette_at ( unknown ): get_palette_at(index) -> RGB get the color for a single entry in a palette","title":"get_palette_at()"},{"location":"api/seagulls-devtools/seagulls/engine/#set_palette","text":"def set_palette ( unknown ): set_palette([RGB, RGB, RGB, ...]) -> None set the color palette for an 8-bit Surface","title":"set_palette()"},{"location":"api/seagulls-devtools/seagulls/engine/#set_palette_at","text":"def set_palette_at ( unknown ): set_palette_at(index, RGB) -> None set the color for a single index in an 8-bit Surface palette","title":"set_palette_at()"},{"location":"api/seagulls-devtools/seagulls/engine/#lock","text":"def lock ( unknown ): lock() -> None lock the Surface memory for pixel access","title":"lock()"},{"location":"api/seagulls-devtools/seagulls/engine/#unlock","text":"def unlock ( unknown ): unlock() -> None unlock the Surface memory from pixel access","title":"unlock()"},{"location":"api/seagulls-devtools/seagulls/engine/#mustlock","text":"def mustlock ( unknown ): mustlock() -> bool test if the Surface requires locking","title":"mustlock()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_locked","text":"def get_locked ( unknown ): get_locked() -> bool test if the Surface is current locked","title":"get_locked()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_locks","text":"def get_locks ( unknown ): get_locks() -> tuple Gets the locks for the Surface","title":"get_locks()"},{"location":"api/seagulls-devtools/seagulls/engine/#set_colorkey","text":"def set_colorkey ( unknown ): set_colorkey(Color, flags=0) -> None set_colorkey(None) -> None Set the transparent colorkey","title":"set_colorkey()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_colorkey","text":"def get_colorkey ( unknown ): get_colorkey() -> RGB or None Get the current transparent colorkey","title":"get_colorkey()"},{"location":"api/seagulls-devtools/seagulls/engine/#set_alpha","text":"def set_alpha ( unknown ): set_alpha(value, flags=0) -> None set_alpha(None) -> None set the alpha value for the full Surface image","title":"set_alpha()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_alpha","text":"def get_alpha ( unknown ): get_alpha() -> int_value get the current Surface transparency value","title":"get_alpha()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_blendmode","text":"def get_blendmode ( unknown ): Return the surface's SDL 2 blend mode","title":"get_blendmode()"},{"location":"api/seagulls-devtools/seagulls/engine/#copy_1","text":"def copy ( unknown ): copy() -> Surface create a new copy of a Surface","title":"copy()"},{"location":"api/seagulls-devtools/seagulls/engine/#convert","text":"def convert ( unknown ): convert(Surface=None) -> Surface convert(depth, flags=0) -> Surface convert(masks, flags=0) -> Surface change the pixel format of an image","title":"convert()"},{"location":"api/seagulls-devtools/seagulls/engine/#convert_alpha","text":"def convert_alpha ( unknown ): convert_alpha(Surface) -> Surface convert_alpha() -> Surface change the pixel format of an image including per pixel alphas","title":"convert_alpha()"},{"location":"api/seagulls-devtools/seagulls/engine/#set_clip","text":"def set_clip ( unknown ): set_clip(rect) -> None set_clip(None) -> None set the current clipping area of the Surface","title":"set_clip()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_clip","text":"def get_clip ( unknown ): get_clip() -> Rect get the current clipping area of the Surface","title":"get_clip()"},{"location":"api/seagulls-devtools/seagulls/engine/#fill","text":"def fill ( unknown ): fill(color, rect=None, special_flags=0) -> Rect fill Surface with a solid color","title":"fill()"},{"location":"api/seagulls-devtools/seagulls/engine/#blit","text":"def blit ( unknown ): blit(source, dest, area=None, special_flags=0) -> Rect draw one image onto another","title":"blit()"},{"location":"api/seagulls-devtools/seagulls/engine/#blits","text":"def blits ( unknown ): blits(blit_sequence=((source, dest), ...), doreturn=1) -> [Rect, ...] or None blits(((source, dest, area), ...)) -> [Rect, ...] blits(((source, dest, area, special_flags), ...)) -> [Rect, ...] draw many images onto another","title":"blits()"},{"location":"api/seagulls-devtools/seagulls/engine/#scroll","text":"def scroll ( unknown ): scroll(dx=0, dy=0) -> None Shift the surface image in place","title":"scroll()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_flags","text":"def get_flags ( unknown ): get_flags() -> int get the additional flags used for the Surface","title":"get_flags()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_size","text":"def get_size ( unknown ): get_size() -> (width, height) get the dimensions of the Surface","title":"get_size()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_width","text":"def get_width ( unknown ): get_width() -> width get the width of the Surface","title":"get_width()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_height","text":"def get_height ( unknown ): get_height() -> height get the height of the Surface","title":"get_height()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_rect","text":"def get_rect ( unknown ): get_rect(**kwargs) -> Rect get the rectangular area of the Surface","title":"get_rect()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_pitch","text":"def get_pitch ( unknown ): get_pitch() -> int get the number of bytes used per Surface row","title":"get_pitch()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_bitsize","text":"def get_bitsize ( unknown ): get_bitsize() -> int get the bit depth of the Surface pixel format","title":"get_bitsize()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_bytesize","text":"def get_bytesize ( unknown ): get_bytesize() -> int get the bytes used per Surface pixel","title":"get_bytesize()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_masks","text":"def get_masks ( unknown ): get_masks() -> (R, G, B, A) the bitmasks needed to convert between a color and a mapped integer","title":"get_masks()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_shifts","text":"def get_shifts ( unknown ): get_shifts() -> (R, G, B, A) the bit shifts needed to convert between a color and a mapped integer","title":"get_shifts()"},{"location":"api/seagulls-devtools/seagulls/engine/#set_masks","text":"def set_masks ( unknown ): set_masks((r,g,b,a)) -> None set the bitmasks needed to convert between a color and a mapped integer","title":"set_masks()"},{"location":"api/seagulls-devtools/seagulls/engine/#set_shifts","text":"def set_shifts ( unknown ): set_shifts((r,g,b,a)) -> None sets the bit shifts needed to convert between a color and a mapped integer","title":"set_shifts()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_losses","text":"def get_losses ( unknown ): get_losses() -> (R, G, B, A) the significant bits used to convert between a color and a mapped integer","title":"get_losses()"},{"location":"api/seagulls-devtools/seagulls/engine/#subsurface","text":"def subsurface ( unknown ): subsurface(Rect) -> Surface create a new surface that references its parent","title":"subsurface()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_offset","text":"def get_offset ( unknown ): get_offset() -> (x, y) find the position of a child subsurface inside a parent","title":"get_offset()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_abs_offset","text":"def get_abs_offset ( unknown ): get_abs_offset() -> (x, y) find the absolute position of a child subsurface inside its top level parent","title":"get_abs_offset()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_parent","text":"def get_parent ( unknown ): get_parent() -> Surface find the parent of a subsurface","title":"get_parent()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_abs_parent","text":"def get_abs_parent ( unknown ): get_abs_parent() -> Surface find the top level parent of a subsurface","title":"get_abs_parent()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_bounding_rect","text":"def get_bounding_rect ( unknown ): get_bounding_rect(min_alpha = 1) -> Rect find the smallest rect containing data","title":"get_bounding_rect()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_view","text":"def get_view ( unknown ): get_view(<kind>='2') -> BufferProxy return a buffer view of the Surface's pixels.","title":"get_view()"},{"location":"api/seagulls-devtools/seagulls/engine/#get_buffer","text":"def get_buffer ( unknown ): get_buffer() -> BufferProxy acquires a buffer object for the pixels of the Surface.","title":"get_buffer()"},{"location":"api/seagulls-devtools/seagulls/engine/#color","text":"class Color : Color(r, g, b) -> Color Color(r, g, b, a=255) -> Color Color(color_value) -> Color pygame object for color representations","title":"Color"},{"location":"api/seagulls-devtools/seagulls/engine/#color_1","text":"Color ( * args , ** kwargs ):","title":"Color()"},{"location":"api/seagulls-devtools/seagulls/engine/#normalize_1","text":"def normalize ( unknown ): normalize() -> tuple Returns the normalized RGBA values of the Color.","title":"normalize()"},{"location":"api/seagulls-devtools/seagulls/engine/#correct_gamma","text":"def correct_gamma ( unknown ): correct_gamma (gamma) -> Color Applies a certain gamma value to the Color.","title":"correct_gamma()"},{"location":"api/seagulls-devtools/seagulls/engine/#set_length","text":"def set_length ( unknown ): set_length(len) -> None Set the number of elements in the Color to 1,2,3, or 4.","title":"set_length()"},{"location":"api/seagulls-devtools/seagulls/engine/#lerp","text":"def lerp ( unknown ): lerp(Color, float) -> Color returns a linear interpolation to the given Color.","title":"lerp()"},{"location":"api/seagulls-devtools/seagulls/engine/#premul_alpha","text":"def premul_alpha ( unknown ): premul_alpha() -> Color returns a Color where the r,g,b components have been multiplied by the alpha.","title":"premul_alpha()"},{"location":"api/seagulls-devtools/seagulls/engine/#update_1","text":"def update ( unknown ): update(r, g, b) -> None update(r, g, b, a=255) -> None update(color_value) -> None Sets the elements of the color","title":"update()"},{"location":"api/seagulls-devtools/seagulls/engine/#r","text":"r r -> int Gets or sets the red value of the Color.","title":"r"},{"location":"api/seagulls-devtools/seagulls/engine/#g","text":"g g -> int Gets or sets the green value of the Color.","title":"g"},{"location":"api/seagulls-devtools/seagulls/engine/#b","text":"b b -> int Gets or sets the blue value of the Color.","title":"b"},{"location":"api/seagulls-devtools/seagulls/engine/#a","text":"a a -> int Gets or sets the alpha value of the Color.","title":"a"},{"location":"api/seagulls-devtools/seagulls/engine/#hsva","text":"hsva hsva -> tuple Gets or sets the HSVA representation of the Color.","title":"hsva"},{"location":"api/seagulls-devtools/seagulls/engine/#hsla","text":"hsla hsla -> tuple Gets or sets the HSLA representation of the Color.","title":"hsla"},{"location":"api/seagulls-devtools/seagulls/engine/#i1i2i3","text":"i1i2i3 i1i2i3 -> tuple Gets or sets the I1I2I3 representation of the Color.","title":"i1i2i3"},{"location":"api/seagulls-devtools/seagulls/engine/#cmy","text":"cmy cmy -> tuple Gets or sets the CMY representation of the Color.","title":"cmy"},{"location":"api/seagulls-devtools/seagulls/engine/#pixelarray","text":"class PixelArray : PixelArray(Surface) -> PixelArray pygame object for direct pixel access of surfaces","title":"PixelArray"},{"location":"api/seagulls-devtools/seagulls/engine/#pixelarray_1","text":"PixelArray ():","title":"PixelArray()"},{"location":"api/seagulls-devtools/seagulls/engine/#compare","text":"def compare ( unknown ): compare(array, distance=0, weights=(0.299, 0.587, 0.114)) -> PixelArray Compares the PixelArray with another one.","title":"compare()"},{"location":"api/seagulls-devtools/seagulls/engine/#extract","text":"def extract ( unknown ): extract(color, distance=0, weights=(0.299, 0.587, 0.114)) -> PixelArray Extracts the passed color from the PixelArray.","title":"extract()"},{"location":"api/seagulls-devtools/seagulls/engine/#make_surface","text":"def make_surface ( unknown ): make_surface() -> Surface Creates a new Surface from the current PixelArray.","title":"make_surface()"},{"location":"api/seagulls-devtools/seagulls/engine/#close","text":"def close ( unknown ): transpose() -> PixelArray Closes the PixelArray, and releases Surface lock.","title":"close()"},{"location":"api/seagulls-devtools/seagulls/engine/#replace","text":"def replace ( unknown ): replace(color, repcolor, distance=0, weights=(0.299, 0.587, 0.114)) -> None Replaces the passed color in the PixelArray with another one.","title":"replace()"},{"location":"api/seagulls-devtools/seagulls/engine/#transpose","text":"def transpose ( unknown ): transpose() -> PixelArray Exchanges the x and y axis.","title":"transpose()"},{"location":"api/seagulls-devtools/seagulls/engine/#surface_2","text":"surface surface -> Surface Gets the Surface the PixelArray uses.","title":"surface"},{"location":"api/seagulls-devtools/seagulls/engine/#itemsize","text":"itemsize itemsize -> int Returns the byte size of a pixel array item","title":"itemsize"},{"location":"api/seagulls-devtools/seagulls/engine/#shape","text":"shape shape -> tuple of int's Returns the array size.","title":"shape"},{"location":"api/seagulls-devtools/seagulls/engine/#strides","text":"strides strides -> tuple of int's Returns byte offsets for each array dimension.","title":"strides"},{"location":"api/seagulls-devtools/seagulls/engine/#ndim","text":"ndim ndim -> int Returns the number of dimensions.","title":"ndim"},{"location":"api/seagulls-devtools/seagulls/engine/#vector2","text":"class Vector2 : Vector2() -> Vector2 Vector2(int) -> Vector2 Vector2(float) -> Vector2 Vector2(Vector2) -> Vector2 Vector2(x, y) -> Vector2 Vector2((x, y)) -> Vector2 a 2-Dimensional Vector","title":"Vector2"},{"location":"api/seagulls-devtools/seagulls/engine/#vector2_1","text":"Vector2 ( * args , ** kwargs ):","title":"Vector2()"},{"location":"api/seagulls-devtools/seagulls/engine/#length","text":"def length ( unknown ): length() -> float returns the Euclidean length of the vector.","title":"length()"},{"location":"api/seagulls-devtools/seagulls/engine/#length_squared","text":"def length_squared ( unknown ): length_squared() -> float returns the squared Euclidean length of the vector.","title":"length_squared()"},{"location":"api/seagulls-devtools/seagulls/engine/#magnitude","text":"def magnitude ( unknown ): magnitude() -> float returns the Euclidean magnitude of the vector.","title":"magnitude()"},{"location":"api/seagulls-devtools/seagulls/engine/#magnitude_squared","text":"def magnitude_squared ( unknown ): magnitude_squared() -> float returns the squared magnitude of the vector.","title":"magnitude_squared()"},{"location":"api/seagulls-devtools/seagulls/engine/#rotate","text":"def rotate ( unknown ): rotate(angle) -> Vector2 rotates a vector by a given angle in degrees.","title":"rotate()"},{"location":"api/seagulls-devtools/seagulls/engine/#rotate_ip","text":"def rotate_ip ( unknown ): rotate_ip(angle) -> None rotates the vector by a given angle in degrees in place.","title":"rotate_ip()"},{"location":"api/seagulls-devtools/seagulls/engine/#rotate_rad","text":"def rotate_rad ( unknown ): rotate_rad(angle) -> Vector2 rotates a vector by a given angle in radians.","title":"rotate_rad()"},{"location":"api/seagulls-devtools/seagulls/engine/#rotate_rad_ip","text":"def rotate_rad_ip ( unknown ): rotate_rad_ip(angle) -> None rotates the vector by a given angle in radians in place.","title":"rotate_rad_ip()"},{"location":"api/seagulls-devtools/seagulls/engine/#rotate_ip_rad","text":"def rotate_ip_rad ( unknown ): rotate_ip_rad(angle) -> None rotates the vector by a given angle in radians in place.","title":"rotate_ip_rad()"},{"location":"api/seagulls-devtools/seagulls/engine/#slerp","text":"def slerp ( unknown ): slerp(Vector2, float) -> Vector2 returns a spherical interpolation to the given vector.","title":"slerp()"},{"location":"api/seagulls-devtools/seagulls/engine/#lerp_1","text":"def lerp ( unknown ): lerp(Vector2, float) -> Vector2 returns a linear interpolation to the given vector.","title":"lerp()"},{"location":"api/seagulls-devtools/seagulls/engine/#normalize_2","text":"def normalize ( unknown ): normalize() -> Vector2 returns a vector with the same direction but length 1.","title":"normalize()"},{"location":"api/seagulls-devtools/seagulls/engine/#normalize_ip","text":"def normalize_ip ( unknown ): normalize_ip() -> None normalizes the vector in place so that its length is 1.","title":"normalize_ip()"},{"location":"api/seagulls-devtools/seagulls/engine/#is_normalized","text":"def is_normalized ( unknown ): is_normalized() -> Bool tests if the vector is normalized i.e. has length == 1.","title":"is_normalized()"},{"location":"api/seagulls-devtools/seagulls/engine/#cross","text":"def cross ( unknown ): cross(Vector2) -> Vector2 calculates the cross- or vector-product","title":"cross()"},{"location":"api/seagulls-devtools/seagulls/engine/#dot","text":"def dot ( unknown ): dot(Vector2) -> float calculates the dot- or scalar-product with the other vector","title":"dot()"},{"location":"api/seagulls-devtools/seagulls/engine/#angle_to","text":"def angle_to ( unknown ): angle_to(Vector2) -> float calculates the angle to a given vector in degrees.","title":"angle_to()"},{"location":"api/seagulls-devtools/seagulls/engine/#update_2","text":"def update ( unknown ): update() -> None update(int) -> None update(float) -> None update(Vector2) -> None update(x, y) -> None update((x, y)) -> None Sets the coordinates of the vector.","title":"update()"},{"location":"api/seagulls-devtools/seagulls/engine/#scale_to_length","text":"def scale_to_length ( unknown ): scale_to_length(float) -> None scales the vector to a given length.","title":"scale_to_length()"},{"location":"api/seagulls-devtools/seagulls/engine/#reflect","text":"def reflect ( unknown ): reflect(Vector2) -> Vector2 returns a vector reflected of a given normal.","title":"reflect()"},{"location":"api/seagulls-devtools/seagulls/engine/#reflect_ip","text":"def reflect_ip ( unknown ): reflect_ip(Vector2) -> None reflect the vector of a given normal in place.","title":"reflect_ip()"},{"location":"api/seagulls-devtools/seagulls/engine/#distance_to","text":"def distance_to ( unknown ): distance_to(Vector2) -> float calculates the Euclidean distance to a given vector.","title":"distance_to()"},{"location":"api/seagulls-devtools/seagulls/engine/#distance_squared_to","text":"def distance_squared_to ( unknown ): distance_squared_to(Vector2) -> float calculates the squared Euclidean distance to a given vector.","title":"distance_squared_to()"},{"location":"api/seagulls-devtools/seagulls/engine/#elementwise","text":"def elementwise ( unknown ): elementwise() -> VectorElementwiseProxy The next operation will be performed elementwise.","title":"elementwise()"},{"location":"api/seagulls-devtools/seagulls/engine/#as_polar","text":"def as_polar ( unknown ): as_polar() -> (r, phi) returns a tuple with radial distance and azimuthal angle.","title":"as_polar()"},{"location":"api/seagulls-devtools/seagulls/engine/#from_polar","text":"def from_polar ( unknown ): from_polar((r, phi)) -> None Sets x and y from a polar coordinates tuple.","title":"from_polar()"},{"location":"api/seagulls-devtools/seagulls/engine/#project","text":"def project ( unknown ): project(Vector2) -> Vector2 projects a vector onto another.","title":"project()"},{"location":"api/seagulls-devtools/seagulls/engine/#copy_2","text":"def copy ( unknown ): copy() -> Vector2 Returns a copy of itself.","title":"copy()"},{"location":"api/seagulls-devtools/seagulls/engine/#epsilon","text":"epsilon small value used in comparisons","title":"epsilon"},{"location":"api/seagulls-devtools/seagulls/engine/#x_1","text":"x","title":"x"},{"location":"api/seagulls-devtools/seagulls/engine/#y_1","text":"y","title":"y"},{"location":"api/seagulls-devtools/seagulls/engine/#vector3","text":"class Vector3 : Vector3() -> Vector3 Vector3(int) -> Vector3 Vector3(float) -> Vector3 Vector3(Vector3) -> Vector3 Vector3(x, y, z) -> Vector3 Vector3((x, y, z)) -> Vector3 a 3-Dimensional Vector","title":"Vector3"},{"location":"api/seagulls-devtools/seagulls/engine/#vector3_1","text":"Vector3 ( * args , ** kwargs ):","title":"Vector3()"},{"location":"api/seagulls-devtools/seagulls/engine/#length_1","text":"def length ( unknown ): length() -> float returns the Euclidean length of the vector.","title":"length()"},{"location":"api/seagulls-devtools/seagulls/engine/#length_squared_1","text":"def length_squared ( unknown ): length_squared() -> float returns the squared Euclidean length of the vector.","title":"length_squared()"},{"location":"api/seagulls-devtools/seagulls/engine/#magnitude_1","text":"def magnitude ( unknown ): magnitude() -> float returns the Euclidean magnitude of the vector.","title":"magnitude()"},{"location":"api/seagulls-devtools/seagulls/engine/#magnitude_squared_1","text":"def magnitude_squared ( unknown ): magnitude_squared() -> float returns the squared Euclidean magnitude of the vector.","title":"magnitude_squared()"},{"location":"api/seagulls-devtools/seagulls/engine/#rotate_1","text":"def rotate ( unknown ): rotate(angle, Vector3) -> Vector3 rotates a vector by a given angle in degrees.","title":"rotate()"},{"location":"api/seagulls-devtools/seagulls/engine/#rotate_ip_1","text":"def rotate_ip ( unknown ): rotate_ip(angle, Vector3) -> None rotates the vector by a given angle in degrees in place.","title":"rotate_ip()"},{"location":"api/seagulls-devtools/seagulls/engine/#rotate_rad_1","text":"def rotate_rad ( unknown ): rotate_rad(angle, Vector3) -> Vector3 rotates a vector by a given angle in radians.","title":"rotate_rad()"},{"location":"api/seagulls-devtools/seagulls/engine/#rotate_rad_ip_1","text":"def rotate_rad_ip ( unknown ): rotate_rad_ip(angle, Vector3) -> None rotates the vector by a given angle in radians in place.","title":"rotate_rad_ip()"},{"location":"api/seagulls-devtools/seagulls/engine/#rotate_ip_rad_1","text":"def rotate_ip_rad ( unknown ): rotate_ip_rad(angle, Vector3) -> None rotates the vector by a given angle in radians in place.","title":"rotate_ip_rad()"},{"location":"api/seagulls-devtools/seagulls/engine/#rotate_x","text":"def rotate_x ( unknown ): rotate_x(angle) -> Vector3 rotates a vector around the x-axis by the angle in degrees.","title":"rotate_x()"},{"location":"api/seagulls-devtools/seagulls/engine/#rotate_x_ip","text":"def rotate_x_ip ( unknown ): rotate_x_ip(angle) -> None rotates the vector around the x-axis by the angle in degrees in place.","title":"rotate_x_ip()"},{"location":"api/seagulls-devtools/seagulls/engine/#rotate_x_rad","text":"def rotate_x_rad ( unknown ): rotate_x_rad(angle) -> Vector3 rotates a vector around the x-axis by the angle in radians.","title":"rotate_x_rad()"},{"location":"api/seagulls-devtools/seagulls/engine/#rotate_x_rad_ip","text":"def rotate_x_rad_ip ( unknown ): rotate_x_rad_ip(angle) -> None rotates the vector around the x-axis by the angle in radians in place.","title":"rotate_x_rad_ip()"},{"location":"api/seagulls-devtools/seagulls/engine/#rotate_x_ip_rad","text":"def rotate_x_ip_rad ( unknown ): rotate_x_ip_rad(angle) -> None rotates the vector around the x-axis by the angle in radians in place.","title":"rotate_x_ip_rad()"},{"location":"api/seagulls-devtools/seagulls/engine/#rotate_y","text":"def rotate_y ( unknown ): rotate_y(angle) -> Vector3 rotates a vector around the y-axis by the angle in degrees.","title":"rotate_y()"},{"location":"api/seagulls-devtools/seagulls/engine/#rotate_y_ip","text":"def rotate_y_ip ( unknown ): rotate_y_ip(angle) -> None rotates the vector around the y-axis by the angle in degrees in place.","title":"rotate_y_ip()"},{"location":"api/seagulls-devtools/seagulls/engine/#rotate_y_rad","text":"def rotate_y_rad ( unknown ): rotate_y_rad(angle) -> Vector3 rotates a vector around the y-axis by the angle in radians.","title":"rotate_y_rad()"},{"location":"api/seagulls-devtools/seagulls/engine/#rotate_y_rad_ip","text":"def rotate_y_rad_ip ( unknown ): rotate_y_rad_ip(angle) -> None rotates the vector around the y-axis by the angle in radians in place.","title":"rotate_y_rad_ip()"},{"location":"api/seagulls-devtools/seagulls/engine/#rotate_y_ip_rad","text":"def rotate_y_ip_rad ( unknown ): rotate_y_ip_rad(angle) -> None rotates the vector around the y-axis by the angle in radians in place.","title":"rotate_y_ip_rad()"},{"location":"api/seagulls-devtools/seagulls/engine/#rotate_z","text":"def rotate_z ( unknown ): rotate_z(angle) -> Vector3 rotates a vector around the z-axis by the angle in degrees.","title":"rotate_z()"},{"location":"api/seagulls-devtools/seagulls/engine/#rotate_z_ip","text":"def rotate_z_ip ( unknown ): rotate_z_ip(angle) -> None rotates the vector around the z-axis by the angle in degrees in place.","title":"rotate_z_ip()"},{"location":"api/seagulls-devtools/seagulls/engine/#rotate_z_rad","text":"def rotate_z_rad ( unknown ): rotate_z_rad(angle) -> Vector3 rotates a vector around the z-axis by the angle in radians.","title":"rotate_z_rad()"},{"location":"api/seagulls-devtools/seagulls/engine/#rotate_z_rad_ip","text":"def rotate_z_rad_ip ( unknown ): rotate_z_rad_ip(angle) -> None rotates the vector around the z-axis by the angle in radians in place.","title":"rotate_z_rad_ip()"},{"location":"api/seagulls-devtools/seagulls/engine/#rotate_z_ip_rad","text":"def rotate_z_ip_rad ( unknown ): rotate_z_ip_rad(angle) -> None rotates the vector around the z-axis by the angle in radians in place.","title":"rotate_z_ip_rad()"},{"location":"api/seagulls-devtools/seagulls/engine/#slerp_1","text":"def slerp ( unknown ): slerp(Vector3, float) -> Vector3 returns a spherical interpolation to the given vector.","title":"slerp()"},{"location":"api/seagulls-devtools/seagulls/engine/#lerp_2","text":"def lerp ( unknown ): lerp(Vector3, float) -> Vector3 returns a linear interpolation to the given vector.","title":"lerp()"},{"location":"api/seagulls-devtools/seagulls/engine/#normalize_3","text":"def normalize ( unknown ): normalize() -> Vector3 returns a vector with the same direction but length 1.","title":"normalize()"},{"location":"api/seagulls-devtools/seagulls/engine/#normalize_ip_1","text":"def normalize_ip ( unknown ): normalize_ip() -> None normalizes the vector in place so that its length is 1.","title":"normalize_ip()"},{"location":"api/seagulls-devtools/seagulls/engine/#is_normalized_1","text":"def is_normalized ( unknown ): is_normalized() -> Bool tests if the vector is normalized i.e. has length == 1.","title":"is_normalized()"},{"location":"api/seagulls-devtools/seagulls/engine/#cross_1","text":"def cross ( unknown ): cross(Vector3) -> Vector3 calculates the cross- or vector-product","title":"cross()"},{"location":"api/seagulls-devtools/seagulls/engine/#dot_1","text":"def dot ( unknown ): dot(Vector3) -> float calculates the dot- or scalar-product with the other vector","title":"dot()"},{"location":"api/seagulls-devtools/seagulls/engine/#angle_to_1","text":"def angle_to ( unknown ): angle_to(Vector3) -> float calculates the angle to a given vector in degrees.","title":"angle_to()"},{"location":"api/seagulls-devtools/seagulls/engine/#update_3","text":"def update ( unknown ): update() -> None update(int) -> None update(float) -> None update(Vector3) -> None update(x, y, z) -> None update((x, y, z)) -> None Sets the coordinates of the vector.","title":"update()"},{"location":"api/seagulls-devtools/seagulls/engine/#scale_to_length_1","text":"def scale_to_length ( unknown ): scale_to_length(float) -> None scales the vector to a given length.","title":"scale_to_length()"},{"location":"api/seagulls-devtools/seagulls/engine/#reflect_1","text":"def reflect ( unknown ): reflect(Vector3) -> Vector3 returns a vector reflected of a given normal.","title":"reflect()"},{"location":"api/seagulls-devtools/seagulls/engine/#reflect_ip_1","text":"def reflect_ip ( unknown ): reflect_ip(Vector3) -> None reflect the vector of a given normal in place.","title":"reflect_ip()"},{"location":"api/seagulls-devtools/seagulls/engine/#distance_to_1","text":"def distance_to ( unknown ): distance_to(Vector3) -> float calculates the Euclidean distance to a given vector.","title":"distance_to()"},{"location":"api/seagulls-devtools/seagulls/engine/#distance_squared_to_1","text":"def distance_squared_to ( unknown ): distance_squared_to(Vector3) -> float calculates the squared Euclidean distance to a given vector.","title":"distance_squared_to()"},{"location":"api/seagulls-devtools/seagulls/engine/#elementwise_1","text":"def elementwise ( unknown ): elementwise() -> VectorElementwiseProxy The next operation will be performed elementwise.","title":"elementwise()"},{"location":"api/seagulls-devtools/seagulls/engine/#as_spherical","text":"def as_spherical ( unknown ): as_spherical() -> (r, theta, phi) returns a tuple with radial distance, inclination and azimuthal angle.","title":"as_spherical()"},{"location":"api/seagulls-devtools/seagulls/engine/#from_spherical","text":"def from_spherical ( unknown ): from_spherical((r, theta, phi)) -> None Sets x, y and z from a spherical coordinates 3-tuple.","title":"from_spherical()"},{"location":"api/seagulls-devtools/seagulls/engine/#project_1","text":"def project ( unknown ): project(Vector3) -> Vector3 projects a vector onto another.","title":"project()"},{"location":"api/seagulls-devtools/seagulls/engine/#copy_3","text":"def copy ( unknown ): copy() -> Vector3 Returns a copy of itself.","title":"copy()"},{"location":"api/seagulls-devtools/seagulls/engine/#epsilon_1","text":"epsilon small value used in comparisons","title":"epsilon"},{"location":"api/seagulls-devtools/seagulls/engine/#x_2","text":"x","title":"x"},{"location":"api/seagulls-devtools/seagulls/engine/#y_2","text":"y","title":"y"},{"location":"api/seagulls-devtools/seagulls/engine/#z","text":"z","title":"z"},{"location":"api/seagulls-devtools/seagulls/eventing/","text":"seagulls .eventing \u00b6 View Source from ._interfaces import ( IDispatchEvents , EventType , EventCallbackType , ) __all__ = [ \"IDispatchEvents\" , \"EventType\" , \"EventCallbackType\" , ] IDispatchEvents \u00b6 class IDispatchEvents ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class IDispatchEvents ( Protocol ): @abstractmethod def register_callback ( self , event_type : Type [ EventType ], callback : EventCallbackType ) -> None : ... def trigger_event ( self , event : EventType ) -> None : ... register_callback() \u00b6 @abstractmethod def register_callback ( self , event_type : Type [ ~ EventType ], callback : Callable [[ ~ EventType ], NoneType ] ) -> None : View Source @abstractmethod def register_callback ( self , event_type : Type [ EventType ], callback : EventCallbackType ) -> None : ... trigger_event() \u00b6 def trigger_event ( self , event : ~ EventType ) -> None : View Source def trigger_event ( self , event : EventType ) -> None : ... EventType \u00b6 EventType = ~ EventType EventCallbackType \u00b6 EventCallbackType = typing . Callable [[ ~ EventType ], NoneType ]","title":"seagulls.eventing"},{"location":"api/seagulls-devtools/seagulls/eventing/#seagullseventing","text":"View Source from ._interfaces import ( IDispatchEvents , EventType , EventCallbackType , ) __all__ = [ \"IDispatchEvents\" , \"EventType\" , \"EventCallbackType\" , ]","title":"seagulls.eventing"},{"location":"api/seagulls-devtools/seagulls/eventing/#idispatchevents","text":"class IDispatchEvents ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class IDispatchEvents ( Protocol ): @abstractmethod def register_callback ( self , event_type : Type [ EventType ], callback : EventCallbackType ) -> None : ... def trigger_event ( self , event : EventType ) -> None : ...","title":"IDispatchEvents"},{"location":"api/seagulls-devtools/seagulls/eventing/#register_callback","text":"@abstractmethod def register_callback ( self , event_type : Type [ ~ EventType ], callback : Callable [[ ~ EventType ], NoneType ] ) -> None : View Source @abstractmethod def register_callback ( self , event_type : Type [ EventType ], callback : EventCallbackType ) -> None : ...","title":"register_callback()"},{"location":"api/seagulls-devtools/seagulls/eventing/#trigger_event","text":"def trigger_event ( self , event : ~ EventType ) -> None : View Source def trigger_event ( self , event : EventType ) -> None : ...","title":"trigger_event()"},{"location":"api/seagulls-devtools/seagulls/eventing/#eventtype","text":"EventType = ~ EventType","title":"EventType"},{"location":"api/seagulls-devtools/seagulls/eventing/#eventcallbacktype","text":"EventCallbackType = typing . Callable [[ ~ EventType ], NoneType ]","title":"EventCallbackType"},{"location":"api/seagulls-devtools/seagulls/seagulls_cli/","text":"seagulls .seagulls_cli \u00b6 View Source from ._application import SeagullsCliApplication from ._entry_point import main __all__ = [ \"SeagullsCliApplication\" , \"main\" , ] SeagullsCliApplication \u00b6 class SeagullsCliApplication ( seagulls . app . _app_interfaces . ISeagullsApplicationseagulls . app . _plugin_interfaces . IPluggableSeagullsApplicationseagulls . eventing . _interfaces . IDispatchEvents ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class SeagullsCliApplication ( ISeagullsApplication , IPluggableSeagullsApplication , IDispatchEvents ): _container_repository : DiContainerRepository _plugin_client : ISeagullsPluginClient _logging_client : LoggingClient _request : CliRequest _plugins : Dict [ Any , Any ] _callbacks : Dict [ Any , List [ Any ]] def __init__ ( self , container_repository : DiContainerRepository , plugin_client : ISeagullsPluginClient , logging_client : LoggingClient , request : CliRequest ): self . _container_repository = container_repository self . _plugin_client = plugin_client self . _logging_client = logging_client self . _request = request self . _plugins = {} self . _callbacks = {} def execute ( self ) -> None : self . _plugin_client . register_plugins ( self ) self . trigger_event ( PostPluginRegistrationEvent ()) self . _request . execute ( event_dispatcher = self ) def register_container ( self , key : Type [ ObjectType ], container : ObjectType ) -> None : self . _container_repository . register ( key , container ) def get_container ( self , key : Type [ ObjectType ]) -> ObjectType : return self . _container_repository . get ( key ) def register_callback ( self , event_type : Type [ EventType ], callback : EventCallbackType ) -> None : if event_type not in self . _callbacks : self . _callbacks [ event_type ] = [] self . _callbacks [ event_type ] . append ( callback ) def trigger_event ( self , event : EventType ) -> None : for callback in self . _callbacks . get ( type ( event ), []): callback ( event ) def register_plugin ( self , plugin : ISeagullsApplicationPlugin ) -> None : if type ( plugin ) in self . _plugins : raise DuplicatePluginError ( plugin ) self . _plugins [ type ( plugin )] = plugin plugin . on_registration () @lru_cache () def get_plugin ( self , plugin_type : Type [ PluginType ]) -> PluginType : # type: ignore return self . _plugins [ plugin_type ] def _apply_to_plugins ( self , callback : Callable [[ PluginType ], None ]) -> None : for plugin in self . _plugins . values (): callback ( plugin ) SeagullsCliApplication() \u00b6 SeagullsCliApplication ( container_repository : seagulls . seagulls_cli . _container_repository . DiContainerRepository , plugin_client : seagulls . app . _plugin_interfaces . ISeagullsPluginClient , logging_client : seagulls . seagulls_cli . _logging_client . LoggingClient , request : seagulls . cli . _request . CliRequest ): View Source def __init__ ( self , container_repository : DiContainerRepository , plugin_client : ISeagullsPluginClient , logging_client : LoggingClient , request : CliRequest ): self . _container_repository = container_repository self . _plugin_client = plugin_client self . _logging_client = logging_client self . _request = request self . _plugins = {} self . _callbacks = {} execute() \u00b6 def execute ( self ) -> None : View Source def execute ( self ) -> None : self . _plugin_client . register_plugins ( self ) self . trigger_event ( PostPluginRegistrationEvent ()) self . _request . execute ( event_dispatcher = self ) register_container() \u00b6 def register_container ( self , key : Type [ ~ ObjectType ], container : ~ ObjectType ) -> None : View Source def register_container ( self , key : Type [ ObjectType ], container : ObjectType ) -> None : self . _container_repository . register ( key , container ) get_container() \u00b6 def get_container ( self , key : Type [ ~ ObjectType ]) -> ~ ObjectType : View Source def get_container ( self , key : Type [ ObjectType ]) -> ObjectType : return self . _container_repository . get ( key ) register_callback() \u00b6 def register_callback ( self , event_type : Type [ ~ EventType ], callback : Callable [[ ~ EventType ], NoneType ] ) -> None : View Source def register_callback ( self , event_type : Type [ EventType ], callback : EventCallbackType ) -> None : if event_type not in self . _callbacks : self . _callbacks [ event_type ] = [] self . _callbacks [ event_type ] . append ( callback ) trigger_event() \u00b6 def trigger_event ( self , event : ~ EventType ) -> None : View Source def trigger_event ( self , event : EventType ) -> None : for callback in self . _callbacks . get ( type ( event ), []): callback ( event ) register_plugin() \u00b6 def register_plugin ( self , plugin : seagulls . app . _plugin_interfaces . ISeagullsApplicationPlugin ) -> None : View Source def register_plugin ( self , plugin : ISeagullsApplicationPlugin ) -> None : if type ( plugin ) in self . _plugins : raise DuplicatePluginError ( plugin ) self . _plugins [ type ( plugin )] = plugin plugin . on_registration () get_plugin() \u00b6 @lru_cache () def get_plugin ( self , plugin_type : Type [ ~ PluginType ]) -> ~ PluginType : View Source @lru_cache () def get_plugin ( self , plugin_type : Type [ PluginType ]) -> PluginType : # type: ignore return self . _plugins [ plugin_type ] main() \u00b6 def main (): View Source def main (): di_container = SeagullsAppDiContainer () app = di_container . application () app . execute ()","title":"seagulls.seagulls_cli"},{"location":"api/seagulls-devtools/seagulls/seagulls_cli/#seagullsseagulls_cli","text":"View Source from ._application import SeagullsCliApplication from ._entry_point import main __all__ = [ \"SeagullsCliApplication\" , \"main\" , ]","title":"seagulls.seagulls_cli"},{"location":"api/seagulls-devtools/seagulls/seagulls_cli/#seagullscliapplication","text":"class SeagullsCliApplication ( seagulls . app . _app_interfaces . ISeagullsApplicationseagulls . app . _plugin_interfaces . IPluggableSeagullsApplicationseagulls . eventing . _interfaces . IDispatchEvents ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class SeagullsCliApplication ( ISeagullsApplication , IPluggableSeagullsApplication , IDispatchEvents ): _container_repository : DiContainerRepository _plugin_client : ISeagullsPluginClient _logging_client : LoggingClient _request : CliRequest _plugins : Dict [ Any , Any ] _callbacks : Dict [ Any , List [ Any ]] def __init__ ( self , container_repository : DiContainerRepository , plugin_client : ISeagullsPluginClient , logging_client : LoggingClient , request : CliRequest ): self . _container_repository = container_repository self . _plugin_client = plugin_client self . _logging_client = logging_client self . _request = request self . _plugins = {} self . _callbacks = {} def execute ( self ) -> None : self . _plugin_client . register_plugins ( self ) self . trigger_event ( PostPluginRegistrationEvent ()) self . _request . execute ( event_dispatcher = self ) def register_container ( self , key : Type [ ObjectType ], container : ObjectType ) -> None : self . _container_repository . register ( key , container ) def get_container ( self , key : Type [ ObjectType ]) -> ObjectType : return self . _container_repository . get ( key ) def register_callback ( self , event_type : Type [ EventType ], callback : EventCallbackType ) -> None : if event_type not in self . _callbacks : self . _callbacks [ event_type ] = [] self . _callbacks [ event_type ] . append ( callback ) def trigger_event ( self , event : EventType ) -> None : for callback in self . _callbacks . get ( type ( event ), []): callback ( event ) def register_plugin ( self , plugin : ISeagullsApplicationPlugin ) -> None : if type ( plugin ) in self . _plugins : raise DuplicatePluginError ( plugin ) self . _plugins [ type ( plugin )] = plugin plugin . on_registration () @lru_cache () def get_plugin ( self , plugin_type : Type [ PluginType ]) -> PluginType : # type: ignore return self . _plugins [ plugin_type ] def _apply_to_plugins ( self , callback : Callable [[ PluginType ], None ]) -> None : for plugin in self . _plugins . values (): callback ( plugin )","title":"SeagullsCliApplication"},{"location":"api/seagulls-devtools/seagulls/seagulls_cli/#seagullscliapplication_1","text":"SeagullsCliApplication ( container_repository : seagulls . seagulls_cli . _container_repository . DiContainerRepository , plugin_client : seagulls . app . _plugin_interfaces . ISeagullsPluginClient , logging_client : seagulls . seagulls_cli . _logging_client . LoggingClient , request : seagulls . cli . _request . CliRequest ): View Source def __init__ ( self , container_repository : DiContainerRepository , plugin_client : ISeagullsPluginClient , logging_client : LoggingClient , request : CliRequest ): self . _container_repository = container_repository self . _plugin_client = plugin_client self . _logging_client = logging_client self . _request = request self . _plugins = {} self . _callbacks = {}","title":"SeagullsCliApplication()"},{"location":"api/seagulls-devtools/seagulls/seagulls_cli/#execute","text":"def execute ( self ) -> None : View Source def execute ( self ) -> None : self . _plugin_client . register_plugins ( self ) self . trigger_event ( PostPluginRegistrationEvent ()) self . _request . execute ( event_dispatcher = self )","title":"execute()"},{"location":"api/seagulls-devtools/seagulls/seagulls_cli/#register_container","text":"def register_container ( self , key : Type [ ~ ObjectType ], container : ~ ObjectType ) -> None : View Source def register_container ( self , key : Type [ ObjectType ], container : ObjectType ) -> None : self . _container_repository . register ( key , container )","title":"register_container()"},{"location":"api/seagulls-devtools/seagulls/seagulls_cli/#get_container","text":"def get_container ( self , key : Type [ ~ ObjectType ]) -> ~ ObjectType : View Source def get_container ( self , key : Type [ ObjectType ]) -> ObjectType : return self . _container_repository . get ( key )","title":"get_container()"},{"location":"api/seagulls-devtools/seagulls/seagulls_cli/#register_callback","text":"def register_callback ( self , event_type : Type [ ~ EventType ], callback : Callable [[ ~ EventType ], NoneType ] ) -> None : View Source def register_callback ( self , event_type : Type [ EventType ], callback : EventCallbackType ) -> None : if event_type not in self . _callbacks : self . _callbacks [ event_type ] = [] self . _callbacks [ event_type ] . append ( callback )","title":"register_callback()"},{"location":"api/seagulls-devtools/seagulls/seagulls_cli/#trigger_event","text":"def trigger_event ( self , event : ~ EventType ) -> None : View Source def trigger_event ( self , event : EventType ) -> None : for callback in self . _callbacks . get ( type ( event ), []): callback ( event )","title":"trigger_event()"},{"location":"api/seagulls-devtools/seagulls/seagulls_cli/#register_plugin","text":"def register_plugin ( self , plugin : seagulls . app . _plugin_interfaces . ISeagullsApplicationPlugin ) -> None : View Source def register_plugin ( self , plugin : ISeagullsApplicationPlugin ) -> None : if type ( plugin ) in self . _plugins : raise DuplicatePluginError ( plugin ) self . _plugins [ type ( plugin )] = plugin plugin . on_registration ()","title":"register_plugin()"},{"location":"api/seagulls-devtools/seagulls/seagulls_cli/#get_plugin","text":"@lru_cache () def get_plugin ( self , plugin_type : Type [ ~ PluginType ]) -> ~ PluginType : View Source @lru_cache () def get_plugin ( self , plugin_type : Type [ PluginType ]) -> PluginType : # type: ignore return self . _plugins [ plugin_type ]","title":"get_plugin()"},{"location":"api/seagulls-devtools/seagulls/seagulls_cli/#main","text":"def main (): View Source def main (): di_container = SeagullsAppDiContainer () app = di_container . application () app . execute ()","title":"main()"},{"location":"api/seagulls-engine/seagulls/","text":"seagulls \u00b6","title":"seagulls"},{"location":"api/seagulls-engine/seagulls/#seagulls","text":"","title":"seagulls"},{"location":"api/seagulls-engine/seagulls/app/","text":"seagulls .app \u00b6 View Source from ._app_interfaces import ISeagullsApplication from ._plugin_client import SeagullsEntryPointsPluginsClient from ._plugin_interfaces import ( ApplicationType , PluginType , ISeagullsApplicationPlugin , IPluggableSeagullsApplication , ISeagullsPluginClient , ISeagullsApplicationPluginRegistrant , ) from ._plugin_exceptions import DuplicatePluginError __all__ = [ # App \"ISeagullsApplication\" , # Plugin Client \"SeagullsEntryPointsPluginsClient\" , # App Plugins \"ApplicationType\" , \"PluginType\" , \"ISeagullsApplicationPlugin\" , \"IPluggableSeagullsApplication\" , \"ISeagullsPluginClient\" , \"ISeagullsApplicationPluginRegistrant\" , # Exceptions \"DuplicatePluginError\" , ] ISeagullsApplication \u00b6 class ISeagullsApplication ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class ISeagullsApplication ( Protocol ): @abstractmethod def execute ( self ) -> None : ... execute() \u00b6 @abstractmethod def execute ( self ) -> None : View Source @abstractmethod def execute ( self ) -> None : ... SeagullsEntryPointsPluginsClient \u00b6 class SeagullsEntryPointsPluginsClient ( seagulls . app . _plugin_interfaces . ISeagullsPluginClient ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class SeagullsEntryPointsPluginsClient ( ISeagullsPluginClient ): _entrypoint_name : str def __init__ ( self , entrypoint_name : str ): self . _entrypoint_name = entrypoint_name def register_plugins ( self , application : ApplicationType ) -> None : plugins = entry_points ( group = self . _entrypoint_name ) for plugin in plugins : plugin_ref : Type [ ISeagullsApplicationPluginRegistrant ] = plugin . load () if not issubclass ( plugin_ref , ISeagullsApplicationPluginRegistrant ): raise InvalidPluginError ( plugin ) plugin_ref . register_plugins ( application ) # type: ignore SeagullsEntryPointsPluginsClient() \u00b6 SeagullsEntryPointsPluginsClient ( entrypoint_name : str ): View Source def __init__ ( self , entrypoint_name : str ): self . _entrypoint_name = entrypoint_name register_plugins() \u00b6 def register_plugins ( self , application : - ApplicationType ) -> None : Find all plugins and let them register plugins to the running application. View Source def register_plugins ( self , application : ApplicationType ) -> None : plugins = entry_points ( group = self . _entrypoint_name ) for plugin in plugins : plugin_ref : Type [ ISeagullsApplicationPluginRegistrant ] = plugin . load () if not issubclass ( plugin_ref , ISeagullsApplicationPluginRegistrant ): raise InvalidPluginError ( plugin ) plugin_ref . register_plugins ( application ) # type: ignore ApplicationType \u00b6 ApplicationType = - ApplicationType PluginType \u00b6 PluginType = ~ PluginType ISeagullsApplicationPlugin \u00b6 class ISeagullsApplicationPlugin ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class ISeagullsApplicationPlugin ( Protocol ): @abstractmethod def on_registration ( self ) -> None : \"\"\" Called when the plugin is first registered with the application. \"\"\" on_registration() \u00b6 @abstractmethod def on_registration ( self ) -> None : Called when the plugin is first registered with the application. View Source @abstractmethod def on_registration ( self ) -> None : \"\"\" Called when the plugin is first registered with the application. \"\"\" IPluggableSeagullsApplication \u00b6 class IPluggableSeagullsApplication ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class IPluggableSeagullsApplication ( Protocol ): @abstractmethod def register_plugin ( self , plugin : ISeagullsApplicationPlugin ) -> None : ... @abstractmethod def get_plugin ( self , plugin : Type [ PluginType ]) -> PluginType : ... register_plugin() \u00b6 @abstractmethod def register_plugin ( self , plugin : seagulls . app . _plugin_interfaces . ISeagullsApplicationPlugin ) -> None : View Source @abstractmethod def register_plugin ( self , plugin : ISeagullsApplicationPlugin ) -> None : ... get_plugin() \u00b6 @abstractmethod def get_plugin ( self , plugin : Type [ ~ PluginType ]) -> ~ PluginType : View Source @abstractmethod def get_plugin ( self , plugin : Type [ PluginType ]) -> PluginType : ... ISeagullsPluginClient \u00b6 class ISeagullsPluginClient ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class ISeagullsPluginClient ( Protocol ): @abstractmethod def register_plugins ( self , application : ApplicationType ) -> None : \"\"\" Find all plugins and let them register plugins to the running application. \"\"\" register_plugins() \u00b6 @abstractmethod def register_plugins ( self , application : - ApplicationType ) -> None : Find all plugins and let them register plugins to the running application. View Source @abstractmethod def register_plugins ( self , application : ApplicationType ) -> None : \"\"\" Find all plugins and let them register plugins to the running application. \"\"\" ISeagullsApplicationPluginRegistrant \u00b6 @runtime_checkable class ISeagullsApplicationPluginRegistrant ( typing . Protocol [ - ApplicationType ]): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source @runtime_checkable class ISeagullsApplicationPluginRegistrant ( Protocol [ ApplicationType ]): @staticmethod @abstractmethod def register_plugins ( application : ApplicationType ) -> None : \"\"\" Called at the start of the process for plugin devs to register their plugins in the app. \"\"\" register_plugins() \u00b6 @staticmethod @abstractmethod def register_plugins ( application : - ApplicationType ) -> None : Called at the start of the process for plugin devs to register their plugins in the app. View Source @staticmethod @abstractmethod def register_plugins ( application : ApplicationType ) -> None : \"\"\" Called at the start of the process for plugin devs to register their plugins in the app. \"\"\" DuplicatePluginError \u00b6 class DuplicatePluginError ( builtins . RuntimeError ): Unspecified run-time error. View Source class DuplicatePluginError ( RuntimeError ): plugin : ISeagullsApplicationPlugin def __init__ ( self , plugin : ISeagullsApplicationPlugin ): super () . __init__ ( f \"Duplicate plugin registration detected: { type ( plugin ) } \" ) self . plugin = plugin DuplicatePluginError() \u00b6 DuplicatePluginError ( plugin : seagulls . app . _plugin_interfaces . ISeagullsApplicationPlugin ): View Source def __init__ ( self , plugin : ISeagullsApplicationPlugin ): super () . __init__ ( f \"Duplicate plugin registration detected: { type ( plugin ) } \" ) self . plugin = plugin Inherited Members \u00b6 taken from: builtins:BaseException with_traceback () args","title":"seagulls.app"},{"location":"api/seagulls-engine/seagulls/app/#seagullsapp","text":"View Source from ._app_interfaces import ISeagullsApplication from ._plugin_client import SeagullsEntryPointsPluginsClient from ._plugin_interfaces import ( ApplicationType , PluginType , ISeagullsApplicationPlugin , IPluggableSeagullsApplication , ISeagullsPluginClient , ISeagullsApplicationPluginRegistrant , ) from ._plugin_exceptions import DuplicatePluginError __all__ = [ # App \"ISeagullsApplication\" , # Plugin Client \"SeagullsEntryPointsPluginsClient\" , # App Plugins \"ApplicationType\" , \"PluginType\" , \"ISeagullsApplicationPlugin\" , \"IPluggableSeagullsApplication\" , \"ISeagullsPluginClient\" , \"ISeagullsApplicationPluginRegistrant\" , # Exceptions \"DuplicatePluginError\" , ]","title":"seagulls.app"},{"location":"api/seagulls-engine/seagulls/app/#iseagullsapplication","text":"class ISeagullsApplication ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class ISeagullsApplication ( Protocol ): @abstractmethod def execute ( self ) -> None : ...","title":"ISeagullsApplication"},{"location":"api/seagulls-engine/seagulls/app/#execute","text":"@abstractmethod def execute ( self ) -> None : View Source @abstractmethod def execute ( self ) -> None : ...","title":"execute()"},{"location":"api/seagulls-engine/seagulls/app/#seagullsentrypointspluginsclient","text":"class SeagullsEntryPointsPluginsClient ( seagulls . app . _plugin_interfaces . ISeagullsPluginClient ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class SeagullsEntryPointsPluginsClient ( ISeagullsPluginClient ): _entrypoint_name : str def __init__ ( self , entrypoint_name : str ): self . _entrypoint_name = entrypoint_name def register_plugins ( self , application : ApplicationType ) -> None : plugins = entry_points ( group = self . _entrypoint_name ) for plugin in plugins : plugin_ref : Type [ ISeagullsApplicationPluginRegistrant ] = plugin . load () if not issubclass ( plugin_ref , ISeagullsApplicationPluginRegistrant ): raise InvalidPluginError ( plugin ) plugin_ref . register_plugins ( application ) # type: ignore","title":"SeagullsEntryPointsPluginsClient"},{"location":"api/seagulls-engine/seagulls/app/#seagullsentrypointspluginsclient_1","text":"SeagullsEntryPointsPluginsClient ( entrypoint_name : str ): View Source def __init__ ( self , entrypoint_name : str ): self . _entrypoint_name = entrypoint_name","title":"SeagullsEntryPointsPluginsClient()"},{"location":"api/seagulls-engine/seagulls/app/#register_plugins","text":"def register_plugins ( self , application : - ApplicationType ) -> None : Find all plugins and let them register plugins to the running application. View Source def register_plugins ( self , application : ApplicationType ) -> None : plugins = entry_points ( group = self . _entrypoint_name ) for plugin in plugins : plugin_ref : Type [ ISeagullsApplicationPluginRegistrant ] = plugin . load () if not issubclass ( plugin_ref , ISeagullsApplicationPluginRegistrant ): raise InvalidPluginError ( plugin ) plugin_ref . register_plugins ( application ) # type: ignore","title":"register_plugins()"},{"location":"api/seagulls-engine/seagulls/app/#applicationtype","text":"ApplicationType = - ApplicationType","title":"ApplicationType"},{"location":"api/seagulls-engine/seagulls/app/#plugintype","text":"PluginType = ~ PluginType","title":"PluginType"},{"location":"api/seagulls-engine/seagulls/app/#iseagullsapplicationplugin","text":"class ISeagullsApplicationPlugin ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class ISeagullsApplicationPlugin ( Protocol ): @abstractmethod def on_registration ( self ) -> None : \"\"\" Called when the plugin is first registered with the application. \"\"\"","title":"ISeagullsApplicationPlugin"},{"location":"api/seagulls-engine/seagulls/app/#on_registration","text":"@abstractmethod def on_registration ( self ) -> None : Called when the plugin is first registered with the application. View Source @abstractmethod def on_registration ( self ) -> None : \"\"\" Called when the plugin is first registered with the application. \"\"\"","title":"on_registration()"},{"location":"api/seagulls-engine/seagulls/app/#ipluggableseagullsapplication","text":"class IPluggableSeagullsApplication ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class IPluggableSeagullsApplication ( Protocol ): @abstractmethod def register_plugin ( self , plugin : ISeagullsApplicationPlugin ) -> None : ... @abstractmethod def get_plugin ( self , plugin : Type [ PluginType ]) -> PluginType : ...","title":"IPluggableSeagullsApplication"},{"location":"api/seagulls-engine/seagulls/app/#register_plugin","text":"@abstractmethod def register_plugin ( self , plugin : seagulls . app . _plugin_interfaces . ISeagullsApplicationPlugin ) -> None : View Source @abstractmethod def register_plugin ( self , plugin : ISeagullsApplicationPlugin ) -> None : ...","title":"register_plugin()"},{"location":"api/seagulls-engine/seagulls/app/#get_plugin","text":"@abstractmethod def get_plugin ( self , plugin : Type [ ~ PluginType ]) -> ~ PluginType : View Source @abstractmethod def get_plugin ( self , plugin : Type [ PluginType ]) -> PluginType : ...","title":"get_plugin()"},{"location":"api/seagulls-engine/seagulls/app/#iseagullspluginclient","text":"class ISeagullsPluginClient ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class ISeagullsPluginClient ( Protocol ): @abstractmethod def register_plugins ( self , application : ApplicationType ) -> None : \"\"\" Find all plugins and let them register plugins to the running application. \"\"\"","title":"ISeagullsPluginClient"},{"location":"api/seagulls-engine/seagulls/app/#register_plugins_1","text":"@abstractmethod def register_plugins ( self , application : - ApplicationType ) -> None : Find all plugins and let them register plugins to the running application. View Source @abstractmethod def register_plugins ( self , application : ApplicationType ) -> None : \"\"\" Find all plugins and let them register plugins to the running application. \"\"\"","title":"register_plugins()"},{"location":"api/seagulls-engine/seagulls/app/#iseagullsapplicationpluginregistrant","text":"@runtime_checkable class ISeagullsApplicationPluginRegistrant ( typing . Protocol [ - ApplicationType ]): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source @runtime_checkable class ISeagullsApplicationPluginRegistrant ( Protocol [ ApplicationType ]): @staticmethod @abstractmethod def register_plugins ( application : ApplicationType ) -> None : \"\"\" Called at the start of the process for plugin devs to register their plugins in the app. \"\"\"","title":"ISeagullsApplicationPluginRegistrant"},{"location":"api/seagulls-engine/seagulls/app/#register_plugins_2","text":"@staticmethod @abstractmethod def register_plugins ( application : - ApplicationType ) -> None : Called at the start of the process for plugin devs to register their plugins in the app. View Source @staticmethod @abstractmethod def register_plugins ( application : ApplicationType ) -> None : \"\"\" Called at the start of the process for plugin devs to register their plugins in the app. \"\"\"","title":"register_plugins()"},{"location":"api/seagulls-engine/seagulls/app/#duplicatepluginerror","text":"class DuplicatePluginError ( builtins . RuntimeError ): Unspecified run-time error. View Source class DuplicatePluginError ( RuntimeError ): plugin : ISeagullsApplicationPlugin def __init__ ( self , plugin : ISeagullsApplicationPlugin ): super () . __init__ ( f \"Duplicate plugin registration detected: { type ( plugin ) } \" ) self . plugin = plugin","title":"DuplicatePluginError"},{"location":"api/seagulls-engine/seagulls/app/#duplicatepluginerror_1","text":"DuplicatePluginError ( plugin : seagulls . app . _plugin_interfaces . ISeagullsApplicationPlugin ): View Source def __init__ ( self , plugin : ISeagullsApplicationPlugin ): super () . __init__ ( f \"Duplicate plugin registration detected: { type ( plugin ) } \" ) self . plugin = plugin","title":"DuplicatePluginError()"},{"location":"api/seagulls-engine/seagulls/app/#inherited-members","text":"taken from: builtins:BaseException with_traceback () args","title":"Inherited Members"},{"location":"api/seagulls-engine/seagulls/assets/","text":"seagulls .assets \u00b6 View Source from ._manager import AssetManager __all__ = [ \"AssetManager\" ] AssetManager \u00b6 class AssetManager : Provides basic functionality for loading assets from disk. View Source class AssetManager : \"\"\"Provides basic functionality for loading assets from disk.\"\"\" _assets_path : Path def __init__ ( self , assets_path : Path ): self . _assets_path = assets_path def load_sprite ( self , name : str ) -> Surface : return self . load_png ( f \"sprites/ { name } \" ) def load_png ( self , name : str ) -> Surface : path = self . _assets_path / f \" { name } .png\" loaded_sprite = load ( path . resolve ()) if loaded_sprite . get_alpha () is None : return loaded_sprite . convert () else : return loaded_sprite . convert_alpha () AssetManager() \u00b6 AssetManager ( assets_path : pathlib . Path ): View Source def __init__ ( self , assets_path : Path ): self . _assets_path = assets_path load_sprite() \u00b6 def load_sprite ( self , name : str ) -> pygame . Surface : View Source def load_sprite ( self , name : str ) -> Surface : return self . load_png ( f \"sprites/ { name } \" ) load_png() \u00b6 def load_png ( self , name : str ) -> pygame . Surface : View Source def load_png ( self , name : str ) -> Surface : path = self . _assets_path / f \" { name } .png\" loaded_sprite = load ( path . resolve ()) if loaded_sprite . get_alpha () is None : return loaded_sprite . convert () else : return loaded_sprite . convert_alpha ()","title":"seagulls.assets"},{"location":"api/seagulls-engine/seagulls/assets/#seagullsassets","text":"View Source from ._manager import AssetManager __all__ = [ \"AssetManager\" ]","title":"seagulls.assets"},{"location":"api/seagulls-engine/seagulls/assets/#assetmanager","text":"class AssetManager : Provides basic functionality for loading assets from disk. View Source class AssetManager : \"\"\"Provides basic functionality for loading assets from disk.\"\"\" _assets_path : Path def __init__ ( self , assets_path : Path ): self . _assets_path = assets_path def load_sprite ( self , name : str ) -> Surface : return self . load_png ( f \"sprites/ { name } \" ) def load_png ( self , name : str ) -> Surface : path = self . _assets_path / f \" { name } .png\" loaded_sprite = load ( path . resolve ()) if loaded_sprite . get_alpha () is None : return loaded_sprite . convert () else : return loaded_sprite . convert_alpha ()","title":"AssetManager"},{"location":"api/seagulls-engine/seagulls/assets/#assetmanager_1","text":"AssetManager ( assets_path : pathlib . Path ): View Source def __init__ ( self , assets_path : Path ): self . _assets_path = assets_path","title":"AssetManager()"},{"location":"api/seagulls-engine/seagulls/assets/#load_sprite","text":"def load_sprite ( self , name : str ) -> pygame . Surface : View Source def load_sprite ( self , name : str ) -> Surface : return self . load_png ( f \"sprites/ { name } \" )","title":"load_sprite()"},{"location":"api/seagulls-engine/seagulls/assets/#load_png","text":"def load_png ( self , name : str ) -> pygame . Surface : View Source def load_png ( self , name : str ) -> Surface : path = self . _assets_path / f \" { name } .png\" loaded_sprite = load ( path . resolve ()) if loaded_sprite . get_alpha () is None : return loaded_sprite . convert () else : return loaded_sprite . convert_alpha ()","title":"load_png()"},{"location":"api/seagulls-engine/seagulls/cli/","text":"seagulls .cli \u00b6 View Source from ._request import ( CliRequest , ICliCommand , RequestEnvironment , CliRequestRegistrationEvent , ) __all__ = [ \"CliRequest\" , \"ICliCommand\" , \"RequestEnvironment\" , \"CliRequestRegistrationEvent\" , ] CliRequest \u00b6 class CliRequest : View Source class CliRequest : _file : Path _args : Tuple [ str , ... ] _env : RequestEnvironment def __init__ ( self , file : Path , args : Tuple [ str , ... ], env : RequestEnvironment ): self . _file = file self . _args = args self . _env = env def execute ( self , event_dispatcher : IDispatchEvents ) -> None : # Build the CLI Command Interface parser = ArgumentParser ( description = \"Seagulls CLI Command\" , ) event = CliRequestRegistrationEvent ( parser ) event_dispatcher . trigger_event ( event ) def default_execute () -> None : parser . print_help () parser . set_defaults ( cmd = default_execute ) args = parser . parse_args ( self . _args ) args . cmd () CliRequest() \u00b6 CliRequest ( file : pathlib . Path , args : Tuple [ str , ... ], env : seagulls . cli . _request . RequestEnvironment ): View Source def __init__ ( self , file : Path , args : Tuple [ str , ... ], env : RequestEnvironment ): self . _file = file self . _args = args self . _env = env execute() \u00b6 def execute ( self , event_dispatcher : seagulls . eventing . _interfaces . IDispatchEvents ) -> None : View Source def execute ( self , event_dispatcher : IDispatchEvents ) -> None : # Build the CLI Command Interface parser = ArgumentParser ( description = \"Seagulls CLI Command\" , ) event = CliRequestRegistrationEvent ( parser ) event_dispatcher . trigger_event ( event ) def default_execute () -> None : parser . print_help () parser . set_defaults ( cmd = default_execute ) args = parser . parse_args ( self . _args ) args . cmd () ICliCommand \u00b6 class ICliCommand ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class ICliCommand ( Protocol ): @abstractmethod def configure_parser ( self , parser : ArgumentParser ) -> None : ... @abstractmethod def execute ( self ) -> None : ... configure_parser() \u00b6 @abstractmethod def configure_parser ( self , parser : argparse . ArgumentParser ) -> None : View Source @abstractmethod def configure_parser ( self , parser : ArgumentParser ) -> None : ... execute() \u00b6 @abstractmethod def execute ( self ) -> None : View Source @abstractmethod def execute ( self ) -> None : ... RequestEnvironment \u00b6 class RequestEnvironment : View Source class RequestEnvironment : _values : Dict [ str , str ] def __init__ ( self , values : Tuple [ EnvironmentTuple , ... ]): self . _values = { k : v for k , v in values } def get ( self , name : str , default : str = None ) -> Optional [ str ]: return self . _values . get ( name , default ) def as_dict ( self ) -> Dict [ str , str ]: return self . _values . copy () RequestEnvironment() \u00b6 RequestEnvironment ( values : Tuple [ Tuple [ str , str ], ... ]): View Source def __init__ ( self , values : Tuple [ EnvironmentTuple , ... ]): self . _values = { k : v for k , v in values } get() \u00b6 def get ( self , name : str , default : str = None ) -> Optional [ str ]: View Source def get ( self , name : str , default : str = None ) -> Optional [ str ]: return self . _values . get ( name , default ) as_dict() \u00b6 def as_dict ( self ) -> Dict [ str , str ]: View Source def as_dict ( self ) -> Dict [ str , str ]: return self . _values . copy () CliRequestRegistrationEvent \u00b6 class CliRequestRegistrationEvent : View Source class CliRequestRegistrationEvent : _parser : ArgumentParser def __init__ ( self , parser : ArgumentParser ): self . _parser = parser def register_command ( self , name : str , command : ICliCommand ) -> None : def callback () -> None : command . execute () subparser = self . _get_subparsers () . add_parser ( name = name ) command . configure_parser ( subparser ) subparser . set_defaults ( cmd = callback ) @lru_cache () def _get_subparsers ( self ): return self . _parser . add_subparsers ( title = \"subcommands\" , metavar = None , help = \"\" ) CliRequestRegistrationEvent() \u00b6 CliRequestRegistrationEvent ( parser : argparse . ArgumentParser ): View Source def __init__ ( self , parser : ArgumentParser ): self . _parser = parser register_command() \u00b6 def register_command ( self , name : str , command : seagulls . cli . _request . ICliCommand ) -> None : View Source def register_command ( self , name : str , command : ICliCommand ) -> None : def callback () -> None : command . execute () subparser = self . _get_subparsers () . add_parser ( name = name ) command . configure_parser ( subparser ) subparser . set_defaults ( cmd = callback )","title":"seagulls.cli"},{"location":"api/seagulls-engine/seagulls/cli/#seagullscli","text":"View Source from ._request import ( CliRequest , ICliCommand , RequestEnvironment , CliRequestRegistrationEvent , ) __all__ = [ \"CliRequest\" , \"ICliCommand\" , \"RequestEnvironment\" , \"CliRequestRegistrationEvent\" , ]","title":"seagulls.cli"},{"location":"api/seagulls-engine/seagulls/cli/#clirequest","text":"class CliRequest : View Source class CliRequest : _file : Path _args : Tuple [ str , ... ] _env : RequestEnvironment def __init__ ( self , file : Path , args : Tuple [ str , ... ], env : RequestEnvironment ): self . _file = file self . _args = args self . _env = env def execute ( self , event_dispatcher : IDispatchEvents ) -> None : # Build the CLI Command Interface parser = ArgumentParser ( description = \"Seagulls CLI Command\" , ) event = CliRequestRegistrationEvent ( parser ) event_dispatcher . trigger_event ( event ) def default_execute () -> None : parser . print_help () parser . set_defaults ( cmd = default_execute ) args = parser . parse_args ( self . _args ) args . cmd ()","title":"CliRequest"},{"location":"api/seagulls-engine/seagulls/cli/#clirequest_1","text":"CliRequest ( file : pathlib . Path , args : Tuple [ str , ... ], env : seagulls . cli . _request . RequestEnvironment ): View Source def __init__ ( self , file : Path , args : Tuple [ str , ... ], env : RequestEnvironment ): self . _file = file self . _args = args self . _env = env","title":"CliRequest()"},{"location":"api/seagulls-engine/seagulls/cli/#execute","text":"def execute ( self , event_dispatcher : seagulls . eventing . _interfaces . IDispatchEvents ) -> None : View Source def execute ( self , event_dispatcher : IDispatchEvents ) -> None : # Build the CLI Command Interface parser = ArgumentParser ( description = \"Seagulls CLI Command\" , ) event = CliRequestRegistrationEvent ( parser ) event_dispatcher . trigger_event ( event ) def default_execute () -> None : parser . print_help () parser . set_defaults ( cmd = default_execute ) args = parser . parse_args ( self . _args ) args . cmd ()","title":"execute()"},{"location":"api/seagulls-engine/seagulls/cli/#iclicommand","text":"class ICliCommand ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class ICliCommand ( Protocol ): @abstractmethod def configure_parser ( self , parser : ArgumentParser ) -> None : ... @abstractmethod def execute ( self ) -> None : ...","title":"ICliCommand"},{"location":"api/seagulls-engine/seagulls/cli/#configure_parser","text":"@abstractmethod def configure_parser ( self , parser : argparse . ArgumentParser ) -> None : View Source @abstractmethod def configure_parser ( self , parser : ArgumentParser ) -> None : ...","title":"configure_parser()"},{"location":"api/seagulls-engine/seagulls/cli/#execute_1","text":"@abstractmethod def execute ( self ) -> None : View Source @abstractmethod def execute ( self ) -> None : ...","title":"execute()"},{"location":"api/seagulls-engine/seagulls/cli/#requestenvironment","text":"class RequestEnvironment : View Source class RequestEnvironment : _values : Dict [ str , str ] def __init__ ( self , values : Tuple [ EnvironmentTuple , ... ]): self . _values = { k : v for k , v in values } def get ( self , name : str , default : str = None ) -> Optional [ str ]: return self . _values . get ( name , default ) def as_dict ( self ) -> Dict [ str , str ]: return self . _values . copy ()","title":"RequestEnvironment"},{"location":"api/seagulls-engine/seagulls/cli/#requestenvironment_1","text":"RequestEnvironment ( values : Tuple [ Tuple [ str , str ], ... ]): View Source def __init__ ( self , values : Tuple [ EnvironmentTuple , ... ]): self . _values = { k : v for k , v in values }","title":"RequestEnvironment()"},{"location":"api/seagulls-engine/seagulls/cli/#get","text":"def get ( self , name : str , default : str = None ) -> Optional [ str ]: View Source def get ( self , name : str , default : str = None ) -> Optional [ str ]: return self . _values . get ( name , default )","title":"get()"},{"location":"api/seagulls-engine/seagulls/cli/#as_dict","text":"def as_dict ( self ) -> Dict [ str , str ]: View Source def as_dict ( self ) -> Dict [ str , str ]: return self . _values . copy ()","title":"as_dict()"},{"location":"api/seagulls-engine/seagulls/cli/#clirequestregistrationevent","text":"class CliRequestRegistrationEvent : View Source class CliRequestRegistrationEvent : _parser : ArgumentParser def __init__ ( self , parser : ArgumentParser ): self . _parser = parser def register_command ( self , name : str , command : ICliCommand ) -> None : def callback () -> None : command . execute () subparser = self . _get_subparsers () . add_parser ( name = name ) command . configure_parser ( subparser ) subparser . set_defaults ( cmd = callback ) @lru_cache () def _get_subparsers ( self ): return self . _parser . add_subparsers ( title = \"subcommands\" , metavar = None , help = \"\" )","title":"CliRequestRegistrationEvent"},{"location":"api/seagulls-engine/seagulls/cli/#clirequestregistrationevent_1","text":"CliRequestRegistrationEvent ( parser : argparse . ArgumentParser ): View Source def __init__ ( self , parser : ArgumentParser ): self . _parser = parser","title":"CliRequestRegistrationEvent()"},{"location":"api/seagulls-engine/seagulls/cli/#register_command","text":"def register_command ( self , name : str , command : seagulls . cli . _request . ICliCommand ) -> None : View Source def register_command ( self , name : str , command : ICliCommand ) -> None : def callback () -> None : command . execute () subparser = self . _get_subparsers () . add_parser ( name = name ) command . configure_parser ( subparser ) subparser . set_defaults ( cmd = callback )","title":"register_command()"},{"location":"api/seagulls-engine/seagulls/devtools/","text":"seagulls .devtools \u00b6 View Source from ._cli_entry_point import DevtoolsCliPluginEntryPoint __all__ = [ \"DevtoolsCliPluginEntryPoint\" , ] DevtoolsCliPluginEntryPoint \u00b6 class DevtoolsCliPluginEntryPoint ( seagulls . app . _plugin_interfaces . ISeagullsApplicationPluginRegistrant [ seagulls . seagulls_cli . _application . SeagullsCliApplication ]): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class DevtoolsCliPluginEntryPoint ( ISeagullsApplicationPluginRegistrant [ SeagullsCliApplication ]): @staticmethod def register_plugins ( application : SeagullsCliApplication ) -> None : di_container = SeagullsDevtoolsDiContainer ( application = application ) application . register_plugin ( di_container . plugin ()) register_plugins() \u00b6 @staticmethod def register_plugins ( application : seagulls . seagulls_cli . _application . SeagullsCliApplication ) -> None : Called at the start of the process for plugin devs to register their plugins in the app. View Source @staticmethod def register_plugins ( application : SeagullsCliApplication ) -> None : di_container = SeagullsDevtoolsDiContainer ( application = application ) application . register_plugin ( di_container . plugin ()) Inherited Members \u00b6 taken from: seagulls.app._plugin_interfaces:ISeagullsApplicationPluginRegistrant ISeagullsApplicationPluginRegistrant ( * args , ** kwargs )","title":"seagulls.devtools"},{"location":"api/seagulls-engine/seagulls/devtools/#seagullsdevtools","text":"View Source from ._cli_entry_point import DevtoolsCliPluginEntryPoint __all__ = [ \"DevtoolsCliPluginEntryPoint\" , ]","title":"seagulls.devtools"},{"location":"api/seagulls-engine/seagulls/devtools/#devtoolsclipluginentrypoint","text":"class DevtoolsCliPluginEntryPoint ( seagulls . app . _plugin_interfaces . ISeagullsApplicationPluginRegistrant [ seagulls . seagulls_cli . _application . SeagullsCliApplication ]): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class DevtoolsCliPluginEntryPoint ( ISeagullsApplicationPluginRegistrant [ SeagullsCliApplication ]): @staticmethod def register_plugins ( application : SeagullsCliApplication ) -> None : di_container = SeagullsDevtoolsDiContainer ( application = application ) application . register_plugin ( di_container . plugin ())","title":"DevtoolsCliPluginEntryPoint"},{"location":"api/seagulls-engine/seagulls/devtools/#register_plugins","text":"@staticmethod def register_plugins ( application : seagulls . seagulls_cli . _application . SeagullsCliApplication ) -> None : Called at the start of the process for plugin devs to register their plugins in the app. View Source @staticmethod def register_plugins ( application : SeagullsCliApplication ) -> None : di_container = SeagullsDevtoolsDiContainer ( application = application ) application . register_plugin ( di_container . plugin ())","title":"register_plugins()"},{"location":"api/seagulls-engine/seagulls/devtools/#inherited-members","text":"taken from: seagulls.app._plugin_interfaces:ISeagullsApplicationPluginRegistrant ISeagullsApplicationPluginRegistrant ( * args , ** kwargs )","title":"Inherited Members"},{"location":"api/seagulls-engine/seagulls/engine/","text":"seagulls .engine \u00b6 Core Engine Components View Source \"\"\"Core Engine Components\"\"\" from ._collisions import CollidableObject , flag_from_string from ._game_clock import GameClock from ._game_controls import GameControls from ._game_object import GameObject , GameObjectsCollection from ._game_scene import IGameScene from ._game_scene_manager import IProvideGameScenes from ._game_session import IGameSession from ._game_session_manager import IProvideGameSessions from ._game_settings import GameSettings from ._pygame import Color , PixelArray , Rect , Surface , Vector2 , Vector3 from ._surface_renderer import SurfaceRenderer __all__ = [ \"flag_from_string\" , \"CollidableObject\" , \"IGameScene\" , \"IProvideGameScenes\" , \"IProvideGameSessions\" , \"IGameSession\" , \"SurfaceRenderer\" , \"GameClock\" , \"GameControls\" , \"GameObject\" , \"GameObjectsCollection\" , \"GameSettings\" , \"Rect\" , \"Surface\" , \"Color\" , \"PixelArray\" , \"Vector2\" , \"Vector3\" , ] flag_from_string() \u00b6 def flag_from_string ( value : str ) -> int : View Source def flag_from_string ( value : str ) -> int : if not isinstance ( value , str ): raise ValueError ( f \"Value must be a string of 0s and 1s: { value } \" ) return int ( value , 2 ) CollidableObject \u00b6 @dataclass ( frozen = True ) class CollidableObject : CollidableObject(layer: int, mask: int) View Source @dataclass ( frozen = True ) class CollidableObject : layer : int mask : int def filter_by_mask ( self , targets : Tuple [ \"CollidableObject\" , ... ]) -> Tuple [ \"CollidableObject\" , ... ]: result = [] for t in targets : if self . is_in_mask ( t ): result . append ( t ) return tuple ( result ) def is_in_mask ( self , target : \"CollidableObject\" ) -> bool : logger . debug ( f \"targeting items located in mask: { self . mask : b } \" ) logger . debug ( f \"target is located in layer: { target . layer : b } \" ) logger . debug ( f \"& result: { self . mask & target . layer : b } \" ) return self . mask & target . layer > 0 def __repr__ ( self ) -> str : return f \" { self . __class__ . __name__ } (layer= { self . layer : b } , mask= { self . mask : b } )\" CollidableObject() \u00b6 CollidableObject ( layer : int , mask : int ): filter_by_mask() \u00b6 def filter_by_mask ( self , targets : Tuple [ seagulls . engine . _collisions . CollidableObject , ... ] ) -> Tuple [ seagulls . engine . _collisions . CollidableObject , ... ]: View Source def filter_by_mask ( self , targets : Tuple [ \"CollidableObject\" , ... ]) -> Tuple [ \"CollidableObject\" , ... ]: result = [] for t in targets : if self . is_in_mask ( t ): result . append ( t ) return tuple ( result ) is_in_mask() \u00b6 def is_in_mask ( self , target : seagulls . engine . _collisions . CollidableObject ) -> bool : View Source def is_in_mask ( self , target : \"CollidableObject\" ) -> bool : logger . debug ( f \"targeting items located in mask: { self . mask : b } \" ) logger . debug ( f \"target is located in layer: { target . layer : b } \" ) logger . debug ( f \"& result: { self . mask & target . layer : b } \" ) return self . mask & target . layer > 0 IGameScene \u00b6 class IGameScene ( abc . ABC ): This class is for X and Y. View Source class IGameScene ( ABC ): \"\"\" This class is for X and Y. \"\"\" @abstractmethod def start ( self ) -> None : pass @abstractmethod def should_quit ( self ) -> bool : pass @abstractmethod def tick ( self ) -> None : pass start() \u00b6 @abstractmethod def start ( self ) -> None : View Source @abstractmethod def start ( self ) -> None : pass should_quit() \u00b6 @abstractmethod def should_quit ( self ) -> bool : View Source @abstractmethod def should_quit ( self ) -> bool : pass tick() \u00b6 @abstractmethod def tick ( self ) -> None : View Source @abstractmethod def tick ( self ) -> None : pass IProvideGameScenes \u00b6 class IProvideGameScenes ( abc . ABC ): Helper class that provides a standard way to create an ABC using inheritance. View Source class IProvideGameScenes ( ABC ): @abstractmethod def get_scene ( self ) -> IGameScene : pass get_scene() \u00b6 @abstractmethod def get_scene ( self ) -> seagulls . engine . _game_scene . IGameScene : View Source @abstractmethod def get_scene ( self ) -> IGameScene : pass IProvideGameSessions \u00b6 class IProvideGameSessions ( abc . ABC ): Helper class that provides a standard way to create an ABC using inheritance. View Source class IProvideGameSessions ( ABC ): @abstractmethod def get_session ( self , scene : str ) -> IGameSession : pass get_session() \u00b6 @abstractmethod def get_session ( self , scene : str ) -> seagulls . engine . _game_session . IGameSession : View Source @abstractmethod def get_session ( self , scene : str ) -> IGameSession : pass IGameSession \u00b6 class IGameSession ( abc . ABC ): Helper class that provides a standard way to create an ABC using inheritance. View Source class IGameSession ( ABC ): @abstractmethod def start ( self ) -> None : pass @abstractmethod def wait_for_completion ( self ) -> None : pass @abstractmethod def stop ( self ) -> None : pass start() \u00b6 @abstractmethod def start ( self ) -> None : View Source @abstractmethod def start ( self ) -> None : pass wait_for_completion() \u00b6 @abstractmethod def wait_for_completion ( self ) -> None : View Source @abstractmethod def wait_for_completion ( self ) -> None : pass stop() \u00b6 @abstractmethod def stop ( self ) -> None : View Source @abstractmethod def stop ( self ) -> None : pass SurfaceRenderer \u00b6 class SurfaceRenderer : View Source class SurfaceRenderer : def start ( self ) -> None : self . _get_surface () def render ( self , surface : Surface ) -> None : self . _get_surface () . blit ( surface , ( 0 , 0 )) pygame . display . flip () @lru_cache () def _get_surface ( self ) -> Surface : return pygame . display . set_mode (( 1024 , 600 )) SurfaceRenderer() \u00b6 SurfaceRenderer (): start() \u00b6 def start ( self ) -> None : View Source def start ( self ) -> None : self . _get_surface () render() \u00b6 def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : Surface ) -> None : self . _get_surface () . blit ( surface , ( 0 , 0 )) pygame . display . flip () GameClock \u00b6 class GameClock ( seagulls . engine . _game_object . GameObject ): Interface for anything representing an object in the scene. View Source class GameClock ( GameObject ): _clock : Clock _ticks : int _delta : int def __init__ ( self ): self . _clock = Clock () self . _ticks = 0 self . _delta = 0 def tick ( self ) -> None : self . _delta = self . _clock . tick () def render ( self , surface : Surface ) -> None : pass def get_time ( self ) -> int : return self . _delta def get_fps ( self ) -> float : return self . _clock . get_fps () GameClock() \u00b6 GameClock (): View Source def __init__ ( self ): self . _clock = Clock () self . _ticks = 0 self . _delta = 0 tick() \u00b6 def tick ( self ) -> None : View Source def tick ( self ) -> None : self . _delta = self . _clock . tick () render() \u00b6 def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : Surface ) -> None : pass get_time() \u00b6 def get_time ( self ) -> int : View Source def get_time ( self ) -> int : return self . _delta get_fps() \u00b6 def get_fps ( self ) -> float : View Source def get_fps ( self ) -> float : return self . _clock . get_fps () GameControls \u00b6 class GameControls ( seagulls . engine . _game_object . GameObject ): Interface for anything representing an object in the scene. View Source class GameControls ( GameObject ): _events : List [ Event ] def __init__ ( self ): self . _events = [] def tick ( self ): self . _events = pygame . event . get () def should_quit ( self ) -> bool : for event in self . _events : if event . type == pygame . QUIT : return True if self . _is_key_down_event ( event , pygame . K_ESCAPE ): return True return False def should_fire ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_SPACE ): return True return False def is_left_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_LEFT ] def is_right_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_RIGHT ] def is_up_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_UP ] def is_down_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_DOWN ] def should_toggle_debug_hud ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_BACKQUOTE ): return True return False def is_click_initialized ( self ) -> bool : for event in self . _events : if not event . type == pygame . MOUSEBUTTONDOWN : continue return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] return False def is_mouse_down ( self ) -> bool : return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] def _is_key_down_event ( self , event : Event , key : int ) -> bool : return event . type == pygame . KEYDOWN and event . key == key def _is_key_up_event ( self , event : Event , key : int ) -> bool : return event . type == pygame . KEYUP and event . key == key def render ( self , surface : Surface ) -> None : pass GameControls() \u00b6 GameControls (): View Source def __init__ ( self ): self . _events = [] tick() \u00b6 def tick ( self ): View Source def tick ( self ): self . _events = pygame . event . get () should_quit() \u00b6 def should_quit ( self ) -> bool : View Source def should_quit ( self ) -> bool : for event in self . _events : if event . type == pygame . QUIT : return True if self . _is_key_down_event ( event , pygame . K_ESCAPE ): return True return False should_fire() \u00b6 def should_fire ( self ) -> bool : View Source def should_fire ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_SPACE ): return True return False is_left_moving() \u00b6 def is_left_moving ( self ) -> bool : View Source def is_left_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_LEFT ] is_right_moving() \u00b6 def is_right_moving ( self ) -> bool : View Source def is_right_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_RIGHT ] is_up_moving() \u00b6 def is_up_moving ( self ) -> bool : View Source def is_up_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_UP ] is_down_moving() \u00b6 def is_down_moving ( self ) -> bool : View Source def is_down_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_DOWN ] should_toggle_debug_hud() \u00b6 def should_toggle_debug_hud ( self ) -> bool : View Source def should_toggle_debug_hud ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_BACKQUOTE ): return True return False is_click_initialized() \u00b6 def is_click_initialized ( self ) -> bool : View Source def is_click_initialized ( self ) -> bool : for event in self . _events : if not event . type == pygame . MOUSEBUTTONDOWN : continue return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] return False is_mouse_down() \u00b6 def is_mouse_down ( self ) -> bool : View Source def is_mouse_down ( self ) -> bool : return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] render() \u00b6 def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : Surface ) -> None : pass GameObject \u00b6 class GameObject ( abc . ABC ): Interface for anything representing an object in the scene. View Source class GameObject ( ABC ): \"\"\" Interface for anything representing an object in the scene. \"\"\" @abstractmethod def tick ( self ) -> None : pass @abstractmethod def render ( self , surface : Surface ) -> None : pass tick() \u00b6 @abstractmethod def tick ( self ) -> None : View Source @abstractmethod def tick ( self ) -> None : pass render() \u00b6 @abstractmethod def render ( self , surface : pygame . Surface ) -> None : View Source @abstractmethod def render ( self , surface : Surface ) -> None : pass GameObjectsCollection \u00b6 class GameObjectsCollection : Data structure that allows you to keep track of objects in the scene. View Source class GameObjectsCollection : \"\"\" Data structure that allows you to keep track of objects in the scene. \"\"\" _game_objects : List [ GameObject ] def __init__ ( self ) -> None : self . _game_objects = [] def add ( self , game_object : GameObject ) -> None : self . _game_objects . append ( game_object ) def apply ( self , func : Callable [[ GameObject ], None ]) -> None : for game_object in self . _game_objects : func ( game_object ) GameObjectsCollection() \u00b6 GameObjectsCollection (): View Source def __init__ ( self ) -> None : self . _game_objects = [] add() \u00b6 def add ( self , game_object : seagulls . engine . _game_object . GameObject ) -> None : View Source def add ( self , game_object : GameObject ) -> None : self . _game_objects . append ( game_object ) apply() \u00b6 def apply ( self , func : Callable [[ seagulls . engine . _game_object . GameObject ], NoneType ] ) -> None : View Source def apply ( self , func : Callable [[ GameObject ], None ]) -> None : for game_object in self . _game_objects : func ( game_object ) GameSettings \u00b6 class GameSettings : View Source class GameSettings : def get_setting ( self , name , default = None ) -> Any : data = self . _load_yaml () return data . get ( name , default ) @lru_cache () def _load_yaml ( self ) -> Dict [ str , Any ]: file = Path . home () / \".config/seagulls.yaml\" if not file . exists (): file . touch () return yaml . safe_load ( file . read_text ()) or {} GameSettings() \u00b6 GameSettings (): get_setting() \u00b6 def get_setting ( self , name , default = None ) -> Any : View Source def get_setting ( self , name , default = None ) -> Any : data = self . _load_yaml () return data . get ( name , default ) Rect \u00b6 class Rect : Rect(left, top, width, height) -> Rect Rect((left, top), (width, height)) -> Rect Rect(object) -> Rect pygame object for storing rectangular coordinates Rect() \u00b6 Rect ( * args , ** kwargs ): normalize() \u00b6 def normalize ( unknown ): normalize() -> None correct negative sizes clip() \u00b6 def clip ( unknown ): clip(Rect) -> Rect crops a rectangle inside another clipline() \u00b6 def clipline ( unknown ): clipline(x1, y1, x2, y2) -> ((cx1, cy1), (cx2, cy2)) clipline(x1, y1, x2, y2) -> () clipline((x1, y1), (x2, y2)) -> ((cx1, cy1), (cx2, cy2)) clipline((x1, y1), (x2, y2)) -> () clipline((x1, y1, x2, y2)) -> ((cx1, cy1), (cx2, cy2)) clipline((x1, y1, x2, y2)) -> () clipline(((x1, y1), (x2, y2))) -> ((cx1, cy1), (cx2, cy2)) clipline(((x1, y1), (x2, y2))) -> () crops a line inside a rectangle clamp() \u00b6 def clamp ( unknown ): clamp(Rect) -> Rect moves the rectangle inside another clamp_ip() \u00b6 def clamp_ip ( unknown ): clamp_ip(Rect) -> None moves the rectangle inside another, in place copy() \u00b6 def copy ( unknown ): copy() -> Rect copy the rectangle fit() \u00b6 def fit ( unknown ): fit(Rect) -> Rect resize and move a rectangle with aspect ratio move() \u00b6 def move ( unknown ): move(x, y) -> Rect moves the rectangle update() \u00b6 def update ( unknown ): update(left, top, width, height) -> None update((left, top), (width, height)) -> None update(object) -> None sets the position and size of the rectangle inflate() \u00b6 def inflate ( unknown ): inflate(x, y) -> Rect grow or shrink the rectangle size union() \u00b6 def union ( unknown ): union(Rect) -> Rect joins two rectangles into one unionall() \u00b6 def unionall ( unknown ): unionall(Rect_sequence) -> Rect the union of many rectangles move_ip() \u00b6 def move_ip ( unknown ): move_ip(x, y) -> None moves the rectangle, in place inflate_ip() \u00b6 def inflate_ip ( unknown ): inflate_ip(x, y) -> None grow or shrink the rectangle size, in place union_ip() \u00b6 def union_ip ( unknown ): union_ip(Rect) -> None joins two rectangles into one, in place unionall_ip() \u00b6 def unionall_ip ( unknown ): unionall_ip(Rect_sequence) -> None the union of many rectangles, in place collidepoint() \u00b6 def collidepoint ( unknown ): collidepoint(x, y) -> bool collidepoint((x,y)) -> bool test if a point is inside a rectangle colliderect() \u00b6 def colliderect ( unknown ): colliderect(Rect) -> bool test if two rectangles overlap collidelist() \u00b6 def collidelist ( unknown ): collidelist(list) -> index test if one rectangle in a list intersects collidelistall() \u00b6 def collidelistall ( unknown ): collidelistall(list) -> indices test if all rectangles in a list intersect collidedict() \u00b6 def collidedict ( unknown ): collidedict(dict) -> (key, value) collidedict(dict) -> None collidedict(dict, use_values=0) -> (key, value) collidedict(dict, use_values=0) -> None test if one rectangle in a dictionary intersects collidedictall() \u00b6 def collidedictall ( unknown ): collidedictall(dict) -> [(key, value), ...] collidedictall(dict, use_values=0) -> [(key, value), ...] test if all rectangles in a dictionary intersect contains() \u00b6 def contains ( unknown ): contains(Rect) -> bool test if one rectangle is inside another x \u00b6 x y \u00b6 y w \u00b6 w h \u00b6 h width \u00b6 width height \u00b6 height top \u00b6 top left \u00b6 left bottom \u00b6 bottom right \u00b6 right centerx \u00b6 centerx centery \u00b6 centery topleft \u00b6 topleft topright \u00b6 topright bottomleft \u00b6 bottomleft bottomright \u00b6 bottomright midtop \u00b6 midtop midleft \u00b6 midleft midbottom \u00b6 midbottom midright \u00b6 midright size \u00b6 size center \u00b6 center Surface \u00b6 class Surface : Surface((width, height), flags=0, depth=0, masks=None) -> Surface Surface((width, height), flags=0, Surface) -> Surface pygame object for representing images Surface() \u00b6 Surface ( * args , ** kwargs ): get_at() \u00b6 def get_at ( unknown ): get_at((x, y)) -> Color get the color value at a single pixel set_at() \u00b6 def set_at ( unknown ): set_at((x, y), Color) -> None set the color value for a single pixel get_at_mapped() \u00b6 def get_at_mapped ( unknown ): get_at_mapped((x, y)) -> Color get the mapped color value at a single pixel map_rgb() \u00b6 def map_rgb ( unknown ): map_rgb(Color) -> mapped_int convert a color into a mapped color value unmap_rgb() \u00b6 def unmap_rgb ( unknown ): unmap_rgb(mapped_int) -> Color convert a mapped integer color value into a Color get_palette() \u00b6 def get_palette ( unknown ): get_palette() -> [RGB, RGB, RGB, ...] get the color index palette for an 8-bit Surface get_palette_at() \u00b6 def get_palette_at ( unknown ): get_palette_at(index) -> RGB get the color for a single entry in a palette set_palette() \u00b6 def set_palette ( unknown ): set_palette([RGB, RGB, RGB, ...]) -> None set the color palette for an 8-bit Surface set_palette_at() \u00b6 def set_palette_at ( unknown ): set_palette_at(index, RGB) -> None set the color for a single index in an 8-bit Surface palette lock() \u00b6 def lock ( unknown ): lock() -> None lock the Surface memory for pixel access unlock() \u00b6 def unlock ( unknown ): unlock() -> None unlock the Surface memory from pixel access mustlock() \u00b6 def mustlock ( unknown ): mustlock() -> bool test if the Surface requires locking get_locked() \u00b6 def get_locked ( unknown ): get_locked() -> bool test if the Surface is current locked get_locks() \u00b6 def get_locks ( unknown ): get_locks() -> tuple Gets the locks for the Surface set_colorkey() \u00b6 def set_colorkey ( unknown ): set_colorkey(Color, flags=0) -> None set_colorkey(None) -> None Set the transparent colorkey get_colorkey() \u00b6 def get_colorkey ( unknown ): get_colorkey() -> RGB or None Get the current transparent colorkey set_alpha() \u00b6 def set_alpha ( unknown ): set_alpha(value, flags=0) -> None set_alpha(None) -> None set the alpha value for the full Surface image get_alpha() \u00b6 def get_alpha ( unknown ): get_alpha() -> int_value get the current Surface transparency value get_blendmode() \u00b6 def get_blendmode ( unknown ): Return the surface's SDL 2 blend mode copy() \u00b6 def copy ( unknown ): copy() -> Surface create a new copy of a Surface convert() \u00b6 def convert ( unknown ): convert(Surface=None) -> Surface convert(depth, flags=0) -> Surface convert(masks, flags=0) -> Surface change the pixel format of an image convert_alpha() \u00b6 def convert_alpha ( unknown ): convert_alpha(Surface) -> Surface convert_alpha() -> Surface change the pixel format of an image including per pixel alphas set_clip() \u00b6 def set_clip ( unknown ): set_clip(rect) -> None set_clip(None) -> None set the current clipping area of the Surface get_clip() \u00b6 def get_clip ( unknown ): get_clip() -> Rect get the current clipping area of the Surface fill() \u00b6 def fill ( unknown ): fill(color, rect=None, special_flags=0) -> Rect fill Surface with a solid color blit() \u00b6 def blit ( unknown ): blit(source, dest, area=None, special_flags=0) -> Rect draw one image onto another blits() \u00b6 def blits ( unknown ): blits(blit_sequence=((source, dest), ...), doreturn=1) -> [Rect, ...] or None blits(((source, dest, area), ...)) -> [Rect, ...] blits(((source, dest, area, special_flags), ...)) -> [Rect, ...] draw many images onto another scroll() \u00b6 def scroll ( unknown ): scroll(dx=0, dy=0) -> None Shift the surface image in place get_flags() \u00b6 def get_flags ( unknown ): get_flags() -> int get the additional flags used for the Surface get_size() \u00b6 def get_size ( unknown ): get_size() -> (width, height) get the dimensions of the Surface get_width() \u00b6 def get_width ( unknown ): get_width() -> width get the width of the Surface get_height() \u00b6 def get_height ( unknown ): get_height() -> height get the height of the Surface get_rect() \u00b6 def get_rect ( unknown ): get_rect(**kwargs) -> Rect get the rectangular area of the Surface get_pitch() \u00b6 def get_pitch ( unknown ): get_pitch() -> int get the number of bytes used per Surface row get_bitsize() \u00b6 def get_bitsize ( unknown ): get_bitsize() -> int get the bit depth of the Surface pixel format get_bytesize() \u00b6 def get_bytesize ( unknown ): get_bytesize() -> int get the bytes used per Surface pixel get_masks() \u00b6 def get_masks ( unknown ): get_masks() -> (R, G, B, A) the bitmasks needed to convert between a color and a mapped integer get_shifts() \u00b6 def get_shifts ( unknown ): get_shifts() -> (R, G, B, A) the bit shifts needed to convert between a color and a mapped integer set_masks() \u00b6 def set_masks ( unknown ): set_masks((r,g,b,a)) -> None set the bitmasks needed to convert between a color and a mapped integer set_shifts() \u00b6 def set_shifts ( unknown ): set_shifts((r,g,b,a)) -> None sets the bit shifts needed to convert between a color and a mapped integer get_losses() \u00b6 def get_losses ( unknown ): get_losses() -> (R, G, B, A) the significant bits used to convert between a color and a mapped integer subsurface() \u00b6 def subsurface ( unknown ): subsurface(Rect) -> Surface create a new surface that references its parent get_offset() \u00b6 def get_offset ( unknown ): get_offset() -> (x, y) find the position of a child subsurface inside a parent get_abs_offset() \u00b6 def get_abs_offset ( unknown ): get_abs_offset() -> (x, y) find the absolute position of a child subsurface inside its top level parent get_parent() \u00b6 def get_parent ( unknown ): get_parent() -> Surface find the parent of a subsurface get_abs_parent() \u00b6 def get_abs_parent ( unknown ): get_abs_parent() -> Surface find the top level parent of a subsurface get_bounding_rect() \u00b6 def get_bounding_rect ( unknown ): get_bounding_rect(min_alpha = 1) -> Rect find the smallest rect containing data get_view() \u00b6 def get_view ( unknown ): get_view(<kind>='2') -> BufferProxy return a buffer view of the Surface's pixels. get_buffer() \u00b6 def get_buffer ( unknown ): get_buffer() -> BufferProxy acquires a buffer object for the pixels of the Surface. Color \u00b6 class Color : Color(r, g, b) -> Color Color(r, g, b, a=255) -> Color Color(color_value) -> Color pygame object for color representations Color() \u00b6 Color ( * args , ** kwargs ): normalize() \u00b6 def normalize ( unknown ): normalize() -> tuple Returns the normalized RGBA values of the Color. correct_gamma() \u00b6 def correct_gamma ( unknown ): correct_gamma (gamma) -> Color Applies a certain gamma value to the Color. set_length() \u00b6 def set_length ( unknown ): set_length(len) -> None Set the number of elements in the Color to 1,2,3, or 4. lerp() \u00b6 def lerp ( unknown ): lerp(Color, float) -> Color returns a linear interpolation to the given Color. premul_alpha() \u00b6 def premul_alpha ( unknown ): premul_alpha() -> Color returns a Color where the r,g,b components have been multiplied by the alpha. update() \u00b6 def update ( unknown ): update(r, g, b) -> None update(r, g, b, a=255) -> None update(color_value) -> None Sets the elements of the color r \u00b6 r r -> int Gets or sets the red value of the Color. g \u00b6 g g -> int Gets or sets the green value of the Color. b \u00b6 b b -> int Gets or sets the blue value of the Color. a \u00b6 a a -> int Gets or sets the alpha value of the Color. hsva \u00b6 hsva hsva -> tuple Gets or sets the HSVA representation of the Color. hsla \u00b6 hsla hsla -> tuple Gets or sets the HSLA representation of the Color. i1i2i3 \u00b6 i1i2i3 i1i2i3 -> tuple Gets or sets the I1I2I3 representation of the Color. cmy \u00b6 cmy cmy -> tuple Gets or sets the CMY representation of the Color. PixelArray \u00b6 class PixelArray : PixelArray(Surface) -> PixelArray pygame object for direct pixel access of surfaces PixelArray() \u00b6 PixelArray (): compare() \u00b6 def compare ( unknown ): compare(array, distance=0, weights=(0.299, 0.587, 0.114)) -> PixelArray Compares the PixelArray with another one. extract() \u00b6 def extract ( unknown ): extract(color, distance=0, weights=(0.299, 0.587, 0.114)) -> PixelArray Extracts the passed color from the PixelArray. make_surface() \u00b6 def make_surface ( unknown ): make_surface() -> Surface Creates a new Surface from the current PixelArray. close() \u00b6 def close ( unknown ): transpose() -> PixelArray Closes the PixelArray, and releases Surface lock. replace() \u00b6 def replace ( unknown ): replace(color, repcolor, distance=0, weights=(0.299, 0.587, 0.114)) -> None Replaces the passed color in the PixelArray with another one. transpose() \u00b6 def transpose ( unknown ): transpose() -> PixelArray Exchanges the x and y axis. surface \u00b6 surface surface -> Surface Gets the Surface the PixelArray uses. itemsize \u00b6 itemsize itemsize -> int Returns the byte size of a pixel array item shape \u00b6 shape shape -> tuple of int's Returns the array size. strides \u00b6 strides strides -> tuple of int's Returns byte offsets for each array dimension. ndim \u00b6 ndim ndim -> int Returns the number of dimensions. Vector2 \u00b6 class Vector2 : Vector2() -> Vector2 Vector2(int) -> Vector2 Vector2(float) -> Vector2 Vector2(Vector2) -> Vector2 Vector2(x, y) -> Vector2 Vector2((x, y)) -> Vector2 a 2-Dimensional Vector Vector2() \u00b6 Vector2 ( * args , ** kwargs ): length() \u00b6 def length ( unknown ): length() -> float returns the Euclidean length of the vector. length_squared() \u00b6 def length_squared ( unknown ): length_squared() -> float returns the squared Euclidean length of the vector. magnitude() \u00b6 def magnitude ( unknown ): magnitude() -> float returns the Euclidean magnitude of the vector. magnitude_squared() \u00b6 def magnitude_squared ( unknown ): magnitude_squared() -> float returns the squared magnitude of the vector. rotate() \u00b6 def rotate ( unknown ): rotate(angle) -> Vector2 rotates a vector by a given angle in degrees. rotate_ip() \u00b6 def rotate_ip ( unknown ): rotate_ip(angle) -> None rotates the vector by a given angle in degrees in place. rotate_rad() \u00b6 def rotate_rad ( unknown ): rotate_rad(angle) -> Vector2 rotates a vector by a given angle in radians. rotate_rad_ip() \u00b6 def rotate_rad_ip ( unknown ): rotate_rad_ip(angle) -> None rotates the vector by a given angle in radians in place. rotate_ip_rad() \u00b6 def rotate_ip_rad ( unknown ): rotate_ip_rad(angle) -> None rotates the vector by a given angle in radians in place. slerp() \u00b6 def slerp ( unknown ): slerp(Vector2, float) -> Vector2 returns a spherical interpolation to the given vector. lerp() \u00b6 def lerp ( unknown ): lerp(Vector2, float) -> Vector2 returns a linear interpolation to the given vector. normalize() \u00b6 def normalize ( unknown ): normalize() -> Vector2 returns a vector with the same direction but length 1. normalize_ip() \u00b6 def normalize_ip ( unknown ): normalize_ip() -> None normalizes the vector in place so that its length is 1. is_normalized() \u00b6 def is_normalized ( unknown ): is_normalized() -> Bool tests if the vector is normalized i.e. has length == 1. cross() \u00b6 def cross ( unknown ): cross(Vector2) -> Vector2 calculates the cross- or vector-product dot() \u00b6 def dot ( unknown ): dot(Vector2) -> float calculates the dot- or scalar-product with the other vector angle_to() \u00b6 def angle_to ( unknown ): angle_to(Vector2) -> float calculates the angle to a given vector in degrees. update() \u00b6 def update ( unknown ): update() -> None update(int) -> None update(float) -> None update(Vector2) -> None update(x, y) -> None update((x, y)) -> None Sets the coordinates of the vector. scale_to_length() \u00b6 def scale_to_length ( unknown ): scale_to_length(float) -> None scales the vector to a given length. reflect() \u00b6 def reflect ( unknown ): reflect(Vector2) -> Vector2 returns a vector reflected of a given normal. reflect_ip() \u00b6 def reflect_ip ( unknown ): reflect_ip(Vector2) -> None reflect the vector of a given normal in place. distance_to() \u00b6 def distance_to ( unknown ): distance_to(Vector2) -> float calculates the Euclidean distance to a given vector. distance_squared_to() \u00b6 def distance_squared_to ( unknown ): distance_squared_to(Vector2) -> float calculates the squared Euclidean distance to a given vector. elementwise() \u00b6 def elementwise ( unknown ): elementwise() -> VectorElementwiseProxy The next operation will be performed elementwise. as_polar() \u00b6 def as_polar ( unknown ): as_polar() -> (r, phi) returns a tuple with radial distance and azimuthal angle. from_polar() \u00b6 def from_polar ( unknown ): from_polar((r, phi)) -> None Sets x and y from a polar coordinates tuple. project() \u00b6 def project ( unknown ): project(Vector2) -> Vector2 projects a vector onto another. copy() \u00b6 def copy ( unknown ): copy() -> Vector2 Returns a copy of itself. epsilon \u00b6 epsilon small value used in comparisons x \u00b6 x y \u00b6 y Vector3 \u00b6 class Vector3 : Vector3() -> Vector3 Vector3(int) -> Vector3 Vector3(float) -> Vector3 Vector3(Vector3) -> Vector3 Vector3(x, y, z) -> Vector3 Vector3((x, y, z)) -> Vector3 a 3-Dimensional Vector Vector3() \u00b6 Vector3 ( * args , ** kwargs ): length() \u00b6 def length ( unknown ): length() -> float returns the Euclidean length of the vector. length_squared() \u00b6 def length_squared ( unknown ): length_squared() -> float returns the squared Euclidean length of the vector. magnitude() \u00b6 def magnitude ( unknown ): magnitude() -> float returns the Euclidean magnitude of the vector. magnitude_squared() \u00b6 def magnitude_squared ( unknown ): magnitude_squared() -> float returns the squared Euclidean magnitude of the vector. rotate() \u00b6 def rotate ( unknown ): rotate(angle, Vector3) -> Vector3 rotates a vector by a given angle in degrees. rotate_ip() \u00b6 def rotate_ip ( unknown ): rotate_ip(angle, Vector3) -> None rotates the vector by a given angle in degrees in place. rotate_rad() \u00b6 def rotate_rad ( unknown ): rotate_rad(angle, Vector3) -> Vector3 rotates a vector by a given angle in radians. rotate_rad_ip() \u00b6 def rotate_rad_ip ( unknown ): rotate_rad_ip(angle, Vector3) -> None rotates the vector by a given angle in radians in place. rotate_ip_rad() \u00b6 def rotate_ip_rad ( unknown ): rotate_ip_rad(angle, Vector3) -> None rotates the vector by a given angle in radians in place. rotate_x() \u00b6 def rotate_x ( unknown ): rotate_x(angle) -> Vector3 rotates a vector around the x-axis by the angle in degrees. rotate_x_ip() \u00b6 def rotate_x_ip ( unknown ): rotate_x_ip(angle) -> None rotates the vector around the x-axis by the angle in degrees in place. rotate_x_rad() \u00b6 def rotate_x_rad ( unknown ): rotate_x_rad(angle) -> Vector3 rotates a vector around the x-axis by the angle in radians. rotate_x_rad_ip() \u00b6 def rotate_x_rad_ip ( unknown ): rotate_x_rad_ip(angle) -> None rotates the vector around the x-axis by the angle in radians in place. rotate_x_ip_rad() \u00b6 def rotate_x_ip_rad ( unknown ): rotate_x_ip_rad(angle) -> None rotates the vector around the x-axis by the angle in radians in place. rotate_y() \u00b6 def rotate_y ( unknown ): rotate_y(angle) -> Vector3 rotates a vector around the y-axis by the angle in degrees. rotate_y_ip() \u00b6 def rotate_y_ip ( unknown ): rotate_y_ip(angle) -> None rotates the vector around the y-axis by the angle in degrees in place. rotate_y_rad() \u00b6 def rotate_y_rad ( unknown ): rotate_y_rad(angle) -> Vector3 rotates a vector around the y-axis by the angle in radians. rotate_y_rad_ip() \u00b6 def rotate_y_rad_ip ( unknown ): rotate_y_rad_ip(angle) -> None rotates the vector around the y-axis by the angle in radians in place. rotate_y_ip_rad() \u00b6 def rotate_y_ip_rad ( unknown ): rotate_y_ip_rad(angle) -> None rotates the vector around the y-axis by the angle in radians in place. rotate_z() \u00b6 def rotate_z ( unknown ): rotate_z(angle) -> Vector3 rotates a vector around the z-axis by the angle in degrees. rotate_z_ip() \u00b6 def rotate_z_ip ( unknown ): rotate_z_ip(angle) -> None rotates the vector around the z-axis by the angle in degrees in place. rotate_z_rad() \u00b6 def rotate_z_rad ( unknown ): rotate_z_rad(angle) -> Vector3 rotates a vector around the z-axis by the angle in radians. rotate_z_rad_ip() \u00b6 def rotate_z_rad_ip ( unknown ): rotate_z_rad_ip(angle) -> None rotates the vector around the z-axis by the angle in radians in place. rotate_z_ip_rad() \u00b6 def rotate_z_ip_rad ( unknown ): rotate_z_ip_rad(angle) -> None rotates the vector around the z-axis by the angle in radians in place. slerp() \u00b6 def slerp ( unknown ): slerp(Vector3, float) -> Vector3 returns a spherical interpolation to the given vector. lerp() \u00b6 def lerp ( unknown ): lerp(Vector3, float) -> Vector3 returns a linear interpolation to the given vector. normalize() \u00b6 def normalize ( unknown ): normalize() -> Vector3 returns a vector with the same direction but length 1. normalize_ip() \u00b6 def normalize_ip ( unknown ): normalize_ip() -> None normalizes the vector in place so that its length is 1. is_normalized() \u00b6 def is_normalized ( unknown ): is_normalized() -> Bool tests if the vector is normalized i.e. has length == 1. cross() \u00b6 def cross ( unknown ): cross(Vector3) -> Vector3 calculates the cross- or vector-product dot() \u00b6 def dot ( unknown ): dot(Vector3) -> float calculates the dot- or scalar-product with the other vector angle_to() \u00b6 def angle_to ( unknown ): angle_to(Vector3) -> float calculates the angle to a given vector in degrees. update() \u00b6 def update ( unknown ): update() -> None update(int) -> None update(float) -> None update(Vector3) -> None update(x, y, z) -> None update((x, y, z)) -> None Sets the coordinates of the vector. scale_to_length() \u00b6 def scale_to_length ( unknown ): scale_to_length(float) -> None scales the vector to a given length. reflect() \u00b6 def reflect ( unknown ): reflect(Vector3) -> Vector3 returns a vector reflected of a given normal. reflect_ip() \u00b6 def reflect_ip ( unknown ): reflect_ip(Vector3) -> None reflect the vector of a given normal in place. distance_to() \u00b6 def distance_to ( unknown ): distance_to(Vector3) -> float calculates the Euclidean distance to a given vector. distance_squared_to() \u00b6 def distance_squared_to ( unknown ): distance_squared_to(Vector3) -> float calculates the squared Euclidean distance to a given vector. elementwise() \u00b6 def elementwise ( unknown ): elementwise() -> VectorElementwiseProxy The next operation will be performed elementwise. as_spherical() \u00b6 def as_spherical ( unknown ): as_spherical() -> (r, theta, phi) returns a tuple with radial distance, inclination and azimuthal angle. from_spherical() \u00b6 def from_spherical ( unknown ): from_spherical((r, theta, phi)) -> None Sets x, y and z from a spherical coordinates 3-tuple. project() \u00b6 def project ( unknown ): project(Vector3) -> Vector3 projects a vector onto another. copy() \u00b6 def copy ( unknown ): copy() -> Vector3 Returns a copy of itself. epsilon \u00b6 epsilon small value used in comparisons x \u00b6 x y \u00b6 y z \u00b6 z","title":"seagulls.engine"},{"location":"api/seagulls-engine/seagulls/engine/#seagullsengine","text":"Core Engine Components View Source \"\"\"Core Engine Components\"\"\" from ._collisions import CollidableObject , flag_from_string from ._game_clock import GameClock from ._game_controls import GameControls from ._game_object import GameObject , GameObjectsCollection from ._game_scene import IGameScene from ._game_scene_manager import IProvideGameScenes from ._game_session import IGameSession from ._game_session_manager import IProvideGameSessions from ._game_settings import GameSettings from ._pygame import Color , PixelArray , Rect , Surface , Vector2 , Vector3 from ._surface_renderer import SurfaceRenderer __all__ = [ \"flag_from_string\" , \"CollidableObject\" , \"IGameScene\" , \"IProvideGameScenes\" , \"IProvideGameSessions\" , \"IGameSession\" , \"SurfaceRenderer\" , \"GameClock\" , \"GameControls\" , \"GameObject\" , \"GameObjectsCollection\" , \"GameSettings\" , \"Rect\" , \"Surface\" , \"Color\" , \"PixelArray\" , \"Vector2\" , \"Vector3\" , ]","title":"seagulls.engine"},{"location":"api/seagulls-engine/seagulls/engine/#flag_from_string","text":"def flag_from_string ( value : str ) -> int : View Source def flag_from_string ( value : str ) -> int : if not isinstance ( value , str ): raise ValueError ( f \"Value must be a string of 0s and 1s: { value } \" ) return int ( value , 2 )","title":"flag_from_string()"},{"location":"api/seagulls-engine/seagulls/engine/#collidableobject","text":"@dataclass ( frozen = True ) class CollidableObject : CollidableObject(layer: int, mask: int) View Source @dataclass ( frozen = True ) class CollidableObject : layer : int mask : int def filter_by_mask ( self , targets : Tuple [ \"CollidableObject\" , ... ]) -> Tuple [ \"CollidableObject\" , ... ]: result = [] for t in targets : if self . is_in_mask ( t ): result . append ( t ) return tuple ( result ) def is_in_mask ( self , target : \"CollidableObject\" ) -> bool : logger . debug ( f \"targeting items located in mask: { self . mask : b } \" ) logger . debug ( f \"target is located in layer: { target . layer : b } \" ) logger . debug ( f \"& result: { self . mask & target . layer : b } \" ) return self . mask & target . layer > 0 def __repr__ ( self ) -> str : return f \" { self . __class__ . __name__ } (layer= { self . layer : b } , mask= { self . mask : b } )\"","title":"CollidableObject"},{"location":"api/seagulls-engine/seagulls/engine/#collidableobject_1","text":"CollidableObject ( layer : int , mask : int ):","title":"CollidableObject()"},{"location":"api/seagulls-engine/seagulls/engine/#filter_by_mask","text":"def filter_by_mask ( self , targets : Tuple [ seagulls . engine . _collisions . CollidableObject , ... ] ) -> Tuple [ seagulls . engine . _collisions . CollidableObject , ... ]: View Source def filter_by_mask ( self , targets : Tuple [ \"CollidableObject\" , ... ]) -> Tuple [ \"CollidableObject\" , ... ]: result = [] for t in targets : if self . is_in_mask ( t ): result . append ( t ) return tuple ( result )","title":"filter_by_mask()"},{"location":"api/seagulls-engine/seagulls/engine/#is_in_mask","text":"def is_in_mask ( self , target : seagulls . engine . _collisions . CollidableObject ) -> bool : View Source def is_in_mask ( self , target : \"CollidableObject\" ) -> bool : logger . debug ( f \"targeting items located in mask: { self . mask : b } \" ) logger . debug ( f \"target is located in layer: { target . layer : b } \" ) logger . debug ( f \"& result: { self . mask & target . layer : b } \" ) return self . mask & target . layer > 0","title":"is_in_mask()"},{"location":"api/seagulls-engine/seagulls/engine/#igamescene","text":"class IGameScene ( abc . ABC ): This class is for X and Y. View Source class IGameScene ( ABC ): \"\"\" This class is for X and Y. \"\"\" @abstractmethod def start ( self ) -> None : pass @abstractmethod def should_quit ( self ) -> bool : pass @abstractmethod def tick ( self ) -> None : pass","title":"IGameScene"},{"location":"api/seagulls-engine/seagulls/engine/#start","text":"@abstractmethod def start ( self ) -> None : View Source @abstractmethod def start ( self ) -> None : pass","title":"start()"},{"location":"api/seagulls-engine/seagulls/engine/#should_quit","text":"@abstractmethod def should_quit ( self ) -> bool : View Source @abstractmethod def should_quit ( self ) -> bool : pass","title":"should_quit()"},{"location":"api/seagulls-engine/seagulls/engine/#tick","text":"@abstractmethod def tick ( self ) -> None : View Source @abstractmethod def tick ( self ) -> None : pass","title":"tick()"},{"location":"api/seagulls-engine/seagulls/engine/#iprovidegamescenes","text":"class IProvideGameScenes ( abc . ABC ): Helper class that provides a standard way to create an ABC using inheritance. View Source class IProvideGameScenes ( ABC ): @abstractmethod def get_scene ( self ) -> IGameScene : pass","title":"IProvideGameScenes"},{"location":"api/seagulls-engine/seagulls/engine/#get_scene","text":"@abstractmethod def get_scene ( self ) -> seagulls . engine . _game_scene . IGameScene : View Source @abstractmethod def get_scene ( self ) -> IGameScene : pass","title":"get_scene()"},{"location":"api/seagulls-engine/seagulls/engine/#iprovidegamesessions","text":"class IProvideGameSessions ( abc . ABC ): Helper class that provides a standard way to create an ABC using inheritance. View Source class IProvideGameSessions ( ABC ): @abstractmethod def get_session ( self , scene : str ) -> IGameSession : pass","title":"IProvideGameSessions"},{"location":"api/seagulls-engine/seagulls/engine/#get_session","text":"@abstractmethod def get_session ( self , scene : str ) -> seagulls . engine . _game_session . IGameSession : View Source @abstractmethod def get_session ( self , scene : str ) -> IGameSession : pass","title":"get_session()"},{"location":"api/seagulls-engine/seagulls/engine/#igamesession","text":"class IGameSession ( abc . ABC ): Helper class that provides a standard way to create an ABC using inheritance. View Source class IGameSession ( ABC ): @abstractmethod def start ( self ) -> None : pass @abstractmethod def wait_for_completion ( self ) -> None : pass @abstractmethod def stop ( self ) -> None : pass","title":"IGameSession"},{"location":"api/seagulls-engine/seagulls/engine/#start_1","text":"@abstractmethod def start ( self ) -> None : View Source @abstractmethod def start ( self ) -> None : pass","title":"start()"},{"location":"api/seagulls-engine/seagulls/engine/#wait_for_completion","text":"@abstractmethod def wait_for_completion ( self ) -> None : View Source @abstractmethod def wait_for_completion ( self ) -> None : pass","title":"wait_for_completion()"},{"location":"api/seagulls-engine/seagulls/engine/#stop","text":"@abstractmethod def stop ( self ) -> None : View Source @abstractmethod def stop ( self ) -> None : pass","title":"stop()"},{"location":"api/seagulls-engine/seagulls/engine/#surfacerenderer","text":"class SurfaceRenderer : View Source class SurfaceRenderer : def start ( self ) -> None : self . _get_surface () def render ( self , surface : Surface ) -> None : self . _get_surface () . blit ( surface , ( 0 , 0 )) pygame . display . flip () @lru_cache () def _get_surface ( self ) -> Surface : return pygame . display . set_mode (( 1024 , 600 ))","title":"SurfaceRenderer"},{"location":"api/seagulls-engine/seagulls/engine/#surfacerenderer_1","text":"SurfaceRenderer ():","title":"SurfaceRenderer()"},{"location":"api/seagulls-engine/seagulls/engine/#start_2","text":"def start ( self ) -> None : View Source def start ( self ) -> None : self . _get_surface ()","title":"start()"},{"location":"api/seagulls-engine/seagulls/engine/#render","text":"def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : Surface ) -> None : self . _get_surface () . blit ( surface , ( 0 , 0 )) pygame . display . flip ()","title":"render()"},{"location":"api/seagulls-engine/seagulls/engine/#gameclock","text":"class GameClock ( seagulls . engine . _game_object . GameObject ): Interface for anything representing an object in the scene. View Source class GameClock ( GameObject ): _clock : Clock _ticks : int _delta : int def __init__ ( self ): self . _clock = Clock () self . _ticks = 0 self . _delta = 0 def tick ( self ) -> None : self . _delta = self . _clock . tick () def render ( self , surface : Surface ) -> None : pass def get_time ( self ) -> int : return self . _delta def get_fps ( self ) -> float : return self . _clock . get_fps ()","title":"GameClock"},{"location":"api/seagulls-engine/seagulls/engine/#gameclock_1","text":"GameClock (): View Source def __init__ ( self ): self . _clock = Clock () self . _ticks = 0 self . _delta = 0","title":"GameClock()"},{"location":"api/seagulls-engine/seagulls/engine/#tick_1","text":"def tick ( self ) -> None : View Source def tick ( self ) -> None : self . _delta = self . _clock . tick ()","title":"tick()"},{"location":"api/seagulls-engine/seagulls/engine/#render_1","text":"def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : Surface ) -> None : pass","title":"render()"},{"location":"api/seagulls-engine/seagulls/engine/#get_time","text":"def get_time ( self ) -> int : View Source def get_time ( self ) -> int : return self . _delta","title":"get_time()"},{"location":"api/seagulls-engine/seagulls/engine/#get_fps","text":"def get_fps ( self ) -> float : View Source def get_fps ( self ) -> float : return self . _clock . get_fps ()","title":"get_fps()"},{"location":"api/seagulls-engine/seagulls/engine/#gamecontrols","text":"class GameControls ( seagulls . engine . _game_object . GameObject ): Interface for anything representing an object in the scene. View Source class GameControls ( GameObject ): _events : List [ Event ] def __init__ ( self ): self . _events = [] def tick ( self ): self . _events = pygame . event . get () def should_quit ( self ) -> bool : for event in self . _events : if event . type == pygame . QUIT : return True if self . _is_key_down_event ( event , pygame . K_ESCAPE ): return True return False def should_fire ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_SPACE ): return True return False def is_left_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_LEFT ] def is_right_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_RIGHT ] def is_up_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_UP ] def is_down_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_DOWN ] def should_toggle_debug_hud ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_BACKQUOTE ): return True return False def is_click_initialized ( self ) -> bool : for event in self . _events : if not event . type == pygame . MOUSEBUTTONDOWN : continue return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] return False def is_mouse_down ( self ) -> bool : return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] def _is_key_down_event ( self , event : Event , key : int ) -> bool : return event . type == pygame . KEYDOWN and event . key == key def _is_key_up_event ( self , event : Event , key : int ) -> bool : return event . type == pygame . KEYUP and event . key == key def render ( self , surface : Surface ) -> None : pass","title":"GameControls"},{"location":"api/seagulls-engine/seagulls/engine/#gamecontrols_1","text":"GameControls (): View Source def __init__ ( self ): self . _events = []","title":"GameControls()"},{"location":"api/seagulls-engine/seagulls/engine/#tick_2","text":"def tick ( self ): View Source def tick ( self ): self . _events = pygame . event . get ()","title":"tick()"},{"location":"api/seagulls-engine/seagulls/engine/#should_quit_1","text":"def should_quit ( self ) -> bool : View Source def should_quit ( self ) -> bool : for event in self . _events : if event . type == pygame . QUIT : return True if self . _is_key_down_event ( event , pygame . K_ESCAPE ): return True return False","title":"should_quit()"},{"location":"api/seagulls-engine/seagulls/engine/#should_fire","text":"def should_fire ( self ) -> bool : View Source def should_fire ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_SPACE ): return True return False","title":"should_fire()"},{"location":"api/seagulls-engine/seagulls/engine/#is_left_moving","text":"def is_left_moving ( self ) -> bool : View Source def is_left_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_LEFT ]","title":"is_left_moving()"},{"location":"api/seagulls-engine/seagulls/engine/#is_right_moving","text":"def is_right_moving ( self ) -> bool : View Source def is_right_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_RIGHT ]","title":"is_right_moving()"},{"location":"api/seagulls-engine/seagulls/engine/#is_up_moving","text":"def is_up_moving ( self ) -> bool : View Source def is_up_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_UP ]","title":"is_up_moving()"},{"location":"api/seagulls-engine/seagulls/engine/#is_down_moving","text":"def is_down_moving ( self ) -> bool : View Source def is_down_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_DOWN ]","title":"is_down_moving()"},{"location":"api/seagulls-engine/seagulls/engine/#should_toggle_debug_hud","text":"def should_toggle_debug_hud ( self ) -> bool : View Source def should_toggle_debug_hud ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_BACKQUOTE ): return True return False","title":"should_toggle_debug_hud()"},{"location":"api/seagulls-engine/seagulls/engine/#is_click_initialized","text":"def is_click_initialized ( self ) -> bool : View Source def is_click_initialized ( self ) -> bool : for event in self . _events : if not event . type == pygame . MOUSEBUTTONDOWN : continue return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] return False","title":"is_click_initialized()"},{"location":"api/seagulls-engine/seagulls/engine/#is_mouse_down","text":"def is_mouse_down ( self ) -> bool : View Source def is_mouse_down ( self ) -> bool : return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ]","title":"is_mouse_down()"},{"location":"api/seagulls-engine/seagulls/engine/#render_2","text":"def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : Surface ) -> None : pass","title":"render()"},{"location":"api/seagulls-engine/seagulls/engine/#gameobject","text":"class GameObject ( abc . ABC ): Interface for anything representing an object in the scene. View Source class GameObject ( ABC ): \"\"\" Interface for anything representing an object in the scene. \"\"\" @abstractmethod def tick ( self ) -> None : pass @abstractmethod def render ( self , surface : Surface ) -> None : pass","title":"GameObject"},{"location":"api/seagulls-engine/seagulls/engine/#tick_3","text":"@abstractmethod def tick ( self ) -> None : View Source @abstractmethod def tick ( self ) -> None : pass","title":"tick()"},{"location":"api/seagulls-engine/seagulls/engine/#render_3","text":"@abstractmethod def render ( self , surface : pygame . Surface ) -> None : View Source @abstractmethod def render ( self , surface : Surface ) -> None : pass","title":"render()"},{"location":"api/seagulls-engine/seagulls/engine/#gameobjectscollection","text":"class GameObjectsCollection : Data structure that allows you to keep track of objects in the scene. View Source class GameObjectsCollection : \"\"\" Data structure that allows you to keep track of objects in the scene. \"\"\" _game_objects : List [ GameObject ] def __init__ ( self ) -> None : self . _game_objects = [] def add ( self , game_object : GameObject ) -> None : self . _game_objects . append ( game_object ) def apply ( self , func : Callable [[ GameObject ], None ]) -> None : for game_object in self . _game_objects : func ( game_object )","title":"GameObjectsCollection"},{"location":"api/seagulls-engine/seagulls/engine/#gameobjectscollection_1","text":"GameObjectsCollection (): View Source def __init__ ( self ) -> None : self . _game_objects = []","title":"GameObjectsCollection()"},{"location":"api/seagulls-engine/seagulls/engine/#add","text":"def add ( self , game_object : seagulls . engine . _game_object . GameObject ) -> None : View Source def add ( self , game_object : GameObject ) -> None : self . _game_objects . append ( game_object )","title":"add()"},{"location":"api/seagulls-engine/seagulls/engine/#apply","text":"def apply ( self , func : Callable [[ seagulls . engine . _game_object . GameObject ], NoneType ] ) -> None : View Source def apply ( self , func : Callable [[ GameObject ], None ]) -> None : for game_object in self . _game_objects : func ( game_object )","title":"apply()"},{"location":"api/seagulls-engine/seagulls/engine/#gamesettings","text":"class GameSettings : View Source class GameSettings : def get_setting ( self , name , default = None ) -> Any : data = self . _load_yaml () return data . get ( name , default ) @lru_cache () def _load_yaml ( self ) -> Dict [ str , Any ]: file = Path . home () / \".config/seagulls.yaml\" if not file . exists (): file . touch () return yaml . safe_load ( file . read_text ()) or {}","title":"GameSettings"},{"location":"api/seagulls-engine/seagulls/engine/#gamesettings_1","text":"GameSettings ():","title":"GameSettings()"},{"location":"api/seagulls-engine/seagulls/engine/#get_setting","text":"def get_setting ( self , name , default = None ) -> Any : View Source def get_setting ( self , name , default = None ) -> Any : data = self . _load_yaml () return data . get ( name , default )","title":"get_setting()"},{"location":"api/seagulls-engine/seagulls/engine/#rect","text":"class Rect : Rect(left, top, width, height) -> Rect Rect((left, top), (width, height)) -> Rect Rect(object) -> Rect pygame object for storing rectangular coordinates","title":"Rect"},{"location":"api/seagulls-engine/seagulls/engine/#rect_1","text":"Rect ( * args , ** kwargs ):","title":"Rect()"},{"location":"api/seagulls-engine/seagulls/engine/#normalize","text":"def normalize ( unknown ): normalize() -> None correct negative sizes","title":"normalize()"},{"location":"api/seagulls-engine/seagulls/engine/#clip","text":"def clip ( unknown ): clip(Rect) -> Rect crops a rectangle inside another","title":"clip()"},{"location":"api/seagulls-engine/seagulls/engine/#clipline","text":"def clipline ( unknown ): clipline(x1, y1, x2, y2) -> ((cx1, cy1), (cx2, cy2)) clipline(x1, y1, x2, y2) -> () clipline((x1, y1), (x2, y2)) -> ((cx1, cy1), (cx2, cy2)) clipline((x1, y1), (x2, y2)) -> () clipline((x1, y1, x2, y2)) -> ((cx1, cy1), (cx2, cy2)) clipline((x1, y1, x2, y2)) -> () clipline(((x1, y1), (x2, y2))) -> ((cx1, cy1), (cx2, cy2)) clipline(((x1, y1), (x2, y2))) -> () crops a line inside a rectangle","title":"clipline()"},{"location":"api/seagulls-engine/seagulls/engine/#clamp","text":"def clamp ( unknown ): clamp(Rect) -> Rect moves the rectangle inside another","title":"clamp()"},{"location":"api/seagulls-engine/seagulls/engine/#clamp_ip","text":"def clamp_ip ( unknown ): clamp_ip(Rect) -> None moves the rectangle inside another, in place","title":"clamp_ip()"},{"location":"api/seagulls-engine/seagulls/engine/#copy","text":"def copy ( unknown ): copy() -> Rect copy the rectangle","title":"copy()"},{"location":"api/seagulls-engine/seagulls/engine/#fit","text":"def fit ( unknown ): fit(Rect) -> Rect resize and move a rectangle with aspect ratio","title":"fit()"},{"location":"api/seagulls-engine/seagulls/engine/#move","text":"def move ( unknown ): move(x, y) -> Rect moves the rectangle","title":"move()"},{"location":"api/seagulls-engine/seagulls/engine/#update","text":"def update ( unknown ): update(left, top, width, height) -> None update((left, top), (width, height)) -> None update(object) -> None sets the position and size of the rectangle","title":"update()"},{"location":"api/seagulls-engine/seagulls/engine/#inflate","text":"def inflate ( unknown ): inflate(x, y) -> Rect grow or shrink the rectangle size","title":"inflate()"},{"location":"api/seagulls-engine/seagulls/engine/#union","text":"def union ( unknown ): union(Rect) -> Rect joins two rectangles into one","title":"union()"},{"location":"api/seagulls-engine/seagulls/engine/#unionall","text":"def unionall ( unknown ): unionall(Rect_sequence) -> Rect the union of many rectangles","title":"unionall()"},{"location":"api/seagulls-engine/seagulls/engine/#move_ip","text":"def move_ip ( unknown ): move_ip(x, y) -> None moves the rectangle, in place","title":"move_ip()"},{"location":"api/seagulls-engine/seagulls/engine/#inflate_ip","text":"def inflate_ip ( unknown ): inflate_ip(x, y) -> None grow or shrink the rectangle size, in place","title":"inflate_ip()"},{"location":"api/seagulls-engine/seagulls/engine/#union_ip","text":"def union_ip ( unknown ): union_ip(Rect) -> None joins two rectangles into one, in place","title":"union_ip()"},{"location":"api/seagulls-engine/seagulls/engine/#unionall_ip","text":"def unionall_ip ( unknown ): unionall_ip(Rect_sequence) -> None the union of many rectangles, in place","title":"unionall_ip()"},{"location":"api/seagulls-engine/seagulls/engine/#collidepoint","text":"def collidepoint ( unknown ): collidepoint(x, y) -> bool collidepoint((x,y)) -> bool test if a point is inside a rectangle","title":"collidepoint()"},{"location":"api/seagulls-engine/seagulls/engine/#colliderect","text":"def colliderect ( unknown ): colliderect(Rect) -> bool test if two rectangles overlap","title":"colliderect()"},{"location":"api/seagulls-engine/seagulls/engine/#collidelist","text":"def collidelist ( unknown ): collidelist(list) -> index test if one rectangle in a list intersects","title":"collidelist()"},{"location":"api/seagulls-engine/seagulls/engine/#collidelistall","text":"def collidelistall ( unknown ): collidelistall(list) -> indices test if all rectangles in a list intersect","title":"collidelistall()"},{"location":"api/seagulls-engine/seagulls/engine/#collidedict","text":"def collidedict ( unknown ): collidedict(dict) -> (key, value) collidedict(dict) -> None collidedict(dict, use_values=0) -> (key, value) collidedict(dict, use_values=0) -> None test if one rectangle in a dictionary intersects","title":"collidedict()"},{"location":"api/seagulls-engine/seagulls/engine/#collidedictall","text":"def collidedictall ( unknown ): collidedictall(dict) -> [(key, value), ...] collidedictall(dict, use_values=0) -> [(key, value), ...] test if all rectangles in a dictionary intersect","title":"collidedictall()"},{"location":"api/seagulls-engine/seagulls/engine/#contains","text":"def contains ( unknown ): contains(Rect) -> bool test if one rectangle is inside another","title":"contains()"},{"location":"api/seagulls-engine/seagulls/engine/#x","text":"x","title":"x"},{"location":"api/seagulls-engine/seagulls/engine/#y","text":"y","title":"y"},{"location":"api/seagulls-engine/seagulls/engine/#w","text":"w","title":"w"},{"location":"api/seagulls-engine/seagulls/engine/#h","text":"h","title":"h"},{"location":"api/seagulls-engine/seagulls/engine/#width","text":"width","title":"width"},{"location":"api/seagulls-engine/seagulls/engine/#height","text":"height","title":"height"},{"location":"api/seagulls-engine/seagulls/engine/#top","text":"top","title":"top"},{"location":"api/seagulls-engine/seagulls/engine/#left","text":"left","title":"left"},{"location":"api/seagulls-engine/seagulls/engine/#bottom","text":"bottom","title":"bottom"},{"location":"api/seagulls-engine/seagulls/engine/#right","text":"right","title":"right"},{"location":"api/seagulls-engine/seagulls/engine/#centerx","text":"centerx","title":"centerx"},{"location":"api/seagulls-engine/seagulls/engine/#centery","text":"centery","title":"centery"},{"location":"api/seagulls-engine/seagulls/engine/#topleft","text":"topleft","title":"topleft"},{"location":"api/seagulls-engine/seagulls/engine/#topright","text":"topright","title":"topright"},{"location":"api/seagulls-engine/seagulls/engine/#bottomleft","text":"bottomleft","title":"bottomleft"},{"location":"api/seagulls-engine/seagulls/engine/#bottomright","text":"bottomright","title":"bottomright"},{"location":"api/seagulls-engine/seagulls/engine/#midtop","text":"midtop","title":"midtop"},{"location":"api/seagulls-engine/seagulls/engine/#midleft","text":"midleft","title":"midleft"},{"location":"api/seagulls-engine/seagulls/engine/#midbottom","text":"midbottom","title":"midbottom"},{"location":"api/seagulls-engine/seagulls/engine/#midright","text":"midright","title":"midright"},{"location":"api/seagulls-engine/seagulls/engine/#size","text":"size","title":"size"},{"location":"api/seagulls-engine/seagulls/engine/#center","text":"center","title":"center"},{"location":"api/seagulls-engine/seagulls/engine/#surface","text":"class Surface : Surface((width, height), flags=0, depth=0, masks=None) -> Surface Surface((width, height), flags=0, Surface) -> Surface pygame object for representing images","title":"Surface"},{"location":"api/seagulls-engine/seagulls/engine/#surface_1","text":"Surface ( * args , ** kwargs ):","title":"Surface()"},{"location":"api/seagulls-engine/seagulls/engine/#get_at","text":"def get_at ( unknown ): get_at((x, y)) -> Color get the color value at a single pixel","title":"get_at()"},{"location":"api/seagulls-engine/seagulls/engine/#set_at","text":"def set_at ( unknown ): set_at((x, y), Color) -> None set the color value for a single pixel","title":"set_at()"},{"location":"api/seagulls-engine/seagulls/engine/#get_at_mapped","text":"def get_at_mapped ( unknown ): get_at_mapped((x, y)) -> Color get the mapped color value at a single pixel","title":"get_at_mapped()"},{"location":"api/seagulls-engine/seagulls/engine/#map_rgb","text":"def map_rgb ( unknown ): map_rgb(Color) -> mapped_int convert a color into a mapped color value","title":"map_rgb()"},{"location":"api/seagulls-engine/seagulls/engine/#unmap_rgb","text":"def unmap_rgb ( unknown ): unmap_rgb(mapped_int) -> Color convert a mapped integer color value into a Color","title":"unmap_rgb()"},{"location":"api/seagulls-engine/seagulls/engine/#get_palette","text":"def get_palette ( unknown ): get_palette() -> [RGB, RGB, RGB, ...] get the color index palette for an 8-bit Surface","title":"get_palette()"},{"location":"api/seagulls-engine/seagulls/engine/#get_palette_at","text":"def get_palette_at ( unknown ): get_palette_at(index) -> RGB get the color for a single entry in a palette","title":"get_palette_at()"},{"location":"api/seagulls-engine/seagulls/engine/#set_palette","text":"def set_palette ( unknown ): set_palette([RGB, RGB, RGB, ...]) -> None set the color palette for an 8-bit Surface","title":"set_palette()"},{"location":"api/seagulls-engine/seagulls/engine/#set_palette_at","text":"def set_palette_at ( unknown ): set_palette_at(index, RGB) -> None set the color for a single index in an 8-bit Surface palette","title":"set_palette_at()"},{"location":"api/seagulls-engine/seagulls/engine/#lock","text":"def lock ( unknown ): lock() -> None lock the Surface memory for pixel access","title":"lock()"},{"location":"api/seagulls-engine/seagulls/engine/#unlock","text":"def unlock ( unknown ): unlock() -> None unlock the Surface memory from pixel access","title":"unlock()"},{"location":"api/seagulls-engine/seagulls/engine/#mustlock","text":"def mustlock ( unknown ): mustlock() -> bool test if the Surface requires locking","title":"mustlock()"},{"location":"api/seagulls-engine/seagulls/engine/#get_locked","text":"def get_locked ( unknown ): get_locked() -> bool test if the Surface is current locked","title":"get_locked()"},{"location":"api/seagulls-engine/seagulls/engine/#get_locks","text":"def get_locks ( unknown ): get_locks() -> tuple Gets the locks for the Surface","title":"get_locks()"},{"location":"api/seagulls-engine/seagulls/engine/#set_colorkey","text":"def set_colorkey ( unknown ): set_colorkey(Color, flags=0) -> None set_colorkey(None) -> None Set the transparent colorkey","title":"set_colorkey()"},{"location":"api/seagulls-engine/seagulls/engine/#get_colorkey","text":"def get_colorkey ( unknown ): get_colorkey() -> RGB or None Get the current transparent colorkey","title":"get_colorkey()"},{"location":"api/seagulls-engine/seagulls/engine/#set_alpha","text":"def set_alpha ( unknown ): set_alpha(value, flags=0) -> None set_alpha(None) -> None set the alpha value for the full Surface image","title":"set_alpha()"},{"location":"api/seagulls-engine/seagulls/engine/#get_alpha","text":"def get_alpha ( unknown ): get_alpha() -> int_value get the current Surface transparency value","title":"get_alpha()"},{"location":"api/seagulls-engine/seagulls/engine/#get_blendmode","text":"def get_blendmode ( unknown ): Return the surface's SDL 2 blend mode","title":"get_blendmode()"},{"location":"api/seagulls-engine/seagulls/engine/#copy_1","text":"def copy ( unknown ): copy() -> Surface create a new copy of a Surface","title":"copy()"},{"location":"api/seagulls-engine/seagulls/engine/#convert","text":"def convert ( unknown ): convert(Surface=None) -> Surface convert(depth, flags=0) -> Surface convert(masks, flags=0) -> Surface change the pixel format of an image","title":"convert()"},{"location":"api/seagulls-engine/seagulls/engine/#convert_alpha","text":"def convert_alpha ( unknown ): convert_alpha(Surface) -> Surface convert_alpha() -> Surface change the pixel format of an image including per pixel alphas","title":"convert_alpha()"},{"location":"api/seagulls-engine/seagulls/engine/#set_clip","text":"def set_clip ( unknown ): set_clip(rect) -> None set_clip(None) -> None set the current clipping area of the Surface","title":"set_clip()"},{"location":"api/seagulls-engine/seagulls/engine/#get_clip","text":"def get_clip ( unknown ): get_clip() -> Rect get the current clipping area of the Surface","title":"get_clip()"},{"location":"api/seagulls-engine/seagulls/engine/#fill","text":"def fill ( unknown ): fill(color, rect=None, special_flags=0) -> Rect fill Surface with a solid color","title":"fill()"},{"location":"api/seagulls-engine/seagulls/engine/#blit","text":"def blit ( unknown ): blit(source, dest, area=None, special_flags=0) -> Rect draw one image onto another","title":"blit()"},{"location":"api/seagulls-engine/seagulls/engine/#blits","text":"def blits ( unknown ): blits(blit_sequence=((source, dest), ...), doreturn=1) -> [Rect, ...] or None blits(((source, dest, area), ...)) -> [Rect, ...] blits(((source, dest, area, special_flags), ...)) -> [Rect, ...] draw many images onto another","title":"blits()"},{"location":"api/seagulls-engine/seagulls/engine/#scroll","text":"def scroll ( unknown ): scroll(dx=0, dy=0) -> None Shift the surface image in place","title":"scroll()"},{"location":"api/seagulls-engine/seagulls/engine/#get_flags","text":"def get_flags ( unknown ): get_flags() -> int get the additional flags used for the Surface","title":"get_flags()"},{"location":"api/seagulls-engine/seagulls/engine/#get_size","text":"def get_size ( unknown ): get_size() -> (width, height) get the dimensions of the Surface","title":"get_size()"},{"location":"api/seagulls-engine/seagulls/engine/#get_width","text":"def get_width ( unknown ): get_width() -> width get the width of the Surface","title":"get_width()"},{"location":"api/seagulls-engine/seagulls/engine/#get_height","text":"def get_height ( unknown ): get_height() -> height get the height of the Surface","title":"get_height()"},{"location":"api/seagulls-engine/seagulls/engine/#get_rect","text":"def get_rect ( unknown ): get_rect(**kwargs) -> Rect get the rectangular area of the Surface","title":"get_rect()"},{"location":"api/seagulls-engine/seagulls/engine/#get_pitch","text":"def get_pitch ( unknown ): get_pitch() -> int get the number of bytes used per Surface row","title":"get_pitch()"},{"location":"api/seagulls-engine/seagulls/engine/#get_bitsize","text":"def get_bitsize ( unknown ): get_bitsize() -> int get the bit depth of the Surface pixel format","title":"get_bitsize()"},{"location":"api/seagulls-engine/seagulls/engine/#get_bytesize","text":"def get_bytesize ( unknown ): get_bytesize() -> int get the bytes used per Surface pixel","title":"get_bytesize()"},{"location":"api/seagulls-engine/seagulls/engine/#get_masks","text":"def get_masks ( unknown ): get_masks() -> (R, G, B, A) the bitmasks needed to convert between a color and a mapped integer","title":"get_masks()"},{"location":"api/seagulls-engine/seagulls/engine/#get_shifts","text":"def get_shifts ( unknown ): get_shifts() -> (R, G, B, A) the bit shifts needed to convert between a color and a mapped integer","title":"get_shifts()"},{"location":"api/seagulls-engine/seagulls/engine/#set_masks","text":"def set_masks ( unknown ): set_masks((r,g,b,a)) -> None set the bitmasks needed to convert between a color and a mapped integer","title":"set_masks()"},{"location":"api/seagulls-engine/seagulls/engine/#set_shifts","text":"def set_shifts ( unknown ): set_shifts((r,g,b,a)) -> None sets the bit shifts needed to convert between a color and a mapped integer","title":"set_shifts()"},{"location":"api/seagulls-engine/seagulls/engine/#get_losses","text":"def get_losses ( unknown ): get_losses() -> (R, G, B, A) the significant bits used to convert between a color and a mapped integer","title":"get_losses()"},{"location":"api/seagulls-engine/seagulls/engine/#subsurface","text":"def subsurface ( unknown ): subsurface(Rect) -> Surface create a new surface that references its parent","title":"subsurface()"},{"location":"api/seagulls-engine/seagulls/engine/#get_offset","text":"def get_offset ( unknown ): get_offset() -> (x, y) find the position of a child subsurface inside a parent","title":"get_offset()"},{"location":"api/seagulls-engine/seagulls/engine/#get_abs_offset","text":"def get_abs_offset ( unknown ): get_abs_offset() -> (x, y) find the absolute position of a child subsurface inside its top level parent","title":"get_abs_offset()"},{"location":"api/seagulls-engine/seagulls/engine/#get_parent","text":"def get_parent ( unknown ): get_parent() -> Surface find the parent of a subsurface","title":"get_parent()"},{"location":"api/seagulls-engine/seagulls/engine/#get_abs_parent","text":"def get_abs_parent ( unknown ): get_abs_parent() -> Surface find the top level parent of a subsurface","title":"get_abs_parent()"},{"location":"api/seagulls-engine/seagulls/engine/#get_bounding_rect","text":"def get_bounding_rect ( unknown ): get_bounding_rect(min_alpha = 1) -> Rect find the smallest rect containing data","title":"get_bounding_rect()"},{"location":"api/seagulls-engine/seagulls/engine/#get_view","text":"def get_view ( unknown ): get_view(<kind>='2') -> BufferProxy return a buffer view of the Surface's pixels.","title":"get_view()"},{"location":"api/seagulls-engine/seagulls/engine/#get_buffer","text":"def get_buffer ( unknown ): get_buffer() -> BufferProxy acquires a buffer object for the pixels of the Surface.","title":"get_buffer()"},{"location":"api/seagulls-engine/seagulls/engine/#color","text":"class Color : Color(r, g, b) -> Color Color(r, g, b, a=255) -> Color Color(color_value) -> Color pygame object for color representations","title":"Color"},{"location":"api/seagulls-engine/seagulls/engine/#color_1","text":"Color ( * args , ** kwargs ):","title":"Color()"},{"location":"api/seagulls-engine/seagulls/engine/#normalize_1","text":"def normalize ( unknown ): normalize() -> tuple Returns the normalized RGBA values of the Color.","title":"normalize()"},{"location":"api/seagulls-engine/seagulls/engine/#correct_gamma","text":"def correct_gamma ( unknown ): correct_gamma (gamma) -> Color Applies a certain gamma value to the Color.","title":"correct_gamma()"},{"location":"api/seagulls-engine/seagulls/engine/#set_length","text":"def set_length ( unknown ): set_length(len) -> None Set the number of elements in the Color to 1,2,3, or 4.","title":"set_length()"},{"location":"api/seagulls-engine/seagulls/engine/#lerp","text":"def lerp ( unknown ): lerp(Color, float) -> Color returns a linear interpolation to the given Color.","title":"lerp()"},{"location":"api/seagulls-engine/seagulls/engine/#premul_alpha","text":"def premul_alpha ( unknown ): premul_alpha() -> Color returns a Color where the r,g,b components have been multiplied by the alpha.","title":"premul_alpha()"},{"location":"api/seagulls-engine/seagulls/engine/#update_1","text":"def update ( unknown ): update(r, g, b) -> None update(r, g, b, a=255) -> None update(color_value) -> None Sets the elements of the color","title":"update()"},{"location":"api/seagulls-engine/seagulls/engine/#r","text":"r r -> int Gets or sets the red value of the Color.","title":"r"},{"location":"api/seagulls-engine/seagulls/engine/#g","text":"g g -> int Gets or sets the green value of the Color.","title":"g"},{"location":"api/seagulls-engine/seagulls/engine/#b","text":"b b -> int Gets or sets the blue value of the Color.","title":"b"},{"location":"api/seagulls-engine/seagulls/engine/#a","text":"a a -> int Gets or sets the alpha value of the Color.","title":"a"},{"location":"api/seagulls-engine/seagulls/engine/#hsva","text":"hsva hsva -> tuple Gets or sets the HSVA representation of the Color.","title":"hsva"},{"location":"api/seagulls-engine/seagulls/engine/#hsla","text":"hsla hsla -> tuple Gets or sets the HSLA representation of the Color.","title":"hsla"},{"location":"api/seagulls-engine/seagulls/engine/#i1i2i3","text":"i1i2i3 i1i2i3 -> tuple Gets or sets the I1I2I3 representation of the Color.","title":"i1i2i3"},{"location":"api/seagulls-engine/seagulls/engine/#cmy","text":"cmy cmy -> tuple Gets or sets the CMY representation of the Color.","title":"cmy"},{"location":"api/seagulls-engine/seagulls/engine/#pixelarray","text":"class PixelArray : PixelArray(Surface) -> PixelArray pygame object for direct pixel access of surfaces","title":"PixelArray"},{"location":"api/seagulls-engine/seagulls/engine/#pixelarray_1","text":"PixelArray ():","title":"PixelArray()"},{"location":"api/seagulls-engine/seagulls/engine/#compare","text":"def compare ( unknown ): compare(array, distance=0, weights=(0.299, 0.587, 0.114)) -> PixelArray Compares the PixelArray with another one.","title":"compare()"},{"location":"api/seagulls-engine/seagulls/engine/#extract","text":"def extract ( unknown ): extract(color, distance=0, weights=(0.299, 0.587, 0.114)) -> PixelArray Extracts the passed color from the PixelArray.","title":"extract()"},{"location":"api/seagulls-engine/seagulls/engine/#make_surface","text":"def make_surface ( unknown ): make_surface() -> Surface Creates a new Surface from the current PixelArray.","title":"make_surface()"},{"location":"api/seagulls-engine/seagulls/engine/#close","text":"def close ( unknown ): transpose() -> PixelArray Closes the PixelArray, and releases Surface lock.","title":"close()"},{"location":"api/seagulls-engine/seagulls/engine/#replace","text":"def replace ( unknown ): replace(color, repcolor, distance=0, weights=(0.299, 0.587, 0.114)) -> None Replaces the passed color in the PixelArray with another one.","title":"replace()"},{"location":"api/seagulls-engine/seagulls/engine/#transpose","text":"def transpose ( unknown ): transpose() -> PixelArray Exchanges the x and y axis.","title":"transpose()"},{"location":"api/seagulls-engine/seagulls/engine/#surface_2","text":"surface surface -> Surface Gets the Surface the PixelArray uses.","title":"surface"},{"location":"api/seagulls-engine/seagulls/engine/#itemsize","text":"itemsize itemsize -> int Returns the byte size of a pixel array item","title":"itemsize"},{"location":"api/seagulls-engine/seagulls/engine/#shape","text":"shape shape -> tuple of int's Returns the array size.","title":"shape"},{"location":"api/seagulls-engine/seagulls/engine/#strides","text":"strides strides -> tuple of int's Returns byte offsets for each array dimension.","title":"strides"},{"location":"api/seagulls-engine/seagulls/engine/#ndim","text":"ndim ndim -> int Returns the number of dimensions.","title":"ndim"},{"location":"api/seagulls-engine/seagulls/engine/#vector2","text":"class Vector2 : Vector2() -> Vector2 Vector2(int) -> Vector2 Vector2(float) -> Vector2 Vector2(Vector2) -> Vector2 Vector2(x, y) -> Vector2 Vector2((x, y)) -> Vector2 a 2-Dimensional Vector","title":"Vector2"},{"location":"api/seagulls-engine/seagulls/engine/#vector2_1","text":"Vector2 ( * args , ** kwargs ):","title":"Vector2()"},{"location":"api/seagulls-engine/seagulls/engine/#length","text":"def length ( unknown ): length() -> float returns the Euclidean length of the vector.","title":"length()"},{"location":"api/seagulls-engine/seagulls/engine/#length_squared","text":"def length_squared ( unknown ): length_squared() -> float returns the squared Euclidean length of the vector.","title":"length_squared()"},{"location":"api/seagulls-engine/seagulls/engine/#magnitude","text":"def magnitude ( unknown ): magnitude() -> float returns the Euclidean magnitude of the vector.","title":"magnitude()"},{"location":"api/seagulls-engine/seagulls/engine/#magnitude_squared","text":"def magnitude_squared ( unknown ): magnitude_squared() -> float returns the squared magnitude of the vector.","title":"magnitude_squared()"},{"location":"api/seagulls-engine/seagulls/engine/#rotate","text":"def rotate ( unknown ): rotate(angle) -> Vector2 rotates a vector by a given angle in degrees.","title":"rotate()"},{"location":"api/seagulls-engine/seagulls/engine/#rotate_ip","text":"def rotate_ip ( unknown ): rotate_ip(angle) -> None rotates the vector by a given angle in degrees in place.","title":"rotate_ip()"},{"location":"api/seagulls-engine/seagulls/engine/#rotate_rad","text":"def rotate_rad ( unknown ): rotate_rad(angle) -> Vector2 rotates a vector by a given angle in radians.","title":"rotate_rad()"},{"location":"api/seagulls-engine/seagulls/engine/#rotate_rad_ip","text":"def rotate_rad_ip ( unknown ): rotate_rad_ip(angle) -> None rotates the vector by a given angle in radians in place.","title":"rotate_rad_ip()"},{"location":"api/seagulls-engine/seagulls/engine/#rotate_ip_rad","text":"def rotate_ip_rad ( unknown ): rotate_ip_rad(angle) -> None rotates the vector by a given angle in radians in place.","title":"rotate_ip_rad()"},{"location":"api/seagulls-engine/seagulls/engine/#slerp","text":"def slerp ( unknown ): slerp(Vector2, float) -> Vector2 returns a spherical interpolation to the given vector.","title":"slerp()"},{"location":"api/seagulls-engine/seagulls/engine/#lerp_1","text":"def lerp ( unknown ): lerp(Vector2, float) -> Vector2 returns a linear interpolation to the given vector.","title":"lerp()"},{"location":"api/seagulls-engine/seagulls/engine/#normalize_2","text":"def normalize ( unknown ): normalize() -> Vector2 returns a vector with the same direction but length 1.","title":"normalize()"},{"location":"api/seagulls-engine/seagulls/engine/#normalize_ip","text":"def normalize_ip ( unknown ): normalize_ip() -> None normalizes the vector in place so that its length is 1.","title":"normalize_ip()"},{"location":"api/seagulls-engine/seagulls/engine/#is_normalized","text":"def is_normalized ( unknown ): is_normalized() -> Bool tests if the vector is normalized i.e. has length == 1.","title":"is_normalized()"},{"location":"api/seagulls-engine/seagulls/engine/#cross","text":"def cross ( unknown ): cross(Vector2) -> Vector2 calculates the cross- or vector-product","title":"cross()"},{"location":"api/seagulls-engine/seagulls/engine/#dot","text":"def dot ( unknown ): dot(Vector2) -> float calculates the dot- or scalar-product with the other vector","title":"dot()"},{"location":"api/seagulls-engine/seagulls/engine/#angle_to","text":"def angle_to ( unknown ): angle_to(Vector2) -> float calculates the angle to a given vector in degrees.","title":"angle_to()"},{"location":"api/seagulls-engine/seagulls/engine/#update_2","text":"def update ( unknown ): update() -> None update(int) -> None update(float) -> None update(Vector2) -> None update(x, y) -> None update((x, y)) -> None Sets the coordinates of the vector.","title":"update()"},{"location":"api/seagulls-engine/seagulls/engine/#scale_to_length","text":"def scale_to_length ( unknown ): scale_to_length(float) -> None scales the vector to a given length.","title":"scale_to_length()"},{"location":"api/seagulls-engine/seagulls/engine/#reflect","text":"def reflect ( unknown ): reflect(Vector2) -> Vector2 returns a vector reflected of a given normal.","title":"reflect()"},{"location":"api/seagulls-engine/seagulls/engine/#reflect_ip","text":"def reflect_ip ( unknown ): reflect_ip(Vector2) -> None reflect the vector of a given normal in place.","title":"reflect_ip()"},{"location":"api/seagulls-engine/seagulls/engine/#distance_to","text":"def distance_to ( unknown ): distance_to(Vector2) -> float calculates the Euclidean distance to a given vector.","title":"distance_to()"},{"location":"api/seagulls-engine/seagulls/engine/#distance_squared_to","text":"def distance_squared_to ( unknown ): distance_squared_to(Vector2) -> float calculates the squared Euclidean distance to a given vector.","title":"distance_squared_to()"},{"location":"api/seagulls-engine/seagulls/engine/#elementwise","text":"def elementwise ( unknown ): elementwise() -> VectorElementwiseProxy The next operation will be performed elementwise.","title":"elementwise()"},{"location":"api/seagulls-engine/seagulls/engine/#as_polar","text":"def as_polar ( unknown ): as_polar() -> (r, phi) returns a tuple with radial distance and azimuthal angle.","title":"as_polar()"},{"location":"api/seagulls-engine/seagulls/engine/#from_polar","text":"def from_polar ( unknown ): from_polar((r, phi)) -> None Sets x and y from a polar coordinates tuple.","title":"from_polar()"},{"location":"api/seagulls-engine/seagulls/engine/#project","text":"def project ( unknown ): project(Vector2) -> Vector2 projects a vector onto another.","title":"project()"},{"location":"api/seagulls-engine/seagulls/engine/#copy_2","text":"def copy ( unknown ): copy() -> Vector2 Returns a copy of itself.","title":"copy()"},{"location":"api/seagulls-engine/seagulls/engine/#epsilon","text":"epsilon small value used in comparisons","title":"epsilon"},{"location":"api/seagulls-engine/seagulls/engine/#x_1","text":"x","title":"x"},{"location":"api/seagulls-engine/seagulls/engine/#y_1","text":"y","title":"y"},{"location":"api/seagulls-engine/seagulls/engine/#vector3","text":"class Vector3 : Vector3() -> Vector3 Vector3(int) -> Vector3 Vector3(float) -> Vector3 Vector3(Vector3) -> Vector3 Vector3(x, y, z) -> Vector3 Vector3((x, y, z)) -> Vector3 a 3-Dimensional Vector","title":"Vector3"},{"location":"api/seagulls-engine/seagulls/engine/#vector3_1","text":"Vector3 ( * args , ** kwargs ):","title":"Vector3()"},{"location":"api/seagulls-engine/seagulls/engine/#length_1","text":"def length ( unknown ): length() -> float returns the Euclidean length of the vector.","title":"length()"},{"location":"api/seagulls-engine/seagulls/engine/#length_squared_1","text":"def length_squared ( unknown ): length_squared() -> float returns the squared Euclidean length of the vector.","title":"length_squared()"},{"location":"api/seagulls-engine/seagulls/engine/#magnitude_1","text":"def magnitude ( unknown ): magnitude() -> float returns the Euclidean magnitude of the vector.","title":"magnitude()"},{"location":"api/seagulls-engine/seagulls/engine/#magnitude_squared_1","text":"def magnitude_squared ( unknown ): magnitude_squared() -> float returns the squared Euclidean magnitude of the vector.","title":"magnitude_squared()"},{"location":"api/seagulls-engine/seagulls/engine/#rotate_1","text":"def rotate ( unknown ): rotate(angle, Vector3) -> Vector3 rotates a vector by a given angle in degrees.","title":"rotate()"},{"location":"api/seagulls-engine/seagulls/engine/#rotate_ip_1","text":"def rotate_ip ( unknown ): rotate_ip(angle, Vector3) -> None rotates the vector by a given angle in degrees in place.","title":"rotate_ip()"},{"location":"api/seagulls-engine/seagulls/engine/#rotate_rad_1","text":"def rotate_rad ( unknown ): rotate_rad(angle, Vector3) -> Vector3 rotates a vector by a given angle in radians.","title":"rotate_rad()"},{"location":"api/seagulls-engine/seagulls/engine/#rotate_rad_ip_1","text":"def rotate_rad_ip ( unknown ): rotate_rad_ip(angle, Vector3) -> None rotates the vector by a given angle in radians in place.","title":"rotate_rad_ip()"},{"location":"api/seagulls-engine/seagulls/engine/#rotate_ip_rad_1","text":"def rotate_ip_rad ( unknown ): rotate_ip_rad(angle, Vector3) -> None rotates the vector by a given angle in radians in place.","title":"rotate_ip_rad()"},{"location":"api/seagulls-engine/seagulls/engine/#rotate_x","text":"def rotate_x ( unknown ): rotate_x(angle) -> Vector3 rotates a vector around the x-axis by the angle in degrees.","title":"rotate_x()"},{"location":"api/seagulls-engine/seagulls/engine/#rotate_x_ip","text":"def rotate_x_ip ( unknown ): rotate_x_ip(angle) -> None rotates the vector around the x-axis by the angle in degrees in place.","title":"rotate_x_ip()"},{"location":"api/seagulls-engine/seagulls/engine/#rotate_x_rad","text":"def rotate_x_rad ( unknown ): rotate_x_rad(angle) -> Vector3 rotates a vector around the x-axis by the angle in radians.","title":"rotate_x_rad()"},{"location":"api/seagulls-engine/seagulls/engine/#rotate_x_rad_ip","text":"def rotate_x_rad_ip ( unknown ): rotate_x_rad_ip(angle) -> None rotates the vector around the x-axis by the angle in radians in place.","title":"rotate_x_rad_ip()"},{"location":"api/seagulls-engine/seagulls/engine/#rotate_x_ip_rad","text":"def rotate_x_ip_rad ( unknown ): rotate_x_ip_rad(angle) -> None rotates the vector around the x-axis by the angle in radians in place.","title":"rotate_x_ip_rad()"},{"location":"api/seagulls-engine/seagulls/engine/#rotate_y","text":"def rotate_y ( unknown ): rotate_y(angle) -> Vector3 rotates a vector around the y-axis by the angle in degrees.","title":"rotate_y()"},{"location":"api/seagulls-engine/seagulls/engine/#rotate_y_ip","text":"def rotate_y_ip ( unknown ): rotate_y_ip(angle) -> None rotates the vector around the y-axis by the angle in degrees in place.","title":"rotate_y_ip()"},{"location":"api/seagulls-engine/seagulls/engine/#rotate_y_rad","text":"def rotate_y_rad ( unknown ): rotate_y_rad(angle) -> Vector3 rotates a vector around the y-axis by the angle in radians.","title":"rotate_y_rad()"},{"location":"api/seagulls-engine/seagulls/engine/#rotate_y_rad_ip","text":"def rotate_y_rad_ip ( unknown ): rotate_y_rad_ip(angle) -> None rotates the vector around the y-axis by the angle in radians in place.","title":"rotate_y_rad_ip()"},{"location":"api/seagulls-engine/seagulls/engine/#rotate_y_ip_rad","text":"def rotate_y_ip_rad ( unknown ): rotate_y_ip_rad(angle) -> None rotates the vector around the y-axis by the angle in radians in place.","title":"rotate_y_ip_rad()"},{"location":"api/seagulls-engine/seagulls/engine/#rotate_z","text":"def rotate_z ( unknown ): rotate_z(angle) -> Vector3 rotates a vector around the z-axis by the angle in degrees.","title":"rotate_z()"},{"location":"api/seagulls-engine/seagulls/engine/#rotate_z_ip","text":"def rotate_z_ip ( unknown ): rotate_z_ip(angle) -> None rotates the vector around the z-axis by the angle in degrees in place.","title":"rotate_z_ip()"},{"location":"api/seagulls-engine/seagulls/engine/#rotate_z_rad","text":"def rotate_z_rad ( unknown ): rotate_z_rad(angle) -> Vector3 rotates a vector around the z-axis by the angle in radians.","title":"rotate_z_rad()"},{"location":"api/seagulls-engine/seagulls/engine/#rotate_z_rad_ip","text":"def rotate_z_rad_ip ( unknown ): rotate_z_rad_ip(angle) -> None rotates the vector around the z-axis by the angle in radians in place.","title":"rotate_z_rad_ip()"},{"location":"api/seagulls-engine/seagulls/engine/#rotate_z_ip_rad","text":"def rotate_z_ip_rad ( unknown ): rotate_z_ip_rad(angle) -> None rotates the vector around the z-axis by the angle in radians in place.","title":"rotate_z_ip_rad()"},{"location":"api/seagulls-engine/seagulls/engine/#slerp_1","text":"def slerp ( unknown ): slerp(Vector3, float) -> Vector3 returns a spherical interpolation to the given vector.","title":"slerp()"},{"location":"api/seagulls-engine/seagulls/engine/#lerp_2","text":"def lerp ( unknown ): lerp(Vector3, float) -> Vector3 returns a linear interpolation to the given vector.","title":"lerp()"},{"location":"api/seagulls-engine/seagulls/engine/#normalize_3","text":"def normalize ( unknown ): normalize() -> Vector3 returns a vector with the same direction but length 1.","title":"normalize()"},{"location":"api/seagulls-engine/seagulls/engine/#normalize_ip_1","text":"def normalize_ip ( unknown ): normalize_ip() -> None normalizes the vector in place so that its length is 1.","title":"normalize_ip()"},{"location":"api/seagulls-engine/seagulls/engine/#is_normalized_1","text":"def is_normalized ( unknown ): is_normalized() -> Bool tests if the vector is normalized i.e. has length == 1.","title":"is_normalized()"},{"location":"api/seagulls-engine/seagulls/engine/#cross_1","text":"def cross ( unknown ): cross(Vector3) -> Vector3 calculates the cross- or vector-product","title":"cross()"},{"location":"api/seagulls-engine/seagulls/engine/#dot_1","text":"def dot ( unknown ): dot(Vector3) -> float calculates the dot- or scalar-product with the other vector","title":"dot()"},{"location":"api/seagulls-engine/seagulls/engine/#angle_to_1","text":"def angle_to ( unknown ): angle_to(Vector3) -> float calculates the angle to a given vector in degrees.","title":"angle_to()"},{"location":"api/seagulls-engine/seagulls/engine/#update_3","text":"def update ( unknown ): update() -> None update(int) -> None update(float) -> None update(Vector3) -> None update(x, y, z) -> None update((x, y, z)) -> None Sets the coordinates of the vector.","title":"update()"},{"location":"api/seagulls-engine/seagulls/engine/#scale_to_length_1","text":"def scale_to_length ( unknown ): scale_to_length(float) -> None scales the vector to a given length.","title":"scale_to_length()"},{"location":"api/seagulls-engine/seagulls/engine/#reflect_1","text":"def reflect ( unknown ): reflect(Vector3) -> Vector3 returns a vector reflected of a given normal.","title":"reflect()"},{"location":"api/seagulls-engine/seagulls/engine/#reflect_ip_1","text":"def reflect_ip ( unknown ): reflect_ip(Vector3) -> None reflect the vector of a given normal in place.","title":"reflect_ip()"},{"location":"api/seagulls-engine/seagulls/engine/#distance_to_1","text":"def distance_to ( unknown ): distance_to(Vector3) -> float calculates the Euclidean distance to a given vector.","title":"distance_to()"},{"location":"api/seagulls-engine/seagulls/engine/#distance_squared_to_1","text":"def distance_squared_to ( unknown ): distance_squared_to(Vector3) -> float calculates the squared Euclidean distance to a given vector.","title":"distance_squared_to()"},{"location":"api/seagulls-engine/seagulls/engine/#elementwise_1","text":"def elementwise ( unknown ): elementwise() -> VectorElementwiseProxy The next operation will be performed elementwise.","title":"elementwise()"},{"location":"api/seagulls-engine/seagulls/engine/#as_spherical","text":"def as_spherical ( unknown ): as_spherical() -> (r, theta, phi) returns a tuple with radial distance, inclination and azimuthal angle.","title":"as_spherical()"},{"location":"api/seagulls-engine/seagulls/engine/#from_spherical","text":"def from_spherical ( unknown ): from_spherical((r, theta, phi)) -> None Sets x, y and z from a spherical coordinates 3-tuple.","title":"from_spherical()"},{"location":"api/seagulls-engine/seagulls/engine/#project_1","text":"def project ( unknown ): project(Vector3) -> Vector3 projects a vector onto another.","title":"project()"},{"location":"api/seagulls-engine/seagulls/engine/#copy_3","text":"def copy ( unknown ): copy() -> Vector3 Returns a copy of itself.","title":"copy()"},{"location":"api/seagulls-engine/seagulls/engine/#epsilon_1","text":"epsilon small value used in comparisons","title":"epsilon"},{"location":"api/seagulls-engine/seagulls/engine/#x_2","text":"x","title":"x"},{"location":"api/seagulls-engine/seagulls/engine/#y_2","text":"y","title":"y"},{"location":"api/seagulls-engine/seagulls/engine/#z","text":"z","title":"z"},{"location":"api/seagulls-engine/seagulls/eventing/","text":"seagulls .eventing \u00b6 View Source from ._interfaces import ( IDispatchEvents , EventType , EventCallbackType , ) __all__ = [ \"IDispatchEvents\" , \"EventType\" , \"EventCallbackType\" , ] IDispatchEvents \u00b6 class IDispatchEvents ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class IDispatchEvents ( Protocol ): @abstractmethod def register_callback ( self , event_type : Type [ EventType ], callback : EventCallbackType ) -> None : ... def trigger_event ( self , event : EventType ) -> None : ... register_callback() \u00b6 @abstractmethod def register_callback ( self , event_type : Type [ ~ EventType ], callback : Callable [[ ~ EventType ], NoneType ] ) -> None : View Source @abstractmethod def register_callback ( self , event_type : Type [ EventType ], callback : EventCallbackType ) -> None : ... trigger_event() \u00b6 def trigger_event ( self , event : ~ EventType ) -> None : View Source def trigger_event ( self , event : EventType ) -> None : ... EventType \u00b6 EventType = ~ EventType EventCallbackType \u00b6 EventCallbackType = typing . Callable [[ ~ EventType ], NoneType ]","title":"seagulls.eventing"},{"location":"api/seagulls-engine/seagulls/eventing/#seagullseventing","text":"View Source from ._interfaces import ( IDispatchEvents , EventType , EventCallbackType , ) __all__ = [ \"IDispatchEvents\" , \"EventType\" , \"EventCallbackType\" , ]","title":"seagulls.eventing"},{"location":"api/seagulls-engine/seagulls/eventing/#idispatchevents","text":"class IDispatchEvents ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class IDispatchEvents ( Protocol ): @abstractmethod def register_callback ( self , event_type : Type [ EventType ], callback : EventCallbackType ) -> None : ... def trigger_event ( self , event : EventType ) -> None : ...","title":"IDispatchEvents"},{"location":"api/seagulls-engine/seagulls/eventing/#register_callback","text":"@abstractmethod def register_callback ( self , event_type : Type [ ~ EventType ], callback : Callable [[ ~ EventType ], NoneType ] ) -> None : View Source @abstractmethod def register_callback ( self , event_type : Type [ EventType ], callback : EventCallbackType ) -> None : ...","title":"register_callback()"},{"location":"api/seagulls-engine/seagulls/eventing/#trigger_event","text":"def trigger_event ( self , event : ~ EventType ) -> None : View Source def trigger_event ( self , event : EventType ) -> None : ...","title":"trigger_event()"},{"location":"api/seagulls-engine/seagulls/eventing/#eventtype","text":"EventType = ~ EventType","title":"EventType"},{"location":"api/seagulls-engine/seagulls/eventing/#eventcallbacktype","text":"EventCallbackType = typing . Callable [[ ~ EventType ], NoneType ]","title":"EventCallbackType"},{"location":"api/seagulls-engine/seagulls/seagulls_cli/","text":"seagulls .seagulls_cli \u00b6 View Source from ._application import SeagullsCliApplication from ._entry_point import main __all__ = [ \"SeagullsCliApplication\" , \"main\" , ] SeagullsCliApplication \u00b6 class SeagullsCliApplication ( seagulls . app . _app_interfaces . ISeagullsApplicationseagulls . app . _plugin_interfaces . IPluggableSeagullsApplicationseagulls . eventing . _interfaces . IDispatchEvents ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class SeagullsCliApplication ( ISeagullsApplication , IPluggableSeagullsApplication , IDispatchEvents ): _container_repository : DiContainerRepository _plugin_client : ISeagullsPluginClient _logging_client : LoggingClient _request : CliRequest _plugins : Dict [ Any , Any ] _callbacks : Dict [ Any , List [ Any ]] def __init__ ( self , container_repository : DiContainerRepository , plugin_client : ISeagullsPluginClient , logging_client : LoggingClient , request : CliRequest ): self . _container_repository = container_repository self . _plugin_client = plugin_client self . _logging_client = logging_client self . _request = request self . _plugins = {} self . _callbacks = {} def execute ( self ) -> None : self . _plugin_client . register_plugins ( self ) self . trigger_event ( PostPluginRegistrationEvent ()) self . _request . execute ( event_dispatcher = self ) def register_container ( self , key : Type [ ObjectType ], container : ObjectType ) -> None : self . _container_repository . register ( key , container ) def get_container ( self , key : Type [ ObjectType ]) -> ObjectType : return self . _container_repository . get ( key ) def register_callback ( self , event_type : Type [ EventType ], callback : EventCallbackType ) -> None : if event_type not in self . _callbacks : self . _callbacks [ event_type ] = [] self . _callbacks [ event_type ] . append ( callback ) def trigger_event ( self , event : EventType ) -> None : for callback in self . _callbacks . get ( type ( event ), []): callback ( event ) def register_plugin ( self , plugin : ISeagullsApplicationPlugin ) -> None : if type ( plugin ) in self . _plugins : raise DuplicatePluginError ( plugin ) self . _plugins [ type ( plugin )] = plugin plugin . on_registration () @lru_cache () def get_plugin ( self , plugin_type : Type [ PluginType ]) -> PluginType : # type: ignore return self . _plugins [ plugin_type ] def _apply_to_plugins ( self , callback : Callable [[ PluginType ], None ]) -> None : for plugin in self . _plugins . values (): callback ( plugin ) SeagullsCliApplication() \u00b6 SeagullsCliApplication ( container_repository : seagulls . seagulls_cli . _container_repository . DiContainerRepository , plugin_client : seagulls . app . _plugin_interfaces . ISeagullsPluginClient , logging_client : seagulls . seagulls_cli . _logging_client . LoggingClient , request : seagulls . cli . _request . CliRequest ): View Source def __init__ ( self , container_repository : DiContainerRepository , plugin_client : ISeagullsPluginClient , logging_client : LoggingClient , request : CliRequest ): self . _container_repository = container_repository self . _plugin_client = plugin_client self . _logging_client = logging_client self . _request = request self . _plugins = {} self . _callbacks = {} execute() \u00b6 def execute ( self ) -> None : View Source def execute ( self ) -> None : self . _plugin_client . register_plugins ( self ) self . trigger_event ( PostPluginRegistrationEvent ()) self . _request . execute ( event_dispatcher = self ) register_container() \u00b6 def register_container ( self , key : Type [ ~ ObjectType ], container : ~ ObjectType ) -> None : View Source def register_container ( self , key : Type [ ObjectType ], container : ObjectType ) -> None : self . _container_repository . register ( key , container ) get_container() \u00b6 def get_container ( self , key : Type [ ~ ObjectType ]) -> ~ ObjectType : View Source def get_container ( self , key : Type [ ObjectType ]) -> ObjectType : return self . _container_repository . get ( key ) register_callback() \u00b6 def register_callback ( self , event_type : Type [ ~ EventType ], callback : Callable [[ ~ EventType ], NoneType ] ) -> None : View Source def register_callback ( self , event_type : Type [ EventType ], callback : EventCallbackType ) -> None : if event_type not in self . _callbacks : self . _callbacks [ event_type ] = [] self . _callbacks [ event_type ] . append ( callback ) trigger_event() \u00b6 def trigger_event ( self , event : ~ EventType ) -> None : View Source def trigger_event ( self , event : EventType ) -> None : for callback in self . _callbacks . get ( type ( event ), []): callback ( event ) register_plugin() \u00b6 def register_plugin ( self , plugin : seagulls . app . _plugin_interfaces . ISeagullsApplicationPlugin ) -> None : View Source def register_plugin ( self , plugin : ISeagullsApplicationPlugin ) -> None : if type ( plugin ) in self . _plugins : raise DuplicatePluginError ( plugin ) self . _plugins [ type ( plugin )] = plugin plugin . on_registration () get_plugin() \u00b6 @lru_cache () def get_plugin ( self , plugin_type : Type [ ~ PluginType ]) -> ~ PluginType : View Source @lru_cache () def get_plugin ( self , plugin_type : Type [ PluginType ]) -> PluginType : # type: ignore return self . _plugins [ plugin_type ] main() \u00b6 def main (): View Source def main (): di_container = SeagullsAppDiContainer () app = di_container . application () app . execute ()","title":"seagulls.seagulls_cli"},{"location":"api/seagulls-engine/seagulls/seagulls_cli/#seagullsseagulls_cli","text":"View Source from ._application import SeagullsCliApplication from ._entry_point import main __all__ = [ \"SeagullsCliApplication\" , \"main\" , ]","title":"seagulls.seagulls_cli"},{"location":"api/seagulls-engine/seagulls/seagulls_cli/#seagullscliapplication","text":"class SeagullsCliApplication ( seagulls . app . _app_interfaces . ISeagullsApplicationseagulls . app . _plugin_interfaces . IPluggableSeagullsApplicationseagulls . eventing . _interfaces . IDispatchEvents ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class SeagullsCliApplication ( ISeagullsApplication , IPluggableSeagullsApplication , IDispatchEvents ): _container_repository : DiContainerRepository _plugin_client : ISeagullsPluginClient _logging_client : LoggingClient _request : CliRequest _plugins : Dict [ Any , Any ] _callbacks : Dict [ Any , List [ Any ]] def __init__ ( self , container_repository : DiContainerRepository , plugin_client : ISeagullsPluginClient , logging_client : LoggingClient , request : CliRequest ): self . _container_repository = container_repository self . _plugin_client = plugin_client self . _logging_client = logging_client self . _request = request self . _plugins = {} self . _callbacks = {} def execute ( self ) -> None : self . _plugin_client . register_plugins ( self ) self . trigger_event ( PostPluginRegistrationEvent ()) self . _request . execute ( event_dispatcher = self ) def register_container ( self , key : Type [ ObjectType ], container : ObjectType ) -> None : self . _container_repository . register ( key , container ) def get_container ( self , key : Type [ ObjectType ]) -> ObjectType : return self . _container_repository . get ( key ) def register_callback ( self , event_type : Type [ EventType ], callback : EventCallbackType ) -> None : if event_type not in self . _callbacks : self . _callbacks [ event_type ] = [] self . _callbacks [ event_type ] . append ( callback ) def trigger_event ( self , event : EventType ) -> None : for callback in self . _callbacks . get ( type ( event ), []): callback ( event ) def register_plugin ( self , plugin : ISeagullsApplicationPlugin ) -> None : if type ( plugin ) in self . _plugins : raise DuplicatePluginError ( plugin ) self . _plugins [ type ( plugin )] = plugin plugin . on_registration () @lru_cache () def get_plugin ( self , plugin_type : Type [ PluginType ]) -> PluginType : # type: ignore return self . _plugins [ plugin_type ] def _apply_to_plugins ( self , callback : Callable [[ PluginType ], None ]) -> None : for plugin in self . _plugins . values (): callback ( plugin )","title":"SeagullsCliApplication"},{"location":"api/seagulls-engine/seagulls/seagulls_cli/#seagullscliapplication_1","text":"SeagullsCliApplication ( container_repository : seagulls . seagulls_cli . _container_repository . DiContainerRepository , plugin_client : seagulls . app . _plugin_interfaces . ISeagullsPluginClient , logging_client : seagulls . seagulls_cli . _logging_client . LoggingClient , request : seagulls . cli . _request . CliRequest ): View Source def __init__ ( self , container_repository : DiContainerRepository , plugin_client : ISeagullsPluginClient , logging_client : LoggingClient , request : CliRequest ): self . _container_repository = container_repository self . _plugin_client = plugin_client self . _logging_client = logging_client self . _request = request self . _plugins = {} self . _callbacks = {}","title":"SeagullsCliApplication()"},{"location":"api/seagulls-engine/seagulls/seagulls_cli/#execute","text":"def execute ( self ) -> None : View Source def execute ( self ) -> None : self . _plugin_client . register_plugins ( self ) self . trigger_event ( PostPluginRegistrationEvent ()) self . _request . execute ( event_dispatcher = self )","title":"execute()"},{"location":"api/seagulls-engine/seagulls/seagulls_cli/#register_container","text":"def register_container ( self , key : Type [ ~ ObjectType ], container : ~ ObjectType ) -> None : View Source def register_container ( self , key : Type [ ObjectType ], container : ObjectType ) -> None : self . _container_repository . register ( key , container )","title":"register_container()"},{"location":"api/seagulls-engine/seagulls/seagulls_cli/#get_container","text":"def get_container ( self , key : Type [ ~ ObjectType ]) -> ~ ObjectType : View Source def get_container ( self , key : Type [ ObjectType ]) -> ObjectType : return self . _container_repository . get ( key )","title":"get_container()"},{"location":"api/seagulls-engine/seagulls/seagulls_cli/#register_callback","text":"def register_callback ( self , event_type : Type [ ~ EventType ], callback : Callable [[ ~ EventType ], NoneType ] ) -> None : View Source def register_callback ( self , event_type : Type [ EventType ], callback : EventCallbackType ) -> None : if event_type not in self . _callbacks : self . _callbacks [ event_type ] = [] self . _callbacks [ event_type ] . append ( callback )","title":"register_callback()"},{"location":"api/seagulls-engine/seagulls/seagulls_cli/#trigger_event","text":"def trigger_event ( self , event : ~ EventType ) -> None : View Source def trigger_event ( self , event : EventType ) -> None : for callback in self . _callbacks . get ( type ( event ), []): callback ( event )","title":"trigger_event()"},{"location":"api/seagulls-engine/seagulls/seagulls_cli/#register_plugin","text":"def register_plugin ( self , plugin : seagulls . app . _plugin_interfaces . ISeagullsApplicationPlugin ) -> None : View Source def register_plugin ( self , plugin : ISeagullsApplicationPlugin ) -> None : if type ( plugin ) in self . _plugins : raise DuplicatePluginError ( plugin ) self . _plugins [ type ( plugin )] = plugin plugin . on_registration ()","title":"register_plugin()"},{"location":"api/seagulls-engine/seagulls/seagulls_cli/#get_plugin","text":"@lru_cache () def get_plugin ( self , plugin_type : Type [ ~ PluginType ]) -> ~ PluginType : View Source @lru_cache () def get_plugin ( self , plugin_type : Type [ PluginType ]) -> PluginType : # type: ignore return self . _plugins [ plugin_type ]","title":"get_plugin()"},{"location":"api/seagulls-engine/seagulls/seagulls_cli/#main","text":"def main (): View Source def main (): di_container = SeagullsAppDiContainer () app = di_container . application () app . execute ()","title":"main()"},{"location":"api/seagulls-space-shooter-demo/seagulls/","text":"seagulls \u00b6","title":"seagulls"},{"location":"api/seagulls-space-shooter-demo/seagulls/#seagulls","text":"","title":"seagulls"},{"location":"api/seagulls-space-shooter-demo/seagulls/app/","text":"seagulls .app \u00b6 View Source from ._app_interfaces import ISeagullsApplication from ._plugin_client import SeagullsEntryPointsPluginsClient from ._plugin_interfaces import ( ApplicationType , PluginType , ISeagullsApplicationPlugin , IPluggableSeagullsApplication , ISeagullsPluginClient , ISeagullsApplicationPluginRegistrant , ) from ._plugin_exceptions import DuplicatePluginError __all__ = [ # App \"ISeagullsApplication\" , # Plugin Client \"SeagullsEntryPointsPluginsClient\" , # App Plugins \"ApplicationType\" , \"PluginType\" , \"ISeagullsApplicationPlugin\" , \"IPluggableSeagullsApplication\" , \"ISeagullsPluginClient\" , \"ISeagullsApplicationPluginRegistrant\" , # Exceptions \"DuplicatePluginError\" , ] ISeagullsApplication \u00b6 class ISeagullsApplication ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class ISeagullsApplication ( Protocol ): @abstractmethod def execute ( self ) -> None : ... execute() \u00b6 @abstractmethod def execute ( self ) -> None : View Source @abstractmethod def execute ( self ) -> None : ... SeagullsEntryPointsPluginsClient \u00b6 class SeagullsEntryPointsPluginsClient ( seagulls . app . _plugin_interfaces . ISeagullsPluginClient ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class SeagullsEntryPointsPluginsClient ( ISeagullsPluginClient ): _entrypoint_name : str def __init__ ( self , entrypoint_name : str ): self . _entrypoint_name = entrypoint_name def register_plugins ( self , application : ApplicationType ) -> None : plugins = entry_points ( group = self . _entrypoint_name ) for plugin in plugins : plugin_ref : Type [ ISeagullsApplicationPluginRegistrant ] = plugin . load () if not issubclass ( plugin_ref , ISeagullsApplicationPluginRegistrant ): raise InvalidPluginError ( plugin ) plugin_ref . register_plugins ( application ) # type: ignore SeagullsEntryPointsPluginsClient() \u00b6 SeagullsEntryPointsPluginsClient ( entrypoint_name : str ): View Source def __init__ ( self , entrypoint_name : str ): self . _entrypoint_name = entrypoint_name register_plugins() \u00b6 def register_plugins ( self , application : - ApplicationType ) -> None : Find all plugins and let them register plugins to the running application. View Source def register_plugins ( self , application : ApplicationType ) -> None : plugins = entry_points ( group = self . _entrypoint_name ) for plugin in plugins : plugin_ref : Type [ ISeagullsApplicationPluginRegistrant ] = plugin . load () if not issubclass ( plugin_ref , ISeagullsApplicationPluginRegistrant ): raise InvalidPluginError ( plugin ) plugin_ref . register_plugins ( application ) # type: ignore ApplicationType \u00b6 ApplicationType = - ApplicationType PluginType \u00b6 PluginType = ~ PluginType ISeagullsApplicationPlugin \u00b6 class ISeagullsApplicationPlugin ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class ISeagullsApplicationPlugin ( Protocol ): @abstractmethod def on_registration ( self ) -> None : \"\"\" Called when the plugin is first registered with the application. \"\"\" on_registration() \u00b6 @abstractmethod def on_registration ( self ) -> None : Called when the plugin is first registered with the application. View Source @abstractmethod def on_registration ( self ) -> None : \"\"\" Called when the plugin is first registered with the application. \"\"\" IPluggableSeagullsApplication \u00b6 class IPluggableSeagullsApplication ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class IPluggableSeagullsApplication ( Protocol ): @abstractmethod def register_plugin ( self , plugin : ISeagullsApplicationPlugin ) -> None : ... @abstractmethod def get_plugin ( self , plugin : Type [ PluginType ]) -> PluginType : ... register_plugin() \u00b6 @abstractmethod def register_plugin ( self , plugin : seagulls . app . _plugin_interfaces . ISeagullsApplicationPlugin ) -> None : View Source @abstractmethod def register_plugin ( self , plugin : ISeagullsApplicationPlugin ) -> None : ... get_plugin() \u00b6 @abstractmethod def get_plugin ( self , plugin : Type [ ~ PluginType ]) -> ~ PluginType : View Source @abstractmethod def get_plugin ( self , plugin : Type [ PluginType ]) -> PluginType : ... ISeagullsPluginClient \u00b6 class ISeagullsPluginClient ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class ISeagullsPluginClient ( Protocol ): @abstractmethod def register_plugins ( self , application : ApplicationType ) -> None : \"\"\" Find all plugins and let them register plugins to the running application. \"\"\" register_plugins() \u00b6 @abstractmethod def register_plugins ( self , application : - ApplicationType ) -> None : Find all plugins and let them register plugins to the running application. View Source @abstractmethod def register_plugins ( self , application : ApplicationType ) -> None : \"\"\" Find all plugins and let them register plugins to the running application. \"\"\" ISeagullsApplicationPluginRegistrant \u00b6 @runtime_checkable class ISeagullsApplicationPluginRegistrant ( typing . Protocol [ - ApplicationType ]): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source @runtime_checkable class ISeagullsApplicationPluginRegistrant ( Protocol [ ApplicationType ]): @staticmethod @abstractmethod def register_plugins ( application : ApplicationType ) -> None : \"\"\" Called at the start of the process for plugin devs to register their plugins in the app. \"\"\" register_plugins() \u00b6 @staticmethod @abstractmethod def register_plugins ( application : - ApplicationType ) -> None : Called at the start of the process for plugin devs to register their plugins in the app. View Source @staticmethod @abstractmethod def register_plugins ( application : ApplicationType ) -> None : \"\"\" Called at the start of the process for plugin devs to register their plugins in the app. \"\"\" DuplicatePluginError \u00b6 class DuplicatePluginError ( builtins . RuntimeError ): Unspecified run-time error. View Source class DuplicatePluginError ( RuntimeError ): plugin : ISeagullsApplicationPlugin def __init__ ( self , plugin : ISeagullsApplicationPlugin ): super () . __init__ ( f \"Duplicate plugin registration detected: { type ( plugin ) } \" ) self . plugin = plugin DuplicatePluginError() \u00b6 DuplicatePluginError ( plugin : seagulls . app . _plugin_interfaces . ISeagullsApplicationPlugin ): View Source def __init__ ( self , plugin : ISeagullsApplicationPlugin ): super () . __init__ ( f \"Duplicate plugin registration detected: { type ( plugin ) } \" ) self . plugin = plugin Inherited Members \u00b6 taken from: builtins:BaseException with_traceback () args","title":"seagulls.app"},{"location":"api/seagulls-space-shooter-demo/seagulls/app/#seagullsapp","text":"View Source from ._app_interfaces import ISeagullsApplication from ._plugin_client import SeagullsEntryPointsPluginsClient from ._plugin_interfaces import ( ApplicationType , PluginType , ISeagullsApplicationPlugin , IPluggableSeagullsApplication , ISeagullsPluginClient , ISeagullsApplicationPluginRegistrant , ) from ._plugin_exceptions import DuplicatePluginError __all__ = [ # App \"ISeagullsApplication\" , # Plugin Client \"SeagullsEntryPointsPluginsClient\" , # App Plugins \"ApplicationType\" , \"PluginType\" , \"ISeagullsApplicationPlugin\" , \"IPluggableSeagullsApplication\" , \"ISeagullsPluginClient\" , \"ISeagullsApplicationPluginRegistrant\" , # Exceptions \"DuplicatePluginError\" , ]","title":"seagulls.app"},{"location":"api/seagulls-space-shooter-demo/seagulls/app/#iseagullsapplication","text":"class ISeagullsApplication ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class ISeagullsApplication ( Protocol ): @abstractmethod def execute ( self ) -> None : ...","title":"ISeagullsApplication"},{"location":"api/seagulls-space-shooter-demo/seagulls/app/#execute","text":"@abstractmethod def execute ( self ) -> None : View Source @abstractmethod def execute ( self ) -> None : ...","title":"execute()"},{"location":"api/seagulls-space-shooter-demo/seagulls/app/#seagullsentrypointspluginsclient","text":"class SeagullsEntryPointsPluginsClient ( seagulls . app . _plugin_interfaces . ISeagullsPluginClient ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class SeagullsEntryPointsPluginsClient ( ISeagullsPluginClient ): _entrypoint_name : str def __init__ ( self , entrypoint_name : str ): self . _entrypoint_name = entrypoint_name def register_plugins ( self , application : ApplicationType ) -> None : plugins = entry_points ( group = self . _entrypoint_name ) for plugin in plugins : plugin_ref : Type [ ISeagullsApplicationPluginRegistrant ] = plugin . load () if not issubclass ( plugin_ref , ISeagullsApplicationPluginRegistrant ): raise InvalidPluginError ( plugin ) plugin_ref . register_plugins ( application ) # type: ignore","title":"SeagullsEntryPointsPluginsClient"},{"location":"api/seagulls-space-shooter-demo/seagulls/app/#seagullsentrypointspluginsclient_1","text":"SeagullsEntryPointsPluginsClient ( entrypoint_name : str ): View Source def __init__ ( self , entrypoint_name : str ): self . _entrypoint_name = entrypoint_name","title":"SeagullsEntryPointsPluginsClient()"},{"location":"api/seagulls-space-shooter-demo/seagulls/app/#register_plugins","text":"def register_plugins ( self , application : - ApplicationType ) -> None : Find all plugins and let them register plugins to the running application. View Source def register_plugins ( self , application : ApplicationType ) -> None : plugins = entry_points ( group = self . _entrypoint_name ) for plugin in plugins : plugin_ref : Type [ ISeagullsApplicationPluginRegistrant ] = plugin . load () if not issubclass ( plugin_ref , ISeagullsApplicationPluginRegistrant ): raise InvalidPluginError ( plugin ) plugin_ref . register_plugins ( application ) # type: ignore","title":"register_plugins()"},{"location":"api/seagulls-space-shooter-demo/seagulls/app/#applicationtype","text":"ApplicationType = - ApplicationType","title":"ApplicationType"},{"location":"api/seagulls-space-shooter-demo/seagulls/app/#plugintype","text":"PluginType = ~ PluginType","title":"PluginType"},{"location":"api/seagulls-space-shooter-demo/seagulls/app/#iseagullsapplicationplugin","text":"class ISeagullsApplicationPlugin ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class ISeagullsApplicationPlugin ( Protocol ): @abstractmethod def on_registration ( self ) -> None : \"\"\" Called when the plugin is first registered with the application. \"\"\"","title":"ISeagullsApplicationPlugin"},{"location":"api/seagulls-space-shooter-demo/seagulls/app/#on_registration","text":"@abstractmethod def on_registration ( self ) -> None : Called when the plugin is first registered with the application. View Source @abstractmethod def on_registration ( self ) -> None : \"\"\" Called when the plugin is first registered with the application. \"\"\"","title":"on_registration()"},{"location":"api/seagulls-space-shooter-demo/seagulls/app/#ipluggableseagullsapplication","text":"class IPluggableSeagullsApplication ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class IPluggableSeagullsApplication ( Protocol ): @abstractmethod def register_plugin ( self , plugin : ISeagullsApplicationPlugin ) -> None : ... @abstractmethod def get_plugin ( self , plugin : Type [ PluginType ]) -> PluginType : ...","title":"IPluggableSeagullsApplication"},{"location":"api/seagulls-space-shooter-demo/seagulls/app/#register_plugin","text":"@abstractmethod def register_plugin ( self , plugin : seagulls . app . _plugin_interfaces . ISeagullsApplicationPlugin ) -> None : View Source @abstractmethod def register_plugin ( self , plugin : ISeagullsApplicationPlugin ) -> None : ...","title":"register_plugin()"},{"location":"api/seagulls-space-shooter-demo/seagulls/app/#get_plugin","text":"@abstractmethod def get_plugin ( self , plugin : Type [ ~ PluginType ]) -> ~ PluginType : View Source @abstractmethod def get_plugin ( self , plugin : Type [ PluginType ]) -> PluginType : ...","title":"get_plugin()"},{"location":"api/seagulls-space-shooter-demo/seagulls/app/#iseagullspluginclient","text":"class ISeagullsPluginClient ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class ISeagullsPluginClient ( Protocol ): @abstractmethod def register_plugins ( self , application : ApplicationType ) -> None : \"\"\" Find all plugins and let them register plugins to the running application. \"\"\"","title":"ISeagullsPluginClient"},{"location":"api/seagulls-space-shooter-demo/seagulls/app/#register_plugins_1","text":"@abstractmethod def register_plugins ( self , application : - ApplicationType ) -> None : Find all plugins and let them register plugins to the running application. View Source @abstractmethod def register_plugins ( self , application : ApplicationType ) -> None : \"\"\" Find all plugins and let them register plugins to the running application. \"\"\"","title":"register_plugins()"},{"location":"api/seagulls-space-shooter-demo/seagulls/app/#iseagullsapplicationpluginregistrant","text":"@runtime_checkable class ISeagullsApplicationPluginRegistrant ( typing . Protocol [ - ApplicationType ]): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source @runtime_checkable class ISeagullsApplicationPluginRegistrant ( Protocol [ ApplicationType ]): @staticmethod @abstractmethod def register_plugins ( application : ApplicationType ) -> None : \"\"\" Called at the start of the process for plugin devs to register their plugins in the app. \"\"\"","title":"ISeagullsApplicationPluginRegistrant"},{"location":"api/seagulls-space-shooter-demo/seagulls/app/#register_plugins_2","text":"@staticmethod @abstractmethod def register_plugins ( application : - ApplicationType ) -> None : Called at the start of the process for plugin devs to register their plugins in the app. View Source @staticmethod @abstractmethod def register_plugins ( application : ApplicationType ) -> None : \"\"\" Called at the start of the process for plugin devs to register their plugins in the app. \"\"\"","title":"register_plugins()"},{"location":"api/seagulls-space-shooter-demo/seagulls/app/#duplicatepluginerror","text":"class DuplicatePluginError ( builtins . RuntimeError ): Unspecified run-time error. View Source class DuplicatePluginError ( RuntimeError ): plugin : ISeagullsApplicationPlugin def __init__ ( self , plugin : ISeagullsApplicationPlugin ): super () . __init__ ( f \"Duplicate plugin registration detected: { type ( plugin ) } \" ) self . plugin = plugin","title":"DuplicatePluginError"},{"location":"api/seagulls-space-shooter-demo/seagulls/app/#duplicatepluginerror_1","text":"DuplicatePluginError ( plugin : seagulls . app . _plugin_interfaces . ISeagullsApplicationPlugin ): View Source def __init__ ( self , plugin : ISeagullsApplicationPlugin ): super () . __init__ ( f \"Duplicate plugin registration detected: { type ( plugin ) } \" ) self . plugin = plugin","title":"DuplicatePluginError()"},{"location":"api/seagulls-space-shooter-demo/seagulls/app/#inherited-members","text":"taken from: builtins:BaseException with_traceback () args","title":"Inherited Members"},{"location":"api/seagulls-space-shooter-demo/seagulls/assets/","text":"seagulls .assets \u00b6 View Source from ._manager import AssetManager __all__ = [ \"AssetManager\" ] AssetManager \u00b6 class AssetManager : Provides basic functionality for loading assets from disk. View Source class AssetManager : \"\"\"Provides basic functionality for loading assets from disk.\"\"\" _assets_path : Path def __init__ ( self , assets_path : Path ): self . _assets_path = assets_path def load_sprite ( self , name : str ) -> Surface : return self . load_png ( f \"sprites/ { name } \" ) def load_png ( self , name : str ) -> Surface : path = self . _assets_path / f \" { name } .png\" loaded_sprite = load ( path . resolve ()) if loaded_sprite . get_alpha () is None : return loaded_sprite . convert () else : return loaded_sprite . convert_alpha () AssetManager() \u00b6 AssetManager ( assets_path : pathlib . Path ): View Source def __init__ ( self , assets_path : Path ): self . _assets_path = assets_path load_sprite() \u00b6 def load_sprite ( self , name : str ) -> pygame . Surface : View Source def load_sprite ( self , name : str ) -> Surface : return self . load_png ( f \"sprites/ { name } \" ) load_png() \u00b6 def load_png ( self , name : str ) -> pygame . Surface : View Source def load_png ( self , name : str ) -> Surface : path = self . _assets_path / f \" { name } .png\" loaded_sprite = load ( path . resolve ()) if loaded_sprite . get_alpha () is None : return loaded_sprite . convert () else : return loaded_sprite . convert_alpha ()","title":"seagulls.assets"},{"location":"api/seagulls-space-shooter-demo/seagulls/assets/#seagullsassets","text":"View Source from ._manager import AssetManager __all__ = [ \"AssetManager\" ]","title":"seagulls.assets"},{"location":"api/seagulls-space-shooter-demo/seagulls/assets/#assetmanager","text":"class AssetManager : Provides basic functionality for loading assets from disk. View Source class AssetManager : \"\"\"Provides basic functionality for loading assets from disk.\"\"\" _assets_path : Path def __init__ ( self , assets_path : Path ): self . _assets_path = assets_path def load_sprite ( self , name : str ) -> Surface : return self . load_png ( f \"sprites/ { name } \" ) def load_png ( self , name : str ) -> Surface : path = self . _assets_path / f \" { name } .png\" loaded_sprite = load ( path . resolve ()) if loaded_sprite . get_alpha () is None : return loaded_sprite . convert () else : return loaded_sprite . convert_alpha ()","title":"AssetManager"},{"location":"api/seagulls-space-shooter-demo/seagulls/assets/#assetmanager_1","text":"AssetManager ( assets_path : pathlib . Path ): View Source def __init__ ( self , assets_path : Path ): self . _assets_path = assets_path","title":"AssetManager()"},{"location":"api/seagulls-space-shooter-demo/seagulls/assets/#load_sprite","text":"def load_sprite ( self , name : str ) -> pygame . Surface : View Source def load_sprite ( self , name : str ) -> Surface : return self . load_png ( f \"sprites/ { name } \" )","title":"load_sprite()"},{"location":"api/seagulls-space-shooter-demo/seagulls/assets/#load_png","text":"def load_png ( self , name : str ) -> pygame . Surface : View Source def load_png ( self , name : str ) -> Surface : path = self . _assets_path / f \" { name } .png\" loaded_sprite = load ( path . resolve ()) if loaded_sprite . get_alpha () is None : return loaded_sprite . convert () else : return loaded_sprite . convert_alpha ()","title":"load_png()"},{"location":"api/seagulls-space-shooter-demo/seagulls/cli/","text":"seagulls .cli \u00b6 View Source from ._request import ( CliRequest , ICliCommand , RequestEnvironment , CliRequestRegistrationEvent , ) __all__ = [ \"CliRequest\" , \"ICliCommand\" , \"RequestEnvironment\" , \"CliRequestRegistrationEvent\" , ] CliRequest \u00b6 class CliRequest : View Source class CliRequest : _file : Path _args : Tuple [ str , ... ] _env : RequestEnvironment def __init__ ( self , file : Path , args : Tuple [ str , ... ], env : RequestEnvironment ): self . _file = file self . _args = args self . _env = env def execute ( self , event_dispatcher : IDispatchEvents ) -> None : # Build the CLI Command Interface parser = ArgumentParser ( description = \"Seagulls CLI Command\" , ) event = CliRequestRegistrationEvent ( parser ) event_dispatcher . trigger_event ( event ) def default_execute () -> None : parser . print_help () parser . set_defaults ( cmd = default_execute ) args = parser . parse_args ( self . _args ) args . cmd () CliRequest() \u00b6 CliRequest ( file : pathlib . Path , args : Tuple [ str , ... ], env : seagulls . cli . _request . RequestEnvironment ): View Source def __init__ ( self , file : Path , args : Tuple [ str , ... ], env : RequestEnvironment ): self . _file = file self . _args = args self . _env = env execute() \u00b6 def execute ( self , event_dispatcher : seagulls . eventing . _interfaces . IDispatchEvents ) -> None : View Source def execute ( self , event_dispatcher : IDispatchEvents ) -> None : # Build the CLI Command Interface parser = ArgumentParser ( description = \"Seagulls CLI Command\" , ) event = CliRequestRegistrationEvent ( parser ) event_dispatcher . trigger_event ( event ) def default_execute () -> None : parser . print_help () parser . set_defaults ( cmd = default_execute ) args = parser . parse_args ( self . _args ) args . cmd () ICliCommand \u00b6 class ICliCommand ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class ICliCommand ( Protocol ): @abstractmethod def configure_parser ( self , parser : ArgumentParser ) -> None : ... @abstractmethod def execute ( self ) -> None : ... configure_parser() \u00b6 @abstractmethod def configure_parser ( self , parser : argparse . ArgumentParser ) -> None : View Source @abstractmethod def configure_parser ( self , parser : ArgumentParser ) -> None : ... execute() \u00b6 @abstractmethod def execute ( self ) -> None : View Source @abstractmethod def execute ( self ) -> None : ... RequestEnvironment \u00b6 class RequestEnvironment : View Source class RequestEnvironment : _values : Dict [ str , str ] def __init__ ( self , values : Tuple [ EnvironmentTuple , ... ]): self . _values = { k : v for k , v in values } def get ( self , name : str , default : str = None ) -> Optional [ str ]: return self . _values . get ( name , default ) def as_dict ( self ) -> Dict [ str , str ]: return self . _values . copy () RequestEnvironment() \u00b6 RequestEnvironment ( values : Tuple [ Tuple [ str , str ], ... ]): View Source def __init__ ( self , values : Tuple [ EnvironmentTuple , ... ]): self . _values = { k : v for k , v in values } get() \u00b6 def get ( self , name : str , default : str = None ) -> Optional [ str ]: View Source def get ( self , name : str , default : str = None ) -> Optional [ str ]: return self . _values . get ( name , default ) as_dict() \u00b6 def as_dict ( self ) -> Dict [ str , str ]: View Source def as_dict ( self ) -> Dict [ str , str ]: return self . _values . copy () CliRequestRegistrationEvent \u00b6 class CliRequestRegistrationEvent : View Source class CliRequestRegistrationEvent : _parser : ArgumentParser def __init__ ( self , parser : ArgumentParser ): self . _parser = parser def register_command ( self , name : str , command : ICliCommand ) -> None : def callback () -> None : command . execute () subparser = self . _get_subparsers () . add_parser ( name = name ) command . configure_parser ( subparser ) subparser . set_defaults ( cmd = callback ) @lru_cache () def _get_subparsers ( self ): return self . _parser . add_subparsers ( title = \"subcommands\" , metavar = None , help = \"\" ) CliRequestRegistrationEvent() \u00b6 CliRequestRegistrationEvent ( parser : argparse . ArgumentParser ): View Source def __init__ ( self , parser : ArgumentParser ): self . _parser = parser register_command() \u00b6 def register_command ( self , name : str , command : seagulls . cli . _request . ICliCommand ) -> None : View Source def register_command ( self , name : str , command : ICliCommand ) -> None : def callback () -> None : command . execute () subparser = self . _get_subparsers () . add_parser ( name = name ) command . configure_parser ( subparser ) subparser . set_defaults ( cmd = callback )","title":"seagulls.cli"},{"location":"api/seagulls-space-shooter-demo/seagulls/cli/#seagullscli","text":"View Source from ._request import ( CliRequest , ICliCommand , RequestEnvironment , CliRequestRegistrationEvent , ) __all__ = [ \"CliRequest\" , \"ICliCommand\" , \"RequestEnvironment\" , \"CliRequestRegistrationEvent\" , ]","title":"seagulls.cli"},{"location":"api/seagulls-space-shooter-demo/seagulls/cli/#clirequest","text":"class CliRequest : View Source class CliRequest : _file : Path _args : Tuple [ str , ... ] _env : RequestEnvironment def __init__ ( self , file : Path , args : Tuple [ str , ... ], env : RequestEnvironment ): self . _file = file self . _args = args self . _env = env def execute ( self , event_dispatcher : IDispatchEvents ) -> None : # Build the CLI Command Interface parser = ArgumentParser ( description = \"Seagulls CLI Command\" , ) event = CliRequestRegistrationEvent ( parser ) event_dispatcher . trigger_event ( event ) def default_execute () -> None : parser . print_help () parser . set_defaults ( cmd = default_execute ) args = parser . parse_args ( self . _args ) args . cmd ()","title":"CliRequest"},{"location":"api/seagulls-space-shooter-demo/seagulls/cli/#clirequest_1","text":"CliRequest ( file : pathlib . Path , args : Tuple [ str , ... ], env : seagulls . cli . _request . RequestEnvironment ): View Source def __init__ ( self , file : Path , args : Tuple [ str , ... ], env : RequestEnvironment ): self . _file = file self . _args = args self . _env = env","title":"CliRequest()"},{"location":"api/seagulls-space-shooter-demo/seagulls/cli/#execute","text":"def execute ( self , event_dispatcher : seagulls . eventing . _interfaces . IDispatchEvents ) -> None : View Source def execute ( self , event_dispatcher : IDispatchEvents ) -> None : # Build the CLI Command Interface parser = ArgumentParser ( description = \"Seagulls CLI Command\" , ) event = CliRequestRegistrationEvent ( parser ) event_dispatcher . trigger_event ( event ) def default_execute () -> None : parser . print_help () parser . set_defaults ( cmd = default_execute ) args = parser . parse_args ( self . _args ) args . cmd ()","title":"execute()"},{"location":"api/seagulls-space-shooter-demo/seagulls/cli/#iclicommand","text":"class ICliCommand ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class ICliCommand ( Protocol ): @abstractmethod def configure_parser ( self , parser : ArgumentParser ) -> None : ... @abstractmethod def execute ( self ) -> None : ...","title":"ICliCommand"},{"location":"api/seagulls-space-shooter-demo/seagulls/cli/#configure_parser","text":"@abstractmethod def configure_parser ( self , parser : argparse . ArgumentParser ) -> None : View Source @abstractmethod def configure_parser ( self , parser : ArgumentParser ) -> None : ...","title":"configure_parser()"},{"location":"api/seagulls-space-shooter-demo/seagulls/cli/#execute_1","text":"@abstractmethod def execute ( self ) -> None : View Source @abstractmethod def execute ( self ) -> None : ...","title":"execute()"},{"location":"api/seagulls-space-shooter-demo/seagulls/cli/#requestenvironment","text":"class RequestEnvironment : View Source class RequestEnvironment : _values : Dict [ str , str ] def __init__ ( self , values : Tuple [ EnvironmentTuple , ... ]): self . _values = { k : v for k , v in values } def get ( self , name : str , default : str = None ) -> Optional [ str ]: return self . _values . get ( name , default ) def as_dict ( self ) -> Dict [ str , str ]: return self . _values . copy ()","title":"RequestEnvironment"},{"location":"api/seagulls-space-shooter-demo/seagulls/cli/#requestenvironment_1","text":"RequestEnvironment ( values : Tuple [ Tuple [ str , str ], ... ]): View Source def __init__ ( self , values : Tuple [ EnvironmentTuple , ... ]): self . _values = { k : v for k , v in values }","title":"RequestEnvironment()"},{"location":"api/seagulls-space-shooter-demo/seagulls/cli/#get","text":"def get ( self , name : str , default : str = None ) -> Optional [ str ]: View Source def get ( self , name : str , default : str = None ) -> Optional [ str ]: return self . _values . get ( name , default )","title":"get()"},{"location":"api/seagulls-space-shooter-demo/seagulls/cli/#as_dict","text":"def as_dict ( self ) -> Dict [ str , str ]: View Source def as_dict ( self ) -> Dict [ str , str ]: return self . _values . copy ()","title":"as_dict()"},{"location":"api/seagulls-space-shooter-demo/seagulls/cli/#clirequestregistrationevent","text":"class CliRequestRegistrationEvent : View Source class CliRequestRegistrationEvent : _parser : ArgumentParser def __init__ ( self , parser : ArgumentParser ): self . _parser = parser def register_command ( self , name : str , command : ICliCommand ) -> None : def callback () -> None : command . execute () subparser = self . _get_subparsers () . add_parser ( name = name ) command . configure_parser ( subparser ) subparser . set_defaults ( cmd = callback ) @lru_cache () def _get_subparsers ( self ): return self . _parser . add_subparsers ( title = \"subcommands\" , metavar = None , help = \"\" )","title":"CliRequestRegistrationEvent"},{"location":"api/seagulls-space-shooter-demo/seagulls/cli/#clirequestregistrationevent_1","text":"CliRequestRegistrationEvent ( parser : argparse . ArgumentParser ): View Source def __init__ ( self , parser : ArgumentParser ): self . _parser = parser","title":"CliRequestRegistrationEvent()"},{"location":"api/seagulls-space-shooter-demo/seagulls/cli/#register_command","text":"def register_command ( self , name : str , command : seagulls . cli . _request . ICliCommand ) -> None : View Source def register_command ( self , name : str , command : ICliCommand ) -> None : def callback () -> None : command . execute () subparser = self . _get_subparsers () . add_parser ( name = name ) command . configure_parser ( subparser ) subparser . set_defaults ( cmd = callback )","title":"register_command()"},{"location":"api/seagulls-space-shooter-demo/seagulls/devtools/","text":"seagulls .devtools \u00b6 View Source from ._cli_entry_point import DevtoolsCliPluginEntryPoint __all__ = [ \"DevtoolsCliPluginEntryPoint\" , ] DevtoolsCliPluginEntryPoint \u00b6 class DevtoolsCliPluginEntryPoint ( seagulls . app . _plugin_interfaces . ISeagullsApplicationPluginRegistrant [ seagulls . seagulls_cli . _application . SeagullsCliApplication ]): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class DevtoolsCliPluginEntryPoint ( ISeagullsApplicationPluginRegistrant [ SeagullsCliApplication ]): @staticmethod def register_plugins ( application : SeagullsCliApplication ) -> None : di_container = SeagullsDevtoolsDiContainer ( application = application ) application . register_plugin ( di_container . plugin ()) register_plugins() \u00b6 @staticmethod def register_plugins ( application : seagulls . seagulls_cli . _application . SeagullsCliApplication ) -> None : Called at the start of the process for plugin devs to register their plugins in the app. View Source @staticmethod def register_plugins ( application : SeagullsCliApplication ) -> None : di_container = SeagullsDevtoolsDiContainer ( application = application ) application . register_plugin ( di_container . plugin ()) Inherited Members \u00b6 taken from: seagulls.app._plugin_interfaces:ISeagullsApplicationPluginRegistrant ISeagullsApplicationPluginRegistrant ( * args , ** kwargs )","title":"seagulls.devtools"},{"location":"api/seagulls-space-shooter-demo/seagulls/devtools/#seagullsdevtools","text":"View Source from ._cli_entry_point import DevtoolsCliPluginEntryPoint __all__ = [ \"DevtoolsCliPluginEntryPoint\" , ]","title":"seagulls.devtools"},{"location":"api/seagulls-space-shooter-demo/seagulls/devtools/#devtoolsclipluginentrypoint","text":"class DevtoolsCliPluginEntryPoint ( seagulls . app . _plugin_interfaces . ISeagullsApplicationPluginRegistrant [ seagulls . seagulls_cli . _application . SeagullsCliApplication ]): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class DevtoolsCliPluginEntryPoint ( ISeagullsApplicationPluginRegistrant [ SeagullsCliApplication ]): @staticmethod def register_plugins ( application : SeagullsCliApplication ) -> None : di_container = SeagullsDevtoolsDiContainer ( application = application ) application . register_plugin ( di_container . plugin ())","title":"DevtoolsCliPluginEntryPoint"},{"location":"api/seagulls-space-shooter-demo/seagulls/devtools/#register_plugins","text":"@staticmethod def register_plugins ( application : seagulls . seagulls_cli . _application . SeagullsCliApplication ) -> None : Called at the start of the process for plugin devs to register their plugins in the app. View Source @staticmethod def register_plugins ( application : SeagullsCliApplication ) -> None : di_container = SeagullsDevtoolsDiContainer ( application = application ) application . register_plugin ( di_container . plugin ())","title":"register_plugins()"},{"location":"api/seagulls-space-shooter-demo/seagulls/devtools/#inherited-members","text":"taken from: seagulls.app._plugin_interfaces:ISeagullsApplicationPluginRegistrant ISeagullsApplicationPluginRegistrant ( * args , ** kwargs )","title":"Inherited Members"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/","text":"seagulls .engine \u00b6 Core Engine Components View Source \"\"\"Core Engine Components\"\"\" from ._collisions import CollidableObject , flag_from_string from ._game_clock import GameClock from ._game_controls import GameControls from ._game_object import GameObject , GameObjectsCollection from ._game_scene import IGameScene from ._game_scene_manager import IProvideGameScenes from ._game_session import IGameSession from ._game_session_manager import IProvideGameSessions from ._game_settings import GameSettings from ._pygame import Color , PixelArray , Rect , Surface , Vector2 , Vector3 from ._surface_renderer import SurfaceRenderer __all__ = [ \"flag_from_string\" , \"CollidableObject\" , \"IGameScene\" , \"IProvideGameScenes\" , \"IProvideGameSessions\" , \"IGameSession\" , \"SurfaceRenderer\" , \"GameClock\" , \"GameControls\" , \"GameObject\" , \"GameObjectsCollection\" , \"GameSettings\" , \"Rect\" , \"Surface\" , \"Color\" , \"PixelArray\" , \"Vector2\" , \"Vector3\" , ] flag_from_string() \u00b6 def flag_from_string ( value : str ) -> int : View Source def flag_from_string ( value : str ) -> int : if not isinstance ( value , str ): raise ValueError ( f \"Value must be a string of 0s and 1s: { value } \" ) return int ( value , 2 ) CollidableObject \u00b6 @dataclass ( frozen = True ) class CollidableObject : CollidableObject(layer: int, mask: int) View Source @dataclass ( frozen = True ) class CollidableObject : layer : int mask : int def filter_by_mask ( self , targets : Tuple [ \"CollidableObject\" , ... ]) -> Tuple [ \"CollidableObject\" , ... ]: result = [] for t in targets : if self . is_in_mask ( t ): result . append ( t ) return tuple ( result ) def is_in_mask ( self , target : \"CollidableObject\" ) -> bool : logger . debug ( f \"targeting items located in mask: { self . mask : b } \" ) logger . debug ( f \"target is located in layer: { target . layer : b } \" ) logger . debug ( f \"& result: { self . mask & target . layer : b } \" ) return self . mask & target . layer > 0 def __repr__ ( self ) -> str : return f \" { self . __class__ . __name__ } (layer= { self . layer : b } , mask= { self . mask : b } )\" CollidableObject() \u00b6 CollidableObject ( layer : int , mask : int ): filter_by_mask() \u00b6 def filter_by_mask ( self , targets : Tuple [ seagulls . engine . _collisions . CollidableObject , ... ] ) -> Tuple [ seagulls . engine . _collisions . CollidableObject , ... ]: View Source def filter_by_mask ( self , targets : Tuple [ \"CollidableObject\" , ... ]) -> Tuple [ \"CollidableObject\" , ... ]: result = [] for t in targets : if self . is_in_mask ( t ): result . append ( t ) return tuple ( result ) is_in_mask() \u00b6 def is_in_mask ( self , target : seagulls . engine . _collisions . CollidableObject ) -> bool : View Source def is_in_mask ( self , target : \"CollidableObject\" ) -> bool : logger . debug ( f \"targeting items located in mask: { self . mask : b } \" ) logger . debug ( f \"target is located in layer: { target . layer : b } \" ) logger . debug ( f \"& result: { self . mask & target . layer : b } \" ) return self . mask & target . layer > 0 IGameScene \u00b6 class IGameScene ( abc . ABC ): This class is for X and Y. View Source class IGameScene ( ABC ): \"\"\" This class is for X and Y. \"\"\" @abstractmethod def start ( self ) -> None : pass @abstractmethod def should_quit ( self ) -> bool : pass @abstractmethod def tick ( self ) -> None : pass start() \u00b6 @abstractmethod def start ( self ) -> None : View Source @abstractmethod def start ( self ) -> None : pass should_quit() \u00b6 @abstractmethod def should_quit ( self ) -> bool : View Source @abstractmethod def should_quit ( self ) -> bool : pass tick() \u00b6 @abstractmethod def tick ( self ) -> None : View Source @abstractmethod def tick ( self ) -> None : pass IProvideGameScenes \u00b6 class IProvideGameScenes ( abc . ABC ): Helper class that provides a standard way to create an ABC using inheritance. View Source class IProvideGameScenes ( ABC ): @abstractmethod def get_scene ( self ) -> IGameScene : pass get_scene() \u00b6 @abstractmethod def get_scene ( self ) -> seagulls . engine . _game_scene . IGameScene : View Source @abstractmethod def get_scene ( self ) -> IGameScene : pass IProvideGameSessions \u00b6 class IProvideGameSessions ( abc . ABC ): Helper class that provides a standard way to create an ABC using inheritance. View Source class IProvideGameSessions ( ABC ): @abstractmethod def get_session ( self , scene : str ) -> IGameSession : pass get_session() \u00b6 @abstractmethod def get_session ( self , scene : str ) -> seagulls . engine . _game_session . IGameSession : View Source @abstractmethod def get_session ( self , scene : str ) -> IGameSession : pass IGameSession \u00b6 class IGameSession ( abc . ABC ): Helper class that provides a standard way to create an ABC using inheritance. View Source class IGameSession ( ABC ): @abstractmethod def start ( self ) -> None : pass @abstractmethod def wait_for_completion ( self ) -> None : pass @abstractmethod def stop ( self ) -> None : pass start() \u00b6 @abstractmethod def start ( self ) -> None : View Source @abstractmethod def start ( self ) -> None : pass wait_for_completion() \u00b6 @abstractmethod def wait_for_completion ( self ) -> None : View Source @abstractmethod def wait_for_completion ( self ) -> None : pass stop() \u00b6 @abstractmethod def stop ( self ) -> None : View Source @abstractmethod def stop ( self ) -> None : pass SurfaceRenderer \u00b6 class SurfaceRenderer : View Source class SurfaceRenderer : def start ( self ) -> None : self . _get_surface () def render ( self , surface : Surface ) -> None : self . _get_surface () . blit ( surface , ( 0 , 0 )) pygame . display . flip () @lru_cache () def _get_surface ( self ) -> Surface : return pygame . display . set_mode (( 1024 , 600 )) SurfaceRenderer() \u00b6 SurfaceRenderer (): start() \u00b6 def start ( self ) -> None : View Source def start ( self ) -> None : self . _get_surface () render() \u00b6 def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : Surface ) -> None : self . _get_surface () . blit ( surface , ( 0 , 0 )) pygame . display . flip () GameClock \u00b6 class GameClock ( seagulls . engine . _game_object . GameObject ): Interface for anything representing an object in the scene. View Source class GameClock ( GameObject ): _clock : Clock _ticks : int _delta : int def __init__ ( self ): self . _clock = Clock () self . _ticks = 0 self . _delta = 0 def tick ( self ) -> None : self . _delta = self . _clock . tick () def render ( self , surface : Surface ) -> None : pass def get_time ( self ) -> int : return self . _delta def get_fps ( self ) -> float : return self . _clock . get_fps () GameClock() \u00b6 GameClock (): View Source def __init__ ( self ): self . _clock = Clock () self . _ticks = 0 self . _delta = 0 tick() \u00b6 def tick ( self ) -> None : View Source def tick ( self ) -> None : self . _delta = self . _clock . tick () render() \u00b6 def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : Surface ) -> None : pass get_time() \u00b6 def get_time ( self ) -> int : View Source def get_time ( self ) -> int : return self . _delta get_fps() \u00b6 def get_fps ( self ) -> float : View Source def get_fps ( self ) -> float : return self . _clock . get_fps () GameControls \u00b6 class GameControls ( seagulls . engine . _game_object . GameObject ): Interface for anything representing an object in the scene. View Source class GameControls ( GameObject ): _events : List [ Event ] def __init__ ( self ): self . _events = [] def tick ( self ): self . _events = pygame . event . get () def should_quit ( self ) -> bool : for event in self . _events : if event . type == pygame . QUIT : return True if self . _is_key_down_event ( event , pygame . K_ESCAPE ): return True return False def should_fire ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_SPACE ): return True return False def is_left_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_LEFT ] def is_right_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_RIGHT ] def is_up_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_UP ] def is_down_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_DOWN ] def should_toggle_debug_hud ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_BACKQUOTE ): return True return False def is_click_initialized ( self ) -> bool : for event in self . _events : if not event . type == pygame . MOUSEBUTTONDOWN : continue return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] return False def is_mouse_down ( self ) -> bool : return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] def _is_key_down_event ( self , event : Event , key : int ) -> bool : return event . type == pygame . KEYDOWN and event . key == key def _is_key_up_event ( self , event : Event , key : int ) -> bool : return event . type == pygame . KEYUP and event . key == key def render ( self , surface : Surface ) -> None : pass GameControls() \u00b6 GameControls (): View Source def __init__ ( self ): self . _events = [] tick() \u00b6 def tick ( self ): View Source def tick ( self ): self . _events = pygame . event . get () should_quit() \u00b6 def should_quit ( self ) -> bool : View Source def should_quit ( self ) -> bool : for event in self . _events : if event . type == pygame . QUIT : return True if self . _is_key_down_event ( event , pygame . K_ESCAPE ): return True return False should_fire() \u00b6 def should_fire ( self ) -> bool : View Source def should_fire ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_SPACE ): return True return False is_left_moving() \u00b6 def is_left_moving ( self ) -> bool : View Source def is_left_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_LEFT ] is_right_moving() \u00b6 def is_right_moving ( self ) -> bool : View Source def is_right_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_RIGHT ] is_up_moving() \u00b6 def is_up_moving ( self ) -> bool : View Source def is_up_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_UP ] is_down_moving() \u00b6 def is_down_moving ( self ) -> bool : View Source def is_down_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_DOWN ] should_toggle_debug_hud() \u00b6 def should_toggle_debug_hud ( self ) -> bool : View Source def should_toggle_debug_hud ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_BACKQUOTE ): return True return False is_click_initialized() \u00b6 def is_click_initialized ( self ) -> bool : View Source def is_click_initialized ( self ) -> bool : for event in self . _events : if not event . type == pygame . MOUSEBUTTONDOWN : continue return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] return False is_mouse_down() \u00b6 def is_mouse_down ( self ) -> bool : View Source def is_mouse_down ( self ) -> bool : return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] render() \u00b6 def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : Surface ) -> None : pass GameObject \u00b6 class GameObject ( abc . ABC ): Interface for anything representing an object in the scene. View Source class GameObject ( ABC ): \"\"\" Interface for anything representing an object in the scene. \"\"\" @abstractmethod def tick ( self ) -> None : pass @abstractmethod def render ( self , surface : Surface ) -> None : pass tick() \u00b6 @abstractmethod def tick ( self ) -> None : View Source @abstractmethod def tick ( self ) -> None : pass render() \u00b6 @abstractmethod def render ( self , surface : pygame . Surface ) -> None : View Source @abstractmethod def render ( self , surface : Surface ) -> None : pass GameObjectsCollection \u00b6 class GameObjectsCollection : Data structure that allows you to keep track of objects in the scene. View Source class GameObjectsCollection : \"\"\" Data structure that allows you to keep track of objects in the scene. \"\"\" _game_objects : List [ GameObject ] def __init__ ( self ) -> None : self . _game_objects = [] def add ( self , game_object : GameObject ) -> None : self . _game_objects . append ( game_object ) def apply ( self , func : Callable [[ GameObject ], None ]) -> None : for game_object in self . _game_objects : func ( game_object ) GameObjectsCollection() \u00b6 GameObjectsCollection (): View Source def __init__ ( self ) -> None : self . _game_objects = [] add() \u00b6 def add ( self , game_object : seagulls . engine . _game_object . GameObject ) -> None : View Source def add ( self , game_object : GameObject ) -> None : self . _game_objects . append ( game_object ) apply() \u00b6 def apply ( self , func : Callable [[ seagulls . engine . _game_object . GameObject ], NoneType ] ) -> None : View Source def apply ( self , func : Callable [[ GameObject ], None ]) -> None : for game_object in self . _game_objects : func ( game_object ) GameSettings \u00b6 class GameSettings : View Source class GameSettings : def get_setting ( self , name , default = None ) -> Any : data = self . _load_yaml () return data . get ( name , default ) @lru_cache () def _load_yaml ( self ) -> Dict [ str , Any ]: file = Path . home () / \".config/seagulls.yaml\" if not file . exists (): file . touch () return yaml . safe_load ( file . read_text ()) or {} GameSettings() \u00b6 GameSettings (): get_setting() \u00b6 def get_setting ( self , name , default = None ) -> Any : View Source def get_setting ( self , name , default = None ) -> Any : data = self . _load_yaml () return data . get ( name , default ) Rect \u00b6 class Rect : Rect(left, top, width, height) -> Rect Rect((left, top), (width, height)) -> Rect Rect(object) -> Rect pygame object for storing rectangular coordinates Rect() \u00b6 Rect ( * args , ** kwargs ): normalize() \u00b6 def normalize ( unknown ): normalize() -> None correct negative sizes clip() \u00b6 def clip ( unknown ): clip(Rect) -> Rect crops a rectangle inside another clipline() \u00b6 def clipline ( unknown ): clipline(x1, y1, x2, y2) -> ((cx1, cy1), (cx2, cy2)) clipline(x1, y1, x2, y2) -> () clipline((x1, y1), (x2, y2)) -> ((cx1, cy1), (cx2, cy2)) clipline((x1, y1), (x2, y2)) -> () clipline((x1, y1, x2, y2)) -> ((cx1, cy1), (cx2, cy2)) clipline((x1, y1, x2, y2)) -> () clipline(((x1, y1), (x2, y2))) -> ((cx1, cy1), (cx2, cy2)) clipline(((x1, y1), (x2, y2))) -> () crops a line inside a rectangle clamp() \u00b6 def clamp ( unknown ): clamp(Rect) -> Rect moves the rectangle inside another clamp_ip() \u00b6 def clamp_ip ( unknown ): clamp_ip(Rect) -> None moves the rectangle inside another, in place copy() \u00b6 def copy ( unknown ): copy() -> Rect copy the rectangle fit() \u00b6 def fit ( unknown ): fit(Rect) -> Rect resize and move a rectangle with aspect ratio move() \u00b6 def move ( unknown ): move(x, y) -> Rect moves the rectangle update() \u00b6 def update ( unknown ): update(left, top, width, height) -> None update((left, top), (width, height)) -> None update(object) -> None sets the position and size of the rectangle inflate() \u00b6 def inflate ( unknown ): inflate(x, y) -> Rect grow or shrink the rectangle size union() \u00b6 def union ( unknown ): union(Rect) -> Rect joins two rectangles into one unionall() \u00b6 def unionall ( unknown ): unionall(Rect_sequence) -> Rect the union of many rectangles move_ip() \u00b6 def move_ip ( unknown ): move_ip(x, y) -> None moves the rectangle, in place inflate_ip() \u00b6 def inflate_ip ( unknown ): inflate_ip(x, y) -> None grow or shrink the rectangle size, in place union_ip() \u00b6 def union_ip ( unknown ): union_ip(Rect) -> None joins two rectangles into one, in place unionall_ip() \u00b6 def unionall_ip ( unknown ): unionall_ip(Rect_sequence) -> None the union of many rectangles, in place collidepoint() \u00b6 def collidepoint ( unknown ): collidepoint(x, y) -> bool collidepoint((x,y)) -> bool test if a point is inside a rectangle colliderect() \u00b6 def colliderect ( unknown ): colliderect(Rect) -> bool test if two rectangles overlap collidelist() \u00b6 def collidelist ( unknown ): collidelist(list) -> index test if one rectangle in a list intersects collidelistall() \u00b6 def collidelistall ( unknown ): collidelistall(list) -> indices test if all rectangles in a list intersect collidedict() \u00b6 def collidedict ( unknown ): collidedict(dict) -> (key, value) collidedict(dict) -> None collidedict(dict, use_values=0) -> (key, value) collidedict(dict, use_values=0) -> None test if one rectangle in a dictionary intersects collidedictall() \u00b6 def collidedictall ( unknown ): collidedictall(dict) -> [(key, value), ...] collidedictall(dict, use_values=0) -> [(key, value), ...] test if all rectangles in a dictionary intersect contains() \u00b6 def contains ( unknown ): contains(Rect) -> bool test if one rectangle is inside another x \u00b6 x y \u00b6 y w \u00b6 w h \u00b6 h width \u00b6 width height \u00b6 height top \u00b6 top left \u00b6 left bottom \u00b6 bottom right \u00b6 right centerx \u00b6 centerx centery \u00b6 centery topleft \u00b6 topleft topright \u00b6 topright bottomleft \u00b6 bottomleft bottomright \u00b6 bottomright midtop \u00b6 midtop midleft \u00b6 midleft midbottom \u00b6 midbottom midright \u00b6 midright size \u00b6 size center \u00b6 center Surface \u00b6 class Surface : Surface((width, height), flags=0, depth=0, masks=None) -> Surface Surface((width, height), flags=0, Surface) -> Surface pygame object for representing images Surface() \u00b6 Surface ( * args , ** kwargs ): get_at() \u00b6 def get_at ( unknown ): get_at((x, y)) -> Color get the color value at a single pixel set_at() \u00b6 def set_at ( unknown ): set_at((x, y), Color) -> None set the color value for a single pixel get_at_mapped() \u00b6 def get_at_mapped ( unknown ): get_at_mapped((x, y)) -> Color get the mapped color value at a single pixel map_rgb() \u00b6 def map_rgb ( unknown ): map_rgb(Color) -> mapped_int convert a color into a mapped color value unmap_rgb() \u00b6 def unmap_rgb ( unknown ): unmap_rgb(mapped_int) -> Color convert a mapped integer color value into a Color get_palette() \u00b6 def get_palette ( unknown ): get_palette() -> [RGB, RGB, RGB, ...] get the color index palette for an 8-bit Surface get_palette_at() \u00b6 def get_palette_at ( unknown ): get_palette_at(index) -> RGB get the color for a single entry in a palette set_palette() \u00b6 def set_palette ( unknown ): set_palette([RGB, RGB, RGB, ...]) -> None set the color palette for an 8-bit Surface set_palette_at() \u00b6 def set_palette_at ( unknown ): set_palette_at(index, RGB) -> None set the color for a single index in an 8-bit Surface palette lock() \u00b6 def lock ( unknown ): lock() -> None lock the Surface memory for pixel access unlock() \u00b6 def unlock ( unknown ): unlock() -> None unlock the Surface memory from pixel access mustlock() \u00b6 def mustlock ( unknown ): mustlock() -> bool test if the Surface requires locking get_locked() \u00b6 def get_locked ( unknown ): get_locked() -> bool test if the Surface is current locked get_locks() \u00b6 def get_locks ( unknown ): get_locks() -> tuple Gets the locks for the Surface set_colorkey() \u00b6 def set_colorkey ( unknown ): set_colorkey(Color, flags=0) -> None set_colorkey(None) -> None Set the transparent colorkey get_colorkey() \u00b6 def get_colorkey ( unknown ): get_colorkey() -> RGB or None Get the current transparent colorkey set_alpha() \u00b6 def set_alpha ( unknown ): set_alpha(value, flags=0) -> None set_alpha(None) -> None set the alpha value for the full Surface image get_alpha() \u00b6 def get_alpha ( unknown ): get_alpha() -> int_value get the current Surface transparency value get_blendmode() \u00b6 def get_blendmode ( unknown ): Return the surface's SDL 2 blend mode copy() \u00b6 def copy ( unknown ): copy() -> Surface create a new copy of a Surface convert() \u00b6 def convert ( unknown ): convert(Surface=None) -> Surface convert(depth, flags=0) -> Surface convert(masks, flags=0) -> Surface change the pixel format of an image convert_alpha() \u00b6 def convert_alpha ( unknown ): convert_alpha(Surface) -> Surface convert_alpha() -> Surface change the pixel format of an image including per pixel alphas set_clip() \u00b6 def set_clip ( unknown ): set_clip(rect) -> None set_clip(None) -> None set the current clipping area of the Surface get_clip() \u00b6 def get_clip ( unknown ): get_clip() -> Rect get the current clipping area of the Surface fill() \u00b6 def fill ( unknown ): fill(color, rect=None, special_flags=0) -> Rect fill Surface with a solid color blit() \u00b6 def blit ( unknown ): blit(source, dest, area=None, special_flags=0) -> Rect draw one image onto another blits() \u00b6 def blits ( unknown ): blits(blit_sequence=((source, dest), ...), doreturn=1) -> [Rect, ...] or None blits(((source, dest, area), ...)) -> [Rect, ...] blits(((source, dest, area, special_flags), ...)) -> [Rect, ...] draw many images onto another scroll() \u00b6 def scroll ( unknown ): scroll(dx=0, dy=0) -> None Shift the surface image in place get_flags() \u00b6 def get_flags ( unknown ): get_flags() -> int get the additional flags used for the Surface get_size() \u00b6 def get_size ( unknown ): get_size() -> (width, height) get the dimensions of the Surface get_width() \u00b6 def get_width ( unknown ): get_width() -> width get the width of the Surface get_height() \u00b6 def get_height ( unknown ): get_height() -> height get the height of the Surface get_rect() \u00b6 def get_rect ( unknown ): get_rect(**kwargs) -> Rect get the rectangular area of the Surface get_pitch() \u00b6 def get_pitch ( unknown ): get_pitch() -> int get the number of bytes used per Surface row get_bitsize() \u00b6 def get_bitsize ( unknown ): get_bitsize() -> int get the bit depth of the Surface pixel format get_bytesize() \u00b6 def get_bytesize ( unknown ): get_bytesize() -> int get the bytes used per Surface pixel get_masks() \u00b6 def get_masks ( unknown ): get_masks() -> (R, G, B, A) the bitmasks needed to convert between a color and a mapped integer get_shifts() \u00b6 def get_shifts ( unknown ): get_shifts() -> (R, G, B, A) the bit shifts needed to convert between a color and a mapped integer set_masks() \u00b6 def set_masks ( unknown ): set_masks((r,g,b,a)) -> None set the bitmasks needed to convert between a color and a mapped integer set_shifts() \u00b6 def set_shifts ( unknown ): set_shifts((r,g,b,a)) -> None sets the bit shifts needed to convert between a color and a mapped integer get_losses() \u00b6 def get_losses ( unknown ): get_losses() -> (R, G, B, A) the significant bits used to convert between a color and a mapped integer subsurface() \u00b6 def subsurface ( unknown ): subsurface(Rect) -> Surface create a new surface that references its parent get_offset() \u00b6 def get_offset ( unknown ): get_offset() -> (x, y) find the position of a child subsurface inside a parent get_abs_offset() \u00b6 def get_abs_offset ( unknown ): get_abs_offset() -> (x, y) find the absolute position of a child subsurface inside its top level parent get_parent() \u00b6 def get_parent ( unknown ): get_parent() -> Surface find the parent of a subsurface get_abs_parent() \u00b6 def get_abs_parent ( unknown ): get_abs_parent() -> Surface find the top level parent of a subsurface get_bounding_rect() \u00b6 def get_bounding_rect ( unknown ): get_bounding_rect(min_alpha = 1) -> Rect find the smallest rect containing data get_view() \u00b6 def get_view ( unknown ): get_view(<kind>='2') -> BufferProxy return a buffer view of the Surface's pixels. get_buffer() \u00b6 def get_buffer ( unknown ): get_buffer() -> BufferProxy acquires a buffer object for the pixels of the Surface. Color \u00b6 class Color : Color(r, g, b) -> Color Color(r, g, b, a=255) -> Color Color(color_value) -> Color pygame object for color representations Color() \u00b6 Color ( * args , ** kwargs ): normalize() \u00b6 def normalize ( unknown ): normalize() -> tuple Returns the normalized RGBA values of the Color. correct_gamma() \u00b6 def correct_gamma ( unknown ): correct_gamma (gamma) -> Color Applies a certain gamma value to the Color. set_length() \u00b6 def set_length ( unknown ): set_length(len) -> None Set the number of elements in the Color to 1,2,3, or 4. lerp() \u00b6 def lerp ( unknown ): lerp(Color, float) -> Color returns a linear interpolation to the given Color. premul_alpha() \u00b6 def premul_alpha ( unknown ): premul_alpha() -> Color returns a Color where the r,g,b components have been multiplied by the alpha. update() \u00b6 def update ( unknown ): update(r, g, b) -> None update(r, g, b, a=255) -> None update(color_value) -> None Sets the elements of the color r \u00b6 r r -> int Gets or sets the red value of the Color. g \u00b6 g g -> int Gets or sets the green value of the Color. b \u00b6 b b -> int Gets or sets the blue value of the Color. a \u00b6 a a -> int Gets or sets the alpha value of the Color. hsva \u00b6 hsva hsva -> tuple Gets or sets the HSVA representation of the Color. hsla \u00b6 hsla hsla -> tuple Gets or sets the HSLA representation of the Color. i1i2i3 \u00b6 i1i2i3 i1i2i3 -> tuple Gets or sets the I1I2I3 representation of the Color. cmy \u00b6 cmy cmy -> tuple Gets or sets the CMY representation of the Color. PixelArray \u00b6 class PixelArray : PixelArray(Surface) -> PixelArray pygame object for direct pixel access of surfaces PixelArray() \u00b6 PixelArray (): compare() \u00b6 def compare ( unknown ): compare(array, distance=0, weights=(0.299, 0.587, 0.114)) -> PixelArray Compares the PixelArray with another one. extract() \u00b6 def extract ( unknown ): extract(color, distance=0, weights=(0.299, 0.587, 0.114)) -> PixelArray Extracts the passed color from the PixelArray. make_surface() \u00b6 def make_surface ( unknown ): make_surface() -> Surface Creates a new Surface from the current PixelArray. close() \u00b6 def close ( unknown ): transpose() -> PixelArray Closes the PixelArray, and releases Surface lock. replace() \u00b6 def replace ( unknown ): replace(color, repcolor, distance=0, weights=(0.299, 0.587, 0.114)) -> None Replaces the passed color in the PixelArray with another one. transpose() \u00b6 def transpose ( unknown ): transpose() -> PixelArray Exchanges the x and y axis. surface \u00b6 surface surface -> Surface Gets the Surface the PixelArray uses. itemsize \u00b6 itemsize itemsize -> int Returns the byte size of a pixel array item shape \u00b6 shape shape -> tuple of int's Returns the array size. strides \u00b6 strides strides -> tuple of int's Returns byte offsets for each array dimension. ndim \u00b6 ndim ndim -> int Returns the number of dimensions. Vector2 \u00b6 class Vector2 : Vector2() -> Vector2 Vector2(int) -> Vector2 Vector2(float) -> Vector2 Vector2(Vector2) -> Vector2 Vector2(x, y) -> Vector2 Vector2((x, y)) -> Vector2 a 2-Dimensional Vector Vector2() \u00b6 Vector2 ( * args , ** kwargs ): length() \u00b6 def length ( unknown ): length() -> float returns the Euclidean length of the vector. length_squared() \u00b6 def length_squared ( unknown ): length_squared() -> float returns the squared Euclidean length of the vector. magnitude() \u00b6 def magnitude ( unknown ): magnitude() -> float returns the Euclidean magnitude of the vector. magnitude_squared() \u00b6 def magnitude_squared ( unknown ): magnitude_squared() -> float returns the squared magnitude of the vector. rotate() \u00b6 def rotate ( unknown ): rotate(angle) -> Vector2 rotates a vector by a given angle in degrees. rotate_ip() \u00b6 def rotate_ip ( unknown ): rotate_ip(angle) -> None rotates the vector by a given angle in degrees in place. rotate_rad() \u00b6 def rotate_rad ( unknown ): rotate_rad(angle) -> Vector2 rotates a vector by a given angle in radians. rotate_rad_ip() \u00b6 def rotate_rad_ip ( unknown ): rotate_rad_ip(angle) -> None rotates the vector by a given angle in radians in place. rotate_ip_rad() \u00b6 def rotate_ip_rad ( unknown ): rotate_ip_rad(angle) -> None rotates the vector by a given angle in radians in place. slerp() \u00b6 def slerp ( unknown ): slerp(Vector2, float) -> Vector2 returns a spherical interpolation to the given vector. lerp() \u00b6 def lerp ( unknown ): lerp(Vector2, float) -> Vector2 returns a linear interpolation to the given vector. normalize() \u00b6 def normalize ( unknown ): normalize() -> Vector2 returns a vector with the same direction but length 1. normalize_ip() \u00b6 def normalize_ip ( unknown ): normalize_ip() -> None normalizes the vector in place so that its length is 1. is_normalized() \u00b6 def is_normalized ( unknown ): is_normalized() -> Bool tests if the vector is normalized i.e. has length == 1. cross() \u00b6 def cross ( unknown ): cross(Vector2) -> Vector2 calculates the cross- or vector-product dot() \u00b6 def dot ( unknown ): dot(Vector2) -> float calculates the dot- or scalar-product with the other vector angle_to() \u00b6 def angle_to ( unknown ): angle_to(Vector2) -> float calculates the angle to a given vector in degrees. update() \u00b6 def update ( unknown ): update() -> None update(int) -> None update(float) -> None update(Vector2) -> None update(x, y) -> None update((x, y)) -> None Sets the coordinates of the vector. scale_to_length() \u00b6 def scale_to_length ( unknown ): scale_to_length(float) -> None scales the vector to a given length. reflect() \u00b6 def reflect ( unknown ): reflect(Vector2) -> Vector2 returns a vector reflected of a given normal. reflect_ip() \u00b6 def reflect_ip ( unknown ): reflect_ip(Vector2) -> None reflect the vector of a given normal in place. distance_to() \u00b6 def distance_to ( unknown ): distance_to(Vector2) -> float calculates the Euclidean distance to a given vector. distance_squared_to() \u00b6 def distance_squared_to ( unknown ): distance_squared_to(Vector2) -> float calculates the squared Euclidean distance to a given vector. elementwise() \u00b6 def elementwise ( unknown ): elementwise() -> VectorElementwiseProxy The next operation will be performed elementwise. as_polar() \u00b6 def as_polar ( unknown ): as_polar() -> (r, phi) returns a tuple with radial distance and azimuthal angle. from_polar() \u00b6 def from_polar ( unknown ): from_polar((r, phi)) -> None Sets x and y from a polar coordinates tuple. project() \u00b6 def project ( unknown ): project(Vector2) -> Vector2 projects a vector onto another. copy() \u00b6 def copy ( unknown ): copy() -> Vector2 Returns a copy of itself. epsilon \u00b6 epsilon small value used in comparisons x \u00b6 x y \u00b6 y Vector3 \u00b6 class Vector3 : Vector3() -> Vector3 Vector3(int) -> Vector3 Vector3(float) -> Vector3 Vector3(Vector3) -> Vector3 Vector3(x, y, z) -> Vector3 Vector3((x, y, z)) -> Vector3 a 3-Dimensional Vector Vector3() \u00b6 Vector3 ( * args , ** kwargs ): length() \u00b6 def length ( unknown ): length() -> float returns the Euclidean length of the vector. length_squared() \u00b6 def length_squared ( unknown ): length_squared() -> float returns the squared Euclidean length of the vector. magnitude() \u00b6 def magnitude ( unknown ): magnitude() -> float returns the Euclidean magnitude of the vector. magnitude_squared() \u00b6 def magnitude_squared ( unknown ): magnitude_squared() -> float returns the squared Euclidean magnitude of the vector. rotate() \u00b6 def rotate ( unknown ): rotate(angle, Vector3) -> Vector3 rotates a vector by a given angle in degrees. rotate_ip() \u00b6 def rotate_ip ( unknown ): rotate_ip(angle, Vector3) -> None rotates the vector by a given angle in degrees in place. rotate_rad() \u00b6 def rotate_rad ( unknown ): rotate_rad(angle, Vector3) -> Vector3 rotates a vector by a given angle in radians. rotate_rad_ip() \u00b6 def rotate_rad_ip ( unknown ): rotate_rad_ip(angle, Vector3) -> None rotates the vector by a given angle in radians in place. rotate_ip_rad() \u00b6 def rotate_ip_rad ( unknown ): rotate_ip_rad(angle, Vector3) -> None rotates the vector by a given angle in radians in place. rotate_x() \u00b6 def rotate_x ( unknown ): rotate_x(angle) -> Vector3 rotates a vector around the x-axis by the angle in degrees. rotate_x_ip() \u00b6 def rotate_x_ip ( unknown ): rotate_x_ip(angle) -> None rotates the vector around the x-axis by the angle in degrees in place. rotate_x_rad() \u00b6 def rotate_x_rad ( unknown ): rotate_x_rad(angle) -> Vector3 rotates a vector around the x-axis by the angle in radians. rotate_x_rad_ip() \u00b6 def rotate_x_rad_ip ( unknown ): rotate_x_rad_ip(angle) -> None rotates the vector around the x-axis by the angle in radians in place. rotate_x_ip_rad() \u00b6 def rotate_x_ip_rad ( unknown ): rotate_x_ip_rad(angle) -> None rotates the vector around the x-axis by the angle in radians in place. rotate_y() \u00b6 def rotate_y ( unknown ): rotate_y(angle) -> Vector3 rotates a vector around the y-axis by the angle in degrees. rotate_y_ip() \u00b6 def rotate_y_ip ( unknown ): rotate_y_ip(angle) -> None rotates the vector around the y-axis by the angle in degrees in place. rotate_y_rad() \u00b6 def rotate_y_rad ( unknown ): rotate_y_rad(angle) -> Vector3 rotates a vector around the y-axis by the angle in radians. rotate_y_rad_ip() \u00b6 def rotate_y_rad_ip ( unknown ): rotate_y_rad_ip(angle) -> None rotates the vector around the y-axis by the angle in radians in place. rotate_y_ip_rad() \u00b6 def rotate_y_ip_rad ( unknown ): rotate_y_ip_rad(angle) -> None rotates the vector around the y-axis by the angle in radians in place. rotate_z() \u00b6 def rotate_z ( unknown ): rotate_z(angle) -> Vector3 rotates a vector around the z-axis by the angle in degrees. rotate_z_ip() \u00b6 def rotate_z_ip ( unknown ): rotate_z_ip(angle) -> None rotates the vector around the z-axis by the angle in degrees in place. rotate_z_rad() \u00b6 def rotate_z_rad ( unknown ): rotate_z_rad(angle) -> Vector3 rotates a vector around the z-axis by the angle in radians. rotate_z_rad_ip() \u00b6 def rotate_z_rad_ip ( unknown ): rotate_z_rad_ip(angle) -> None rotates the vector around the z-axis by the angle in radians in place. rotate_z_ip_rad() \u00b6 def rotate_z_ip_rad ( unknown ): rotate_z_ip_rad(angle) -> None rotates the vector around the z-axis by the angle in radians in place. slerp() \u00b6 def slerp ( unknown ): slerp(Vector3, float) -> Vector3 returns a spherical interpolation to the given vector. lerp() \u00b6 def lerp ( unknown ): lerp(Vector3, float) -> Vector3 returns a linear interpolation to the given vector. normalize() \u00b6 def normalize ( unknown ): normalize() -> Vector3 returns a vector with the same direction but length 1. normalize_ip() \u00b6 def normalize_ip ( unknown ): normalize_ip() -> None normalizes the vector in place so that its length is 1. is_normalized() \u00b6 def is_normalized ( unknown ): is_normalized() -> Bool tests if the vector is normalized i.e. has length == 1. cross() \u00b6 def cross ( unknown ): cross(Vector3) -> Vector3 calculates the cross- or vector-product dot() \u00b6 def dot ( unknown ): dot(Vector3) -> float calculates the dot- or scalar-product with the other vector angle_to() \u00b6 def angle_to ( unknown ): angle_to(Vector3) -> float calculates the angle to a given vector in degrees. update() \u00b6 def update ( unknown ): update() -> None update(int) -> None update(float) -> None update(Vector3) -> None update(x, y, z) -> None update((x, y, z)) -> None Sets the coordinates of the vector. scale_to_length() \u00b6 def scale_to_length ( unknown ): scale_to_length(float) -> None scales the vector to a given length. reflect() \u00b6 def reflect ( unknown ): reflect(Vector3) -> Vector3 returns a vector reflected of a given normal. reflect_ip() \u00b6 def reflect_ip ( unknown ): reflect_ip(Vector3) -> None reflect the vector of a given normal in place. distance_to() \u00b6 def distance_to ( unknown ): distance_to(Vector3) -> float calculates the Euclidean distance to a given vector. distance_squared_to() \u00b6 def distance_squared_to ( unknown ): distance_squared_to(Vector3) -> float calculates the squared Euclidean distance to a given vector. elementwise() \u00b6 def elementwise ( unknown ): elementwise() -> VectorElementwiseProxy The next operation will be performed elementwise. as_spherical() \u00b6 def as_spherical ( unknown ): as_spherical() -> (r, theta, phi) returns a tuple with radial distance, inclination and azimuthal angle. from_spherical() \u00b6 def from_spherical ( unknown ): from_spherical((r, theta, phi)) -> None Sets x, y and z from a spherical coordinates 3-tuple. project() \u00b6 def project ( unknown ): project(Vector3) -> Vector3 projects a vector onto another. copy() \u00b6 def copy ( unknown ): copy() -> Vector3 Returns a copy of itself. epsilon \u00b6 epsilon small value used in comparisons x \u00b6 x y \u00b6 y z \u00b6 z","title":"seagulls.engine"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#seagullsengine","text":"Core Engine Components View Source \"\"\"Core Engine Components\"\"\" from ._collisions import CollidableObject , flag_from_string from ._game_clock import GameClock from ._game_controls import GameControls from ._game_object import GameObject , GameObjectsCollection from ._game_scene import IGameScene from ._game_scene_manager import IProvideGameScenes from ._game_session import IGameSession from ._game_session_manager import IProvideGameSessions from ._game_settings import GameSettings from ._pygame import Color , PixelArray , Rect , Surface , Vector2 , Vector3 from ._surface_renderer import SurfaceRenderer __all__ = [ \"flag_from_string\" , \"CollidableObject\" , \"IGameScene\" , \"IProvideGameScenes\" , \"IProvideGameSessions\" , \"IGameSession\" , \"SurfaceRenderer\" , \"GameClock\" , \"GameControls\" , \"GameObject\" , \"GameObjectsCollection\" , \"GameSettings\" , \"Rect\" , \"Surface\" , \"Color\" , \"PixelArray\" , \"Vector2\" , \"Vector3\" , ]","title":"seagulls.engine"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#flag_from_string","text":"def flag_from_string ( value : str ) -> int : View Source def flag_from_string ( value : str ) -> int : if not isinstance ( value , str ): raise ValueError ( f \"Value must be a string of 0s and 1s: { value } \" ) return int ( value , 2 )","title":"flag_from_string()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#collidableobject","text":"@dataclass ( frozen = True ) class CollidableObject : CollidableObject(layer: int, mask: int) View Source @dataclass ( frozen = True ) class CollidableObject : layer : int mask : int def filter_by_mask ( self , targets : Tuple [ \"CollidableObject\" , ... ]) -> Tuple [ \"CollidableObject\" , ... ]: result = [] for t in targets : if self . is_in_mask ( t ): result . append ( t ) return tuple ( result ) def is_in_mask ( self , target : \"CollidableObject\" ) -> bool : logger . debug ( f \"targeting items located in mask: { self . mask : b } \" ) logger . debug ( f \"target is located in layer: { target . layer : b } \" ) logger . debug ( f \"& result: { self . mask & target . layer : b } \" ) return self . mask & target . layer > 0 def __repr__ ( self ) -> str : return f \" { self . __class__ . __name__ } (layer= { self . layer : b } , mask= { self . mask : b } )\"","title":"CollidableObject"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#collidableobject_1","text":"CollidableObject ( layer : int , mask : int ):","title":"CollidableObject()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#filter_by_mask","text":"def filter_by_mask ( self , targets : Tuple [ seagulls . engine . _collisions . CollidableObject , ... ] ) -> Tuple [ seagulls . engine . _collisions . CollidableObject , ... ]: View Source def filter_by_mask ( self , targets : Tuple [ \"CollidableObject\" , ... ]) -> Tuple [ \"CollidableObject\" , ... ]: result = [] for t in targets : if self . is_in_mask ( t ): result . append ( t ) return tuple ( result )","title":"filter_by_mask()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#is_in_mask","text":"def is_in_mask ( self , target : seagulls . engine . _collisions . CollidableObject ) -> bool : View Source def is_in_mask ( self , target : \"CollidableObject\" ) -> bool : logger . debug ( f \"targeting items located in mask: { self . mask : b } \" ) logger . debug ( f \"target is located in layer: { target . layer : b } \" ) logger . debug ( f \"& result: { self . mask & target . layer : b } \" ) return self . mask & target . layer > 0","title":"is_in_mask()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#igamescene","text":"class IGameScene ( abc . ABC ): This class is for X and Y. View Source class IGameScene ( ABC ): \"\"\" This class is for X and Y. \"\"\" @abstractmethod def start ( self ) -> None : pass @abstractmethod def should_quit ( self ) -> bool : pass @abstractmethod def tick ( self ) -> None : pass","title":"IGameScene"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#start","text":"@abstractmethod def start ( self ) -> None : View Source @abstractmethod def start ( self ) -> None : pass","title":"start()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#should_quit","text":"@abstractmethod def should_quit ( self ) -> bool : View Source @abstractmethod def should_quit ( self ) -> bool : pass","title":"should_quit()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#tick","text":"@abstractmethod def tick ( self ) -> None : View Source @abstractmethod def tick ( self ) -> None : pass","title":"tick()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#iprovidegamescenes","text":"class IProvideGameScenes ( abc . ABC ): Helper class that provides a standard way to create an ABC using inheritance. View Source class IProvideGameScenes ( ABC ): @abstractmethod def get_scene ( self ) -> IGameScene : pass","title":"IProvideGameScenes"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_scene","text":"@abstractmethod def get_scene ( self ) -> seagulls . engine . _game_scene . IGameScene : View Source @abstractmethod def get_scene ( self ) -> IGameScene : pass","title":"get_scene()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#iprovidegamesessions","text":"class IProvideGameSessions ( abc . ABC ): Helper class that provides a standard way to create an ABC using inheritance. View Source class IProvideGameSessions ( ABC ): @abstractmethod def get_session ( self , scene : str ) -> IGameSession : pass","title":"IProvideGameSessions"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_session","text":"@abstractmethod def get_session ( self , scene : str ) -> seagulls . engine . _game_session . IGameSession : View Source @abstractmethod def get_session ( self , scene : str ) -> IGameSession : pass","title":"get_session()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#igamesession","text":"class IGameSession ( abc . ABC ): Helper class that provides a standard way to create an ABC using inheritance. View Source class IGameSession ( ABC ): @abstractmethod def start ( self ) -> None : pass @abstractmethod def wait_for_completion ( self ) -> None : pass @abstractmethod def stop ( self ) -> None : pass","title":"IGameSession"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#start_1","text":"@abstractmethod def start ( self ) -> None : View Source @abstractmethod def start ( self ) -> None : pass","title":"start()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#wait_for_completion","text":"@abstractmethod def wait_for_completion ( self ) -> None : View Source @abstractmethod def wait_for_completion ( self ) -> None : pass","title":"wait_for_completion()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#stop","text":"@abstractmethod def stop ( self ) -> None : View Source @abstractmethod def stop ( self ) -> None : pass","title":"stop()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#surfacerenderer","text":"class SurfaceRenderer : View Source class SurfaceRenderer : def start ( self ) -> None : self . _get_surface () def render ( self , surface : Surface ) -> None : self . _get_surface () . blit ( surface , ( 0 , 0 )) pygame . display . flip () @lru_cache () def _get_surface ( self ) -> Surface : return pygame . display . set_mode (( 1024 , 600 ))","title":"SurfaceRenderer"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#surfacerenderer_1","text":"SurfaceRenderer ():","title":"SurfaceRenderer()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#start_2","text":"def start ( self ) -> None : View Source def start ( self ) -> None : self . _get_surface ()","title":"start()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#render","text":"def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : Surface ) -> None : self . _get_surface () . blit ( surface , ( 0 , 0 )) pygame . display . flip ()","title":"render()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#gameclock","text":"class GameClock ( seagulls . engine . _game_object . GameObject ): Interface for anything representing an object in the scene. View Source class GameClock ( GameObject ): _clock : Clock _ticks : int _delta : int def __init__ ( self ): self . _clock = Clock () self . _ticks = 0 self . _delta = 0 def tick ( self ) -> None : self . _delta = self . _clock . tick () def render ( self , surface : Surface ) -> None : pass def get_time ( self ) -> int : return self . _delta def get_fps ( self ) -> float : return self . _clock . get_fps ()","title":"GameClock"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#gameclock_1","text":"GameClock (): View Source def __init__ ( self ): self . _clock = Clock () self . _ticks = 0 self . _delta = 0","title":"GameClock()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#tick_1","text":"def tick ( self ) -> None : View Source def tick ( self ) -> None : self . _delta = self . _clock . tick ()","title":"tick()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#render_1","text":"def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : Surface ) -> None : pass","title":"render()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_time","text":"def get_time ( self ) -> int : View Source def get_time ( self ) -> int : return self . _delta","title":"get_time()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_fps","text":"def get_fps ( self ) -> float : View Source def get_fps ( self ) -> float : return self . _clock . get_fps ()","title":"get_fps()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#gamecontrols","text":"class GameControls ( seagulls . engine . _game_object . GameObject ): Interface for anything representing an object in the scene. View Source class GameControls ( GameObject ): _events : List [ Event ] def __init__ ( self ): self . _events = [] def tick ( self ): self . _events = pygame . event . get () def should_quit ( self ) -> bool : for event in self . _events : if event . type == pygame . QUIT : return True if self . _is_key_down_event ( event , pygame . K_ESCAPE ): return True return False def should_fire ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_SPACE ): return True return False def is_left_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_LEFT ] def is_right_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_RIGHT ] def is_up_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_UP ] def is_down_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_DOWN ] def should_toggle_debug_hud ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_BACKQUOTE ): return True return False def is_click_initialized ( self ) -> bool : for event in self . _events : if not event . type == pygame . MOUSEBUTTONDOWN : continue return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] return False def is_mouse_down ( self ) -> bool : return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] def _is_key_down_event ( self , event : Event , key : int ) -> bool : return event . type == pygame . KEYDOWN and event . key == key def _is_key_up_event ( self , event : Event , key : int ) -> bool : return event . type == pygame . KEYUP and event . key == key def render ( self , surface : Surface ) -> None : pass","title":"GameControls"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#gamecontrols_1","text":"GameControls (): View Source def __init__ ( self ): self . _events = []","title":"GameControls()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#tick_2","text":"def tick ( self ): View Source def tick ( self ): self . _events = pygame . event . get ()","title":"tick()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#should_quit_1","text":"def should_quit ( self ) -> bool : View Source def should_quit ( self ) -> bool : for event in self . _events : if event . type == pygame . QUIT : return True if self . _is_key_down_event ( event , pygame . K_ESCAPE ): return True return False","title":"should_quit()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#should_fire","text":"def should_fire ( self ) -> bool : View Source def should_fire ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_SPACE ): return True return False","title":"should_fire()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#is_left_moving","text":"def is_left_moving ( self ) -> bool : View Source def is_left_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_LEFT ]","title":"is_left_moving()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#is_right_moving","text":"def is_right_moving ( self ) -> bool : View Source def is_right_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_RIGHT ]","title":"is_right_moving()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#is_up_moving","text":"def is_up_moving ( self ) -> bool : View Source def is_up_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_UP ]","title":"is_up_moving()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#is_down_moving","text":"def is_down_moving ( self ) -> bool : View Source def is_down_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_DOWN ]","title":"is_down_moving()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#should_toggle_debug_hud","text":"def should_toggle_debug_hud ( self ) -> bool : View Source def should_toggle_debug_hud ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_BACKQUOTE ): return True return False","title":"should_toggle_debug_hud()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#is_click_initialized","text":"def is_click_initialized ( self ) -> bool : View Source def is_click_initialized ( self ) -> bool : for event in self . _events : if not event . type == pygame . MOUSEBUTTONDOWN : continue return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] return False","title":"is_click_initialized()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#is_mouse_down","text":"def is_mouse_down ( self ) -> bool : View Source def is_mouse_down ( self ) -> bool : return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ]","title":"is_mouse_down()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#render_2","text":"def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : Surface ) -> None : pass","title":"render()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#gameobject","text":"class GameObject ( abc . ABC ): Interface for anything representing an object in the scene. View Source class GameObject ( ABC ): \"\"\" Interface for anything representing an object in the scene. \"\"\" @abstractmethod def tick ( self ) -> None : pass @abstractmethod def render ( self , surface : Surface ) -> None : pass","title":"GameObject"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#tick_3","text":"@abstractmethod def tick ( self ) -> None : View Source @abstractmethod def tick ( self ) -> None : pass","title":"tick()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#render_3","text":"@abstractmethod def render ( self , surface : pygame . Surface ) -> None : View Source @abstractmethod def render ( self , surface : Surface ) -> None : pass","title":"render()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#gameobjectscollection","text":"class GameObjectsCollection : Data structure that allows you to keep track of objects in the scene. View Source class GameObjectsCollection : \"\"\" Data structure that allows you to keep track of objects in the scene. \"\"\" _game_objects : List [ GameObject ] def __init__ ( self ) -> None : self . _game_objects = [] def add ( self , game_object : GameObject ) -> None : self . _game_objects . append ( game_object ) def apply ( self , func : Callable [[ GameObject ], None ]) -> None : for game_object in self . _game_objects : func ( game_object )","title":"GameObjectsCollection"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#gameobjectscollection_1","text":"GameObjectsCollection (): View Source def __init__ ( self ) -> None : self . _game_objects = []","title":"GameObjectsCollection()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#add","text":"def add ( self , game_object : seagulls . engine . _game_object . GameObject ) -> None : View Source def add ( self , game_object : GameObject ) -> None : self . _game_objects . append ( game_object )","title":"add()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#apply","text":"def apply ( self , func : Callable [[ seagulls . engine . _game_object . GameObject ], NoneType ] ) -> None : View Source def apply ( self , func : Callable [[ GameObject ], None ]) -> None : for game_object in self . _game_objects : func ( game_object )","title":"apply()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#gamesettings","text":"class GameSettings : View Source class GameSettings : def get_setting ( self , name , default = None ) -> Any : data = self . _load_yaml () return data . get ( name , default ) @lru_cache () def _load_yaml ( self ) -> Dict [ str , Any ]: file = Path . home () / \".config/seagulls.yaml\" if not file . exists (): file . touch () return yaml . safe_load ( file . read_text ()) or {}","title":"GameSettings"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#gamesettings_1","text":"GameSettings ():","title":"GameSettings()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_setting","text":"def get_setting ( self , name , default = None ) -> Any : View Source def get_setting ( self , name , default = None ) -> Any : data = self . _load_yaml () return data . get ( name , default )","title":"get_setting()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#rect","text":"class Rect : Rect(left, top, width, height) -> Rect Rect((left, top), (width, height)) -> Rect Rect(object) -> Rect pygame object for storing rectangular coordinates","title":"Rect"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#rect_1","text":"Rect ( * args , ** kwargs ):","title":"Rect()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#normalize","text":"def normalize ( unknown ): normalize() -> None correct negative sizes","title":"normalize()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#clip","text":"def clip ( unknown ): clip(Rect) -> Rect crops a rectangle inside another","title":"clip()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#clipline","text":"def clipline ( unknown ): clipline(x1, y1, x2, y2) -> ((cx1, cy1), (cx2, cy2)) clipline(x1, y1, x2, y2) -> () clipline((x1, y1), (x2, y2)) -> ((cx1, cy1), (cx2, cy2)) clipline((x1, y1), (x2, y2)) -> () clipline((x1, y1, x2, y2)) -> ((cx1, cy1), (cx2, cy2)) clipline((x1, y1, x2, y2)) -> () clipline(((x1, y1), (x2, y2))) -> ((cx1, cy1), (cx2, cy2)) clipline(((x1, y1), (x2, y2))) -> () crops a line inside a rectangle","title":"clipline()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#clamp","text":"def clamp ( unknown ): clamp(Rect) -> Rect moves the rectangle inside another","title":"clamp()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#clamp_ip","text":"def clamp_ip ( unknown ): clamp_ip(Rect) -> None moves the rectangle inside another, in place","title":"clamp_ip()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#copy","text":"def copy ( unknown ): copy() -> Rect copy the rectangle","title":"copy()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#fit","text":"def fit ( unknown ): fit(Rect) -> Rect resize and move a rectangle with aspect ratio","title":"fit()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#move","text":"def move ( unknown ): move(x, y) -> Rect moves the rectangle","title":"move()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#update","text":"def update ( unknown ): update(left, top, width, height) -> None update((left, top), (width, height)) -> None update(object) -> None sets the position and size of the rectangle","title":"update()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#inflate","text":"def inflate ( unknown ): inflate(x, y) -> Rect grow or shrink the rectangle size","title":"inflate()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#union","text":"def union ( unknown ): union(Rect) -> Rect joins two rectangles into one","title":"union()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#unionall","text":"def unionall ( unknown ): unionall(Rect_sequence) -> Rect the union of many rectangles","title":"unionall()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#move_ip","text":"def move_ip ( unknown ): move_ip(x, y) -> None moves the rectangle, in place","title":"move_ip()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#inflate_ip","text":"def inflate_ip ( unknown ): inflate_ip(x, y) -> None grow or shrink the rectangle size, in place","title":"inflate_ip()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#union_ip","text":"def union_ip ( unknown ): union_ip(Rect) -> None joins two rectangles into one, in place","title":"union_ip()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#unionall_ip","text":"def unionall_ip ( unknown ): unionall_ip(Rect_sequence) -> None the union of many rectangles, in place","title":"unionall_ip()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#collidepoint","text":"def collidepoint ( unknown ): collidepoint(x, y) -> bool collidepoint((x,y)) -> bool test if a point is inside a rectangle","title":"collidepoint()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#colliderect","text":"def colliderect ( unknown ): colliderect(Rect) -> bool test if two rectangles overlap","title":"colliderect()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#collidelist","text":"def collidelist ( unknown ): collidelist(list) -> index test if one rectangle in a list intersects","title":"collidelist()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#collidelistall","text":"def collidelistall ( unknown ): collidelistall(list) -> indices test if all rectangles in a list intersect","title":"collidelistall()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#collidedict","text":"def collidedict ( unknown ): collidedict(dict) -> (key, value) collidedict(dict) -> None collidedict(dict, use_values=0) -> (key, value) collidedict(dict, use_values=0) -> None test if one rectangle in a dictionary intersects","title":"collidedict()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#collidedictall","text":"def collidedictall ( unknown ): collidedictall(dict) -> [(key, value), ...] collidedictall(dict, use_values=0) -> [(key, value), ...] test if all rectangles in a dictionary intersect","title":"collidedictall()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#contains","text":"def contains ( unknown ): contains(Rect) -> bool test if one rectangle is inside another","title":"contains()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#x","text":"x","title":"x"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#y","text":"y","title":"y"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#w","text":"w","title":"w"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#h","text":"h","title":"h"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#width","text":"width","title":"width"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#height","text":"height","title":"height"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#top","text":"top","title":"top"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#left","text":"left","title":"left"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#bottom","text":"bottom","title":"bottom"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#right","text":"right","title":"right"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#centerx","text":"centerx","title":"centerx"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#centery","text":"centery","title":"centery"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#topleft","text":"topleft","title":"topleft"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#topright","text":"topright","title":"topright"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#bottomleft","text":"bottomleft","title":"bottomleft"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#bottomright","text":"bottomright","title":"bottomright"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#midtop","text":"midtop","title":"midtop"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#midleft","text":"midleft","title":"midleft"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#midbottom","text":"midbottom","title":"midbottom"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#midright","text":"midright","title":"midright"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#size","text":"size","title":"size"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#center","text":"center","title":"center"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#surface","text":"class Surface : Surface((width, height), flags=0, depth=0, masks=None) -> Surface Surface((width, height), flags=0, Surface) -> Surface pygame object for representing images","title":"Surface"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#surface_1","text":"Surface ( * args , ** kwargs ):","title":"Surface()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_at","text":"def get_at ( unknown ): get_at((x, y)) -> Color get the color value at a single pixel","title":"get_at()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#set_at","text":"def set_at ( unknown ): set_at((x, y), Color) -> None set the color value for a single pixel","title":"set_at()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_at_mapped","text":"def get_at_mapped ( unknown ): get_at_mapped((x, y)) -> Color get the mapped color value at a single pixel","title":"get_at_mapped()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#map_rgb","text":"def map_rgb ( unknown ): map_rgb(Color) -> mapped_int convert a color into a mapped color value","title":"map_rgb()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#unmap_rgb","text":"def unmap_rgb ( unknown ): unmap_rgb(mapped_int) -> Color convert a mapped integer color value into a Color","title":"unmap_rgb()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_palette","text":"def get_palette ( unknown ): get_palette() -> [RGB, RGB, RGB, ...] get the color index palette for an 8-bit Surface","title":"get_palette()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_palette_at","text":"def get_palette_at ( unknown ): get_palette_at(index) -> RGB get the color for a single entry in a palette","title":"get_palette_at()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#set_palette","text":"def set_palette ( unknown ): set_palette([RGB, RGB, RGB, ...]) -> None set the color palette for an 8-bit Surface","title":"set_palette()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#set_palette_at","text":"def set_palette_at ( unknown ): set_palette_at(index, RGB) -> None set the color for a single index in an 8-bit Surface palette","title":"set_palette_at()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#lock","text":"def lock ( unknown ): lock() -> None lock the Surface memory for pixel access","title":"lock()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#unlock","text":"def unlock ( unknown ): unlock() -> None unlock the Surface memory from pixel access","title":"unlock()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#mustlock","text":"def mustlock ( unknown ): mustlock() -> bool test if the Surface requires locking","title":"mustlock()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_locked","text":"def get_locked ( unknown ): get_locked() -> bool test if the Surface is current locked","title":"get_locked()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_locks","text":"def get_locks ( unknown ): get_locks() -> tuple Gets the locks for the Surface","title":"get_locks()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#set_colorkey","text":"def set_colorkey ( unknown ): set_colorkey(Color, flags=0) -> None set_colorkey(None) -> None Set the transparent colorkey","title":"set_colorkey()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_colorkey","text":"def get_colorkey ( unknown ): get_colorkey() -> RGB or None Get the current transparent colorkey","title":"get_colorkey()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#set_alpha","text":"def set_alpha ( unknown ): set_alpha(value, flags=0) -> None set_alpha(None) -> None set the alpha value for the full Surface image","title":"set_alpha()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_alpha","text":"def get_alpha ( unknown ): get_alpha() -> int_value get the current Surface transparency value","title":"get_alpha()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_blendmode","text":"def get_blendmode ( unknown ): Return the surface's SDL 2 blend mode","title":"get_blendmode()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#copy_1","text":"def copy ( unknown ): copy() -> Surface create a new copy of a Surface","title":"copy()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#convert","text":"def convert ( unknown ): convert(Surface=None) -> Surface convert(depth, flags=0) -> Surface convert(masks, flags=0) -> Surface change the pixel format of an image","title":"convert()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#convert_alpha","text":"def convert_alpha ( unknown ): convert_alpha(Surface) -> Surface convert_alpha() -> Surface change the pixel format of an image including per pixel alphas","title":"convert_alpha()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#set_clip","text":"def set_clip ( unknown ): set_clip(rect) -> None set_clip(None) -> None set the current clipping area of the Surface","title":"set_clip()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_clip","text":"def get_clip ( unknown ): get_clip() -> Rect get the current clipping area of the Surface","title":"get_clip()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#fill","text":"def fill ( unknown ): fill(color, rect=None, special_flags=0) -> Rect fill Surface with a solid color","title":"fill()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#blit","text":"def blit ( unknown ): blit(source, dest, area=None, special_flags=0) -> Rect draw one image onto another","title":"blit()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#blits","text":"def blits ( unknown ): blits(blit_sequence=((source, dest), ...), doreturn=1) -> [Rect, ...] or None blits(((source, dest, area), ...)) -> [Rect, ...] blits(((source, dest, area, special_flags), ...)) -> [Rect, ...] draw many images onto another","title":"blits()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#scroll","text":"def scroll ( unknown ): scroll(dx=0, dy=0) -> None Shift the surface image in place","title":"scroll()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_flags","text":"def get_flags ( unknown ): get_flags() -> int get the additional flags used for the Surface","title":"get_flags()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_size","text":"def get_size ( unknown ): get_size() -> (width, height) get the dimensions of the Surface","title":"get_size()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_width","text":"def get_width ( unknown ): get_width() -> width get the width of the Surface","title":"get_width()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_height","text":"def get_height ( unknown ): get_height() -> height get the height of the Surface","title":"get_height()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_rect","text":"def get_rect ( unknown ): get_rect(**kwargs) -> Rect get the rectangular area of the Surface","title":"get_rect()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_pitch","text":"def get_pitch ( unknown ): get_pitch() -> int get the number of bytes used per Surface row","title":"get_pitch()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_bitsize","text":"def get_bitsize ( unknown ): get_bitsize() -> int get the bit depth of the Surface pixel format","title":"get_bitsize()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_bytesize","text":"def get_bytesize ( unknown ): get_bytesize() -> int get the bytes used per Surface pixel","title":"get_bytesize()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_masks","text":"def get_masks ( unknown ): get_masks() -> (R, G, B, A) the bitmasks needed to convert between a color and a mapped integer","title":"get_masks()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_shifts","text":"def get_shifts ( unknown ): get_shifts() -> (R, G, B, A) the bit shifts needed to convert between a color and a mapped integer","title":"get_shifts()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#set_masks","text":"def set_masks ( unknown ): set_masks((r,g,b,a)) -> None set the bitmasks needed to convert between a color and a mapped integer","title":"set_masks()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#set_shifts","text":"def set_shifts ( unknown ): set_shifts((r,g,b,a)) -> None sets the bit shifts needed to convert between a color and a mapped integer","title":"set_shifts()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_losses","text":"def get_losses ( unknown ): get_losses() -> (R, G, B, A) the significant bits used to convert between a color and a mapped integer","title":"get_losses()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#subsurface","text":"def subsurface ( unknown ): subsurface(Rect) -> Surface create a new surface that references its parent","title":"subsurface()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_offset","text":"def get_offset ( unknown ): get_offset() -> (x, y) find the position of a child subsurface inside a parent","title":"get_offset()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_abs_offset","text":"def get_abs_offset ( unknown ): get_abs_offset() -> (x, y) find the absolute position of a child subsurface inside its top level parent","title":"get_abs_offset()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_parent","text":"def get_parent ( unknown ): get_parent() -> Surface find the parent of a subsurface","title":"get_parent()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_abs_parent","text":"def get_abs_parent ( unknown ): get_abs_parent() -> Surface find the top level parent of a subsurface","title":"get_abs_parent()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_bounding_rect","text":"def get_bounding_rect ( unknown ): get_bounding_rect(min_alpha = 1) -> Rect find the smallest rect containing data","title":"get_bounding_rect()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_view","text":"def get_view ( unknown ): get_view(<kind>='2') -> BufferProxy return a buffer view of the Surface's pixels.","title":"get_view()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#get_buffer","text":"def get_buffer ( unknown ): get_buffer() -> BufferProxy acquires a buffer object for the pixels of the Surface.","title":"get_buffer()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#color","text":"class Color : Color(r, g, b) -> Color Color(r, g, b, a=255) -> Color Color(color_value) -> Color pygame object for color representations","title":"Color"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#color_1","text":"Color ( * args , ** kwargs ):","title":"Color()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#normalize_1","text":"def normalize ( unknown ): normalize() -> tuple Returns the normalized RGBA values of the Color.","title":"normalize()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#correct_gamma","text":"def correct_gamma ( unknown ): correct_gamma (gamma) -> Color Applies a certain gamma value to the Color.","title":"correct_gamma()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#set_length","text":"def set_length ( unknown ): set_length(len) -> None Set the number of elements in the Color to 1,2,3, or 4.","title":"set_length()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#lerp","text":"def lerp ( unknown ): lerp(Color, float) -> Color returns a linear interpolation to the given Color.","title":"lerp()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#premul_alpha","text":"def premul_alpha ( unknown ): premul_alpha() -> Color returns a Color where the r,g,b components have been multiplied by the alpha.","title":"premul_alpha()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#update_1","text":"def update ( unknown ): update(r, g, b) -> None update(r, g, b, a=255) -> None update(color_value) -> None Sets the elements of the color","title":"update()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#r","text":"r r -> int Gets or sets the red value of the Color.","title":"r"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#g","text":"g g -> int Gets or sets the green value of the Color.","title":"g"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#b","text":"b b -> int Gets or sets the blue value of the Color.","title":"b"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#a","text":"a a -> int Gets or sets the alpha value of the Color.","title":"a"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#hsva","text":"hsva hsva -> tuple Gets or sets the HSVA representation of the Color.","title":"hsva"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#hsla","text":"hsla hsla -> tuple Gets or sets the HSLA representation of the Color.","title":"hsla"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#i1i2i3","text":"i1i2i3 i1i2i3 -> tuple Gets or sets the I1I2I3 representation of the Color.","title":"i1i2i3"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#cmy","text":"cmy cmy -> tuple Gets or sets the CMY representation of the Color.","title":"cmy"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#pixelarray","text":"class PixelArray : PixelArray(Surface) -> PixelArray pygame object for direct pixel access of surfaces","title":"PixelArray"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#pixelarray_1","text":"PixelArray ():","title":"PixelArray()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#compare","text":"def compare ( unknown ): compare(array, distance=0, weights=(0.299, 0.587, 0.114)) -> PixelArray Compares the PixelArray with another one.","title":"compare()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#extract","text":"def extract ( unknown ): extract(color, distance=0, weights=(0.299, 0.587, 0.114)) -> PixelArray Extracts the passed color from the PixelArray.","title":"extract()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#make_surface","text":"def make_surface ( unknown ): make_surface() -> Surface Creates a new Surface from the current PixelArray.","title":"make_surface()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#close","text":"def close ( unknown ): transpose() -> PixelArray Closes the PixelArray, and releases Surface lock.","title":"close()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#replace","text":"def replace ( unknown ): replace(color, repcolor, distance=0, weights=(0.299, 0.587, 0.114)) -> None Replaces the passed color in the PixelArray with another one.","title":"replace()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#transpose","text":"def transpose ( unknown ): transpose() -> PixelArray Exchanges the x and y axis.","title":"transpose()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#surface_2","text":"surface surface -> Surface Gets the Surface the PixelArray uses.","title":"surface"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#itemsize","text":"itemsize itemsize -> int Returns the byte size of a pixel array item","title":"itemsize"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#shape","text":"shape shape -> tuple of int's Returns the array size.","title":"shape"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#strides","text":"strides strides -> tuple of int's Returns byte offsets for each array dimension.","title":"strides"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#ndim","text":"ndim ndim -> int Returns the number of dimensions.","title":"ndim"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#vector2","text":"class Vector2 : Vector2() -> Vector2 Vector2(int) -> Vector2 Vector2(float) -> Vector2 Vector2(Vector2) -> Vector2 Vector2(x, y) -> Vector2 Vector2((x, y)) -> Vector2 a 2-Dimensional Vector","title":"Vector2"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#vector2_1","text":"Vector2 ( * args , ** kwargs ):","title":"Vector2()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#length","text":"def length ( unknown ): length() -> float returns the Euclidean length of the vector.","title":"length()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#length_squared","text":"def length_squared ( unknown ): length_squared() -> float returns the squared Euclidean length of the vector.","title":"length_squared()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#magnitude","text":"def magnitude ( unknown ): magnitude() -> float returns the Euclidean magnitude of the vector.","title":"magnitude()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#magnitude_squared","text":"def magnitude_squared ( unknown ): magnitude_squared() -> float returns the squared magnitude of the vector.","title":"magnitude_squared()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#rotate","text":"def rotate ( unknown ): rotate(angle) -> Vector2 rotates a vector by a given angle in degrees.","title":"rotate()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#rotate_ip","text":"def rotate_ip ( unknown ): rotate_ip(angle) -> None rotates the vector by a given angle in degrees in place.","title":"rotate_ip()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#rotate_rad","text":"def rotate_rad ( unknown ): rotate_rad(angle) -> Vector2 rotates a vector by a given angle in radians.","title":"rotate_rad()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#rotate_rad_ip","text":"def rotate_rad_ip ( unknown ): rotate_rad_ip(angle) -> None rotates the vector by a given angle in radians in place.","title":"rotate_rad_ip()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#rotate_ip_rad","text":"def rotate_ip_rad ( unknown ): rotate_ip_rad(angle) -> None rotates the vector by a given angle in radians in place.","title":"rotate_ip_rad()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#slerp","text":"def slerp ( unknown ): slerp(Vector2, float) -> Vector2 returns a spherical interpolation to the given vector.","title":"slerp()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#lerp_1","text":"def lerp ( unknown ): lerp(Vector2, float) -> Vector2 returns a linear interpolation to the given vector.","title":"lerp()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#normalize_2","text":"def normalize ( unknown ): normalize() -> Vector2 returns a vector with the same direction but length 1.","title":"normalize()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#normalize_ip","text":"def normalize_ip ( unknown ): normalize_ip() -> None normalizes the vector in place so that its length is 1.","title":"normalize_ip()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#is_normalized","text":"def is_normalized ( unknown ): is_normalized() -> Bool tests if the vector is normalized i.e. has length == 1.","title":"is_normalized()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#cross","text":"def cross ( unknown ): cross(Vector2) -> Vector2 calculates the cross- or vector-product","title":"cross()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#dot","text":"def dot ( unknown ): dot(Vector2) -> float calculates the dot- or scalar-product with the other vector","title":"dot()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#angle_to","text":"def angle_to ( unknown ): angle_to(Vector2) -> float calculates the angle to a given vector in degrees.","title":"angle_to()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#update_2","text":"def update ( unknown ): update() -> None update(int) -> None update(float) -> None update(Vector2) -> None update(x, y) -> None update((x, y)) -> None Sets the coordinates of the vector.","title":"update()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#scale_to_length","text":"def scale_to_length ( unknown ): scale_to_length(float) -> None scales the vector to a given length.","title":"scale_to_length()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#reflect","text":"def reflect ( unknown ): reflect(Vector2) -> Vector2 returns a vector reflected of a given normal.","title":"reflect()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#reflect_ip","text":"def reflect_ip ( unknown ): reflect_ip(Vector2) -> None reflect the vector of a given normal in place.","title":"reflect_ip()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#distance_to","text":"def distance_to ( unknown ): distance_to(Vector2) -> float calculates the Euclidean distance to a given vector.","title":"distance_to()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#distance_squared_to","text":"def distance_squared_to ( unknown ): distance_squared_to(Vector2) -> float calculates the squared Euclidean distance to a given vector.","title":"distance_squared_to()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#elementwise","text":"def elementwise ( unknown ): elementwise() -> VectorElementwiseProxy The next operation will be performed elementwise.","title":"elementwise()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#as_polar","text":"def as_polar ( unknown ): as_polar() -> (r, phi) returns a tuple with radial distance and azimuthal angle.","title":"as_polar()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#from_polar","text":"def from_polar ( unknown ): from_polar((r, phi)) -> None Sets x and y from a polar coordinates tuple.","title":"from_polar()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#project","text":"def project ( unknown ): project(Vector2) -> Vector2 projects a vector onto another.","title":"project()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#copy_2","text":"def copy ( unknown ): copy() -> Vector2 Returns a copy of itself.","title":"copy()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#epsilon","text":"epsilon small value used in comparisons","title":"epsilon"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#x_1","text":"x","title":"x"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#y_1","text":"y","title":"y"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#vector3","text":"class Vector3 : Vector3() -> Vector3 Vector3(int) -> Vector3 Vector3(float) -> Vector3 Vector3(Vector3) -> Vector3 Vector3(x, y, z) -> Vector3 Vector3((x, y, z)) -> Vector3 a 3-Dimensional Vector","title":"Vector3"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#vector3_1","text":"Vector3 ( * args , ** kwargs ):","title":"Vector3()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#length_1","text":"def length ( unknown ): length() -> float returns the Euclidean length of the vector.","title":"length()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#length_squared_1","text":"def length_squared ( unknown ): length_squared() -> float returns the squared Euclidean length of the vector.","title":"length_squared()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#magnitude_1","text":"def magnitude ( unknown ): magnitude() -> float returns the Euclidean magnitude of the vector.","title":"magnitude()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#magnitude_squared_1","text":"def magnitude_squared ( unknown ): magnitude_squared() -> float returns the squared Euclidean magnitude of the vector.","title":"magnitude_squared()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#rotate_1","text":"def rotate ( unknown ): rotate(angle, Vector3) -> Vector3 rotates a vector by a given angle in degrees.","title":"rotate()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#rotate_ip_1","text":"def rotate_ip ( unknown ): rotate_ip(angle, Vector3) -> None rotates the vector by a given angle in degrees in place.","title":"rotate_ip()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#rotate_rad_1","text":"def rotate_rad ( unknown ): rotate_rad(angle, Vector3) -> Vector3 rotates a vector by a given angle in radians.","title":"rotate_rad()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#rotate_rad_ip_1","text":"def rotate_rad_ip ( unknown ): rotate_rad_ip(angle, Vector3) -> None rotates the vector by a given angle in radians in place.","title":"rotate_rad_ip()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#rotate_ip_rad_1","text":"def rotate_ip_rad ( unknown ): rotate_ip_rad(angle, Vector3) -> None rotates the vector by a given angle in radians in place.","title":"rotate_ip_rad()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#rotate_x","text":"def rotate_x ( unknown ): rotate_x(angle) -> Vector3 rotates a vector around the x-axis by the angle in degrees.","title":"rotate_x()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#rotate_x_ip","text":"def rotate_x_ip ( unknown ): rotate_x_ip(angle) -> None rotates the vector around the x-axis by the angle in degrees in place.","title":"rotate_x_ip()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#rotate_x_rad","text":"def rotate_x_rad ( unknown ): rotate_x_rad(angle) -> Vector3 rotates a vector around the x-axis by the angle in radians.","title":"rotate_x_rad()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#rotate_x_rad_ip","text":"def rotate_x_rad_ip ( unknown ): rotate_x_rad_ip(angle) -> None rotates the vector around the x-axis by the angle in radians in place.","title":"rotate_x_rad_ip()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#rotate_x_ip_rad","text":"def rotate_x_ip_rad ( unknown ): rotate_x_ip_rad(angle) -> None rotates the vector around the x-axis by the angle in radians in place.","title":"rotate_x_ip_rad()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#rotate_y","text":"def rotate_y ( unknown ): rotate_y(angle) -> Vector3 rotates a vector around the y-axis by the angle in degrees.","title":"rotate_y()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#rotate_y_ip","text":"def rotate_y_ip ( unknown ): rotate_y_ip(angle) -> None rotates the vector around the y-axis by the angle in degrees in place.","title":"rotate_y_ip()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#rotate_y_rad","text":"def rotate_y_rad ( unknown ): rotate_y_rad(angle) -> Vector3 rotates a vector around the y-axis by the angle in radians.","title":"rotate_y_rad()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#rotate_y_rad_ip","text":"def rotate_y_rad_ip ( unknown ): rotate_y_rad_ip(angle) -> None rotates the vector around the y-axis by the angle in radians in place.","title":"rotate_y_rad_ip()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#rotate_y_ip_rad","text":"def rotate_y_ip_rad ( unknown ): rotate_y_ip_rad(angle) -> None rotates the vector around the y-axis by the angle in radians in place.","title":"rotate_y_ip_rad()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#rotate_z","text":"def rotate_z ( unknown ): rotate_z(angle) -> Vector3 rotates a vector around the z-axis by the angle in degrees.","title":"rotate_z()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#rotate_z_ip","text":"def rotate_z_ip ( unknown ): rotate_z_ip(angle) -> None rotates the vector around the z-axis by the angle in degrees in place.","title":"rotate_z_ip()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#rotate_z_rad","text":"def rotate_z_rad ( unknown ): rotate_z_rad(angle) -> Vector3 rotates a vector around the z-axis by the angle in radians.","title":"rotate_z_rad()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#rotate_z_rad_ip","text":"def rotate_z_rad_ip ( unknown ): rotate_z_rad_ip(angle) -> None rotates the vector around the z-axis by the angle in radians in place.","title":"rotate_z_rad_ip()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#rotate_z_ip_rad","text":"def rotate_z_ip_rad ( unknown ): rotate_z_ip_rad(angle) -> None rotates the vector around the z-axis by the angle in radians in place.","title":"rotate_z_ip_rad()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#slerp_1","text":"def slerp ( unknown ): slerp(Vector3, float) -> Vector3 returns a spherical interpolation to the given vector.","title":"slerp()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#lerp_2","text":"def lerp ( unknown ): lerp(Vector3, float) -> Vector3 returns a linear interpolation to the given vector.","title":"lerp()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#normalize_3","text":"def normalize ( unknown ): normalize() -> Vector3 returns a vector with the same direction but length 1.","title":"normalize()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#normalize_ip_1","text":"def normalize_ip ( unknown ): normalize_ip() -> None normalizes the vector in place so that its length is 1.","title":"normalize_ip()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#is_normalized_1","text":"def is_normalized ( unknown ): is_normalized() -> Bool tests if the vector is normalized i.e. has length == 1.","title":"is_normalized()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#cross_1","text":"def cross ( unknown ): cross(Vector3) -> Vector3 calculates the cross- or vector-product","title":"cross()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#dot_1","text":"def dot ( unknown ): dot(Vector3) -> float calculates the dot- or scalar-product with the other vector","title":"dot()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#angle_to_1","text":"def angle_to ( unknown ): angle_to(Vector3) -> float calculates the angle to a given vector in degrees.","title":"angle_to()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#update_3","text":"def update ( unknown ): update() -> None update(int) -> None update(float) -> None update(Vector3) -> None update(x, y, z) -> None update((x, y, z)) -> None Sets the coordinates of the vector.","title":"update()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#scale_to_length_1","text":"def scale_to_length ( unknown ): scale_to_length(float) -> None scales the vector to a given length.","title":"scale_to_length()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#reflect_1","text":"def reflect ( unknown ): reflect(Vector3) -> Vector3 returns a vector reflected of a given normal.","title":"reflect()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#reflect_ip_1","text":"def reflect_ip ( unknown ): reflect_ip(Vector3) -> None reflect the vector of a given normal in place.","title":"reflect_ip()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#distance_to_1","text":"def distance_to ( unknown ): distance_to(Vector3) -> float calculates the Euclidean distance to a given vector.","title":"distance_to()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#distance_squared_to_1","text":"def distance_squared_to ( unknown ): distance_squared_to(Vector3) -> float calculates the squared Euclidean distance to a given vector.","title":"distance_squared_to()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#elementwise_1","text":"def elementwise ( unknown ): elementwise() -> VectorElementwiseProxy The next operation will be performed elementwise.","title":"elementwise()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#as_spherical","text":"def as_spherical ( unknown ): as_spherical() -> (r, theta, phi) returns a tuple with radial distance, inclination and azimuthal angle.","title":"as_spherical()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#from_spherical","text":"def from_spherical ( unknown ): from_spherical((r, theta, phi)) -> None Sets x, y and z from a spherical coordinates 3-tuple.","title":"from_spherical()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#project_1","text":"def project ( unknown ): project(Vector3) -> Vector3 projects a vector onto another.","title":"project()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#copy_3","text":"def copy ( unknown ): copy() -> Vector3 Returns a copy of itself.","title":"copy()"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#epsilon_1","text":"epsilon small value used in comparisons","title":"epsilon"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#x_2","text":"x","title":"x"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#y_2","text":"y","title":"y"},{"location":"api/seagulls-space-shooter-demo/seagulls/engine/#z","text":"z","title":"z"},{"location":"api/seagulls-space-shooter-demo/seagulls/eventing/","text":"seagulls .eventing \u00b6 View Source from ._interfaces import ( IDispatchEvents , EventType , EventCallbackType , ) __all__ = [ \"IDispatchEvents\" , \"EventType\" , \"EventCallbackType\" , ] IDispatchEvents \u00b6 class IDispatchEvents ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class IDispatchEvents ( Protocol ): @abstractmethod def register_callback ( self , event_type : Type [ EventType ], callback : EventCallbackType ) -> None : ... def trigger_event ( self , event : EventType ) -> None : ... register_callback() \u00b6 @abstractmethod def register_callback ( self , event_type : Type [ ~ EventType ], callback : Callable [[ ~ EventType ], NoneType ] ) -> None : View Source @abstractmethod def register_callback ( self , event_type : Type [ EventType ], callback : EventCallbackType ) -> None : ... trigger_event() \u00b6 def trigger_event ( self , event : ~ EventType ) -> None : View Source def trigger_event ( self , event : EventType ) -> None : ... EventType \u00b6 EventType = ~ EventType EventCallbackType \u00b6 EventCallbackType = typing . Callable [[ ~ EventType ], NoneType ]","title":"seagulls.eventing"},{"location":"api/seagulls-space-shooter-demo/seagulls/eventing/#seagullseventing","text":"View Source from ._interfaces import ( IDispatchEvents , EventType , EventCallbackType , ) __all__ = [ \"IDispatchEvents\" , \"EventType\" , \"EventCallbackType\" , ]","title":"seagulls.eventing"},{"location":"api/seagulls-space-shooter-demo/seagulls/eventing/#idispatchevents","text":"class IDispatchEvents ( typing . Protocol ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class IDispatchEvents ( Protocol ): @abstractmethod def register_callback ( self , event_type : Type [ EventType ], callback : EventCallbackType ) -> None : ... def trigger_event ( self , event : EventType ) -> None : ...","title":"IDispatchEvents"},{"location":"api/seagulls-space-shooter-demo/seagulls/eventing/#register_callback","text":"@abstractmethod def register_callback ( self , event_type : Type [ ~ EventType ], callback : Callable [[ ~ EventType ], NoneType ] ) -> None : View Source @abstractmethod def register_callback ( self , event_type : Type [ EventType ], callback : EventCallbackType ) -> None : ...","title":"register_callback()"},{"location":"api/seagulls-space-shooter-demo/seagulls/eventing/#trigger_event","text":"def trigger_event ( self , event : ~ EventType ) -> None : View Source def trigger_event ( self , event : EventType ) -> None : ...","title":"trigger_event()"},{"location":"api/seagulls-space-shooter-demo/seagulls/eventing/#eventtype","text":"EventType = ~ EventType","title":"EventType"},{"location":"api/seagulls-space-shooter-demo/seagulls/eventing/#eventcallbacktype","text":"EventCallbackType = typing . Callable [[ ~ EventType ], NoneType ]","title":"EventCallbackType"},{"location":"api/seagulls-space-shooter-demo/seagulls/seagulls_cli/","text":"seagulls .seagulls_cli \u00b6 View Source from ._application import SeagullsCliApplication from ._entry_point import main __all__ = [ \"SeagullsCliApplication\" , \"main\" , ] SeagullsCliApplication \u00b6 class SeagullsCliApplication ( seagulls . app . _app_interfaces . ISeagullsApplicationseagulls . app . _plugin_interfaces . IPluggableSeagullsApplicationseagulls . eventing . _interfaces . IDispatchEvents ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class SeagullsCliApplication ( ISeagullsApplication , IPluggableSeagullsApplication , IDispatchEvents ): _container_repository : DiContainerRepository _plugin_client : ISeagullsPluginClient _logging_client : LoggingClient _request : CliRequest _plugins : Dict [ Any , Any ] _callbacks : Dict [ Any , List [ Any ]] def __init__ ( self , container_repository : DiContainerRepository , plugin_client : ISeagullsPluginClient , logging_client : LoggingClient , request : CliRequest ): self . _container_repository = container_repository self . _plugin_client = plugin_client self . _logging_client = logging_client self . _request = request self . _plugins = {} self . _callbacks = {} def execute ( self ) -> None : self . _plugin_client . register_plugins ( self ) self . trigger_event ( PostPluginRegistrationEvent ()) self . _request . execute ( event_dispatcher = self ) def register_container ( self , key : Type [ ObjectType ], container : ObjectType ) -> None : self . _container_repository . register ( key , container ) def get_container ( self , key : Type [ ObjectType ]) -> ObjectType : return self . _container_repository . get ( key ) def register_callback ( self , event_type : Type [ EventType ], callback : EventCallbackType ) -> None : if event_type not in self . _callbacks : self . _callbacks [ event_type ] = [] self . _callbacks [ event_type ] . append ( callback ) def trigger_event ( self , event : EventType ) -> None : for callback in self . _callbacks . get ( type ( event ), []): callback ( event ) def register_plugin ( self , plugin : ISeagullsApplicationPlugin ) -> None : if type ( plugin ) in self . _plugins : raise DuplicatePluginError ( plugin ) self . _plugins [ type ( plugin )] = plugin plugin . on_registration () @lru_cache () def get_plugin ( self , plugin_type : Type [ PluginType ]) -> PluginType : # type: ignore return self . _plugins [ plugin_type ] def _apply_to_plugins ( self , callback : Callable [[ PluginType ], None ]) -> None : for plugin in self . _plugins . values (): callback ( plugin ) SeagullsCliApplication() \u00b6 SeagullsCliApplication ( container_repository : seagulls . seagulls_cli . _container_repository . DiContainerRepository , plugin_client : seagulls . app . _plugin_interfaces . ISeagullsPluginClient , logging_client : seagulls . seagulls_cli . _logging_client . LoggingClient , request : seagulls . cli . _request . CliRequest ): View Source def __init__ ( self , container_repository : DiContainerRepository , plugin_client : ISeagullsPluginClient , logging_client : LoggingClient , request : CliRequest ): self . _container_repository = container_repository self . _plugin_client = plugin_client self . _logging_client = logging_client self . _request = request self . _plugins = {} self . _callbacks = {} execute() \u00b6 def execute ( self ) -> None : View Source def execute ( self ) -> None : self . _plugin_client . register_plugins ( self ) self . trigger_event ( PostPluginRegistrationEvent ()) self . _request . execute ( event_dispatcher = self ) register_container() \u00b6 def register_container ( self , key : Type [ ~ ObjectType ], container : ~ ObjectType ) -> None : View Source def register_container ( self , key : Type [ ObjectType ], container : ObjectType ) -> None : self . _container_repository . register ( key , container ) get_container() \u00b6 def get_container ( self , key : Type [ ~ ObjectType ]) -> ~ ObjectType : View Source def get_container ( self , key : Type [ ObjectType ]) -> ObjectType : return self . _container_repository . get ( key ) register_callback() \u00b6 def register_callback ( self , event_type : Type [ ~ EventType ], callback : Callable [[ ~ EventType ], NoneType ] ) -> None : View Source def register_callback ( self , event_type : Type [ EventType ], callback : EventCallbackType ) -> None : if event_type not in self . _callbacks : self . _callbacks [ event_type ] = [] self . _callbacks [ event_type ] . append ( callback ) trigger_event() \u00b6 def trigger_event ( self , event : ~ EventType ) -> None : View Source def trigger_event ( self , event : EventType ) -> None : for callback in self . _callbacks . get ( type ( event ), []): callback ( event ) register_plugin() \u00b6 def register_plugin ( self , plugin : seagulls . app . _plugin_interfaces . ISeagullsApplicationPlugin ) -> None : View Source def register_plugin ( self , plugin : ISeagullsApplicationPlugin ) -> None : if type ( plugin ) in self . _plugins : raise DuplicatePluginError ( plugin ) self . _plugins [ type ( plugin )] = plugin plugin . on_registration () get_plugin() \u00b6 @lru_cache () def get_plugin ( self , plugin_type : Type [ ~ PluginType ]) -> ~ PluginType : View Source @lru_cache () def get_plugin ( self , plugin_type : Type [ PluginType ]) -> PluginType : # type: ignore return self . _plugins [ plugin_type ] main() \u00b6 def main (): View Source def main (): di_container = SeagullsAppDiContainer () app = di_container . application () app . execute ()","title":"seagulls.seagulls_cli"},{"location":"api/seagulls-space-shooter-demo/seagulls/seagulls_cli/#seagullsseagulls_cli","text":"View Source from ._application import SeagullsCliApplication from ._entry_point import main __all__ = [ \"SeagullsCliApplication\" , \"main\" , ]","title":"seagulls.seagulls_cli"},{"location":"api/seagulls-space-shooter-demo/seagulls/seagulls_cli/#seagullscliapplication","text":"class SeagullsCliApplication ( seagulls . app . _app_interfaces . ISeagullsApplicationseagulls . app . _plugin_interfaces . IPluggableSeagullsApplicationseagulls . eventing . _interfaces . IDispatchEvents ): Base class for protocol classes. Protocol classes are defined as:: class Proto(Protocol): def meth(self) -&gt; int: ... Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example:: class C: def meth(self) -&gt; int: return 0 def func(x: Proto) -&gt; int: return x.meth() func(C()) # Passes static type check See PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as:: class GenProto(Protocol[T]): def meth(self) -&gt; T: ... View Source class SeagullsCliApplication ( ISeagullsApplication , IPluggableSeagullsApplication , IDispatchEvents ): _container_repository : DiContainerRepository _plugin_client : ISeagullsPluginClient _logging_client : LoggingClient _request : CliRequest _plugins : Dict [ Any , Any ] _callbacks : Dict [ Any , List [ Any ]] def __init__ ( self , container_repository : DiContainerRepository , plugin_client : ISeagullsPluginClient , logging_client : LoggingClient , request : CliRequest ): self . _container_repository = container_repository self . _plugin_client = plugin_client self . _logging_client = logging_client self . _request = request self . _plugins = {} self . _callbacks = {} def execute ( self ) -> None : self . _plugin_client . register_plugins ( self ) self . trigger_event ( PostPluginRegistrationEvent ()) self . _request . execute ( event_dispatcher = self ) def register_container ( self , key : Type [ ObjectType ], container : ObjectType ) -> None : self . _container_repository . register ( key , container ) def get_container ( self , key : Type [ ObjectType ]) -> ObjectType : return self . _container_repository . get ( key ) def register_callback ( self , event_type : Type [ EventType ], callback : EventCallbackType ) -> None : if event_type not in self . _callbacks : self . _callbacks [ event_type ] = [] self . _callbacks [ event_type ] . append ( callback ) def trigger_event ( self , event : EventType ) -> None : for callback in self . _callbacks . get ( type ( event ), []): callback ( event ) def register_plugin ( self , plugin : ISeagullsApplicationPlugin ) -> None : if type ( plugin ) in self . _plugins : raise DuplicatePluginError ( plugin ) self . _plugins [ type ( plugin )] = plugin plugin . on_registration () @lru_cache () def get_plugin ( self , plugin_type : Type [ PluginType ]) -> PluginType : # type: ignore return self . _plugins [ plugin_type ] def _apply_to_plugins ( self , callback : Callable [[ PluginType ], None ]) -> None : for plugin in self . _plugins . values (): callback ( plugin )","title":"SeagullsCliApplication"},{"location":"api/seagulls-space-shooter-demo/seagulls/seagulls_cli/#seagullscliapplication_1","text":"SeagullsCliApplication ( container_repository : seagulls . seagulls_cli . _container_repository . DiContainerRepository , plugin_client : seagulls . app . _plugin_interfaces . ISeagullsPluginClient , logging_client : seagulls . seagulls_cli . _logging_client . LoggingClient , request : seagulls . cli . _request . CliRequest ): View Source def __init__ ( self , container_repository : DiContainerRepository , plugin_client : ISeagullsPluginClient , logging_client : LoggingClient , request : CliRequest ): self . _container_repository = container_repository self . _plugin_client = plugin_client self . _logging_client = logging_client self . _request = request self . _plugins = {} self . _callbacks = {}","title":"SeagullsCliApplication()"},{"location":"api/seagulls-space-shooter-demo/seagulls/seagulls_cli/#execute","text":"def execute ( self ) -> None : View Source def execute ( self ) -> None : self . _plugin_client . register_plugins ( self ) self . trigger_event ( PostPluginRegistrationEvent ()) self . _request . execute ( event_dispatcher = self )","title":"execute()"},{"location":"api/seagulls-space-shooter-demo/seagulls/seagulls_cli/#register_container","text":"def register_container ( self , key : Type [ ~ ObjectType ], container : ~ ObjectType ) -> None : View Source def register_container ( self , key : Type [ ObjectType ], container : ObjectType ) -> None : self . _container_repository . register ( key , container )","title":"register_container()"},{"location":"api/seagulls-space-shooter-demo/seagulls/seagulls_cli/#get_container","text":"def get_container ( self , key : Type [ ~ ObjectType ]) -> ~ ObjectType : View Source def get_container ( self , key : Type [ ObjectType ]) -> ObjectType : return self . _container_repository . get ( key )","title":"get_container()"},{"location":"api/seagulls-space-shooter-demo/seagulls/seagulls_cli/#register_callback","text":"def register_callback ( self , event_type : Type [ ~ EventType ], callback : Callable [[ ~ EventType ], NoneType ] ) -> None : View Source def register_callback ( self , event_type : Type [ EventType ], callback : EventCallbackType ) -> None : if event_type not in self . _callbacks : self . _callbacks [ event_type ] = [] self . _callbacks [ event_type ] . append ( callback )","title":"register_callback()"},{"location":"api/seagulls-space-shooter-demo/seagulls/seagulls_cli/#trigger_event","text":"def trigger_event ( self , event : ~ EventType ) -> None : View Source def trigger_event ( self , event : EventType ) -> None : for callback in self . _callbacks . get ( type ( event ), []): callback ( event )","title":"trigger_event()"},{"location":"api/seagulls-space-shooter-demo/seagulls/seagulls_cli/#register_plugin","text":"def register_plugin ( self , plugin : seagulls . app . _plugin_interfaces . ISeagullsApplicationPlugin ) -> None : View Source def register_plugin ( self , plugin : ISeagullsApplicationPlugin ) -> None : if type ( plugin ) in self . _plugins : raise DuplicatePluginError ( plugin ) self . _plugins [ type ( plugin )] = plugin plugin . on_registration ()","title":"register_plugin()"},{"location":"api/seagulls-space-shooter-demo/seagulls/seagulls_cli/#get_plugin","text":"@lru_cache () def get_plugin ( self , plugin_type : Type [ ~ PluginType ]) -> ~ PluginType : View Source @lru_cache () def get_plugin ( self , plugin_type : Type [ PluginType ]) -> PluginType : # type: ignore return self . _plugins [ plugin_type ]","title":"get_plugin()"},{"location":"api/seagulls-space-shooter-demo/seagulls/seagulls_cli/#main","text":"def main (): View Source def main (): di_container = SeagullsAppDiContainer () app = di_container . application () app . execute ()","title":"main()"}]}