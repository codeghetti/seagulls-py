{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 Coming Soon!","title":"Home"},{"location":"#home","text":"Coming Soon!","title":"Home"},{"location":"api/seagulls/","text":"seagulls \u00b6 The Seagulls Game Engine. View Source \"\"\" The Seagulls Game Engine. \"\"\"","title":"Seagulls"},{"location":"api/seagulls/#seagulls","text":"The Seagulls Game Engine. View Source \"\"\" The Seagulls Game Engine. \"\"\"","title":"seagulls"},{"location":"api/seagulls/assets/","text":"seagulls .assets \u00b6 View Source from ._manager import AssetManager __all__ = [ \"AssetManager\" ] AssetManager \u00b6 class ` AssetManager ` : Provides basic functionality for loading assets from disk. View Source class AssetManager : \"\"\"Provides basic functionality for loading assets from disk.\"\"\" _assets_path : Path def __init__ ( self , assets_path : Path ): self . _assets_path = assets_path def load_sprite ( self , name : str ) -> Surface : return self . load_png ( f \"sprites/ { name } \" ) def load_png ( self , name : str ) -> Surface : path = self . _assets_path / f \" { name } .png\" loaded_sprite = load ( path . resolve ()) if loaded_sprite . get_alpha () is None : return loaded_sprite . convert () else : return loaded_sprite . convert_alpha () AssetManager ( assets_path : pathlib . Path ): View Source def __init__ ( self , assets_path : Path ): self . _assets_path = assets_path def load_sprite ( self , name : str ) -> pygame . Surface : View Source def load_sprite ( self , name : str ) -> Surface : return self . load_png ( f \"sprites/ { name } \" ) def load_png ( self , name : str ) -> pygame . Surface : View Source def load_png ( self , name : str ) -> Surface : path = self . _assets_path / f \" { name } .png\" loaded_sprite = load ( path . resolve ()) if loaded_sprite . get_alpha () is None : return loaded_sprite . convert () else : return loaded_sprite . convert_alpha ()","title":"Assets"},{"location":"api/seagulls/assets/#seagullsassets","text":"View Source from ._manager import AssetManager __all__ = [ \"AssetManager\" ]","title":"seagulls.assets"},{"location":"api/seagulls/assets/#assetmanager","text":"class ` AssetManager ` : Provides basic functionality for loading assets from disk. View Source class AssetManager : \"\"\"Provides basic functionality for loading assets from disk.\"\"\" _assets_path : Path def __init__ ( self , assets_path : Path ): self . _assets_path = assets_path def load_sprite ( self , name : str ) -> Surface : return self . load_png ( f \"sprites/ { name } \" ) def load_png ( self , name : str ) -> Surface : path = self . _assets_path / f \" { name } .png\" loaded_sprite = load ( path . resolve ()) if loaded_sprite . get_alpha () is None : return loaded_sprite . convert () else : return loaded_sprite . convert_alpha () AssetManager ( assets_path : pathlib . Path ): View Source def __init__ ( self , assets_path : Path ): self . _assets_path = assets_path def load_sprite ( self , name : str ) -> pygame . Surface : View Source def load_sprite ( self , name : str ) -> Surface : return self . load_png ( f \"sprites/ { name } \" ) def load_png ( self , name : str ) -> pygame . Surface : View Source def load_png ( self , name : str ) -> Surface : path = self . _assets_path / f \" { name } .png\" loaded_sprite = load ( path . resolve ()) if loaded_sprite . get_alpha () is None : return loaded_sprite . convert () else : return loaded_sprite . convert_alpha ()","title":"AssetManager"},{"location":"api/seagulls/cli/","text":"seagulls .cli \u00b6 View Source from ._main import main from ._next import cli_next __all__ = [ \"main\" , \"cli_next\" , ] main \u00b6 def main (): View Source def main (): # Got tired of running into exceptions when this isn't initialized in time. pygame . init () logging_verbosity = int ( os . environ . get ( \"VERBOSITY\" , \"3\" )) if \"DEBUG\" in os . environ : logging_verbosity = 100 # 100 is higher than any log level we will ever have di_container = SeagullsDiContainer ( _logging_verbosity = logging_verbosity ) logging_client = di_container . logging_client () logging_client . configure_logging () root_command = di_container . root_command () # Build the CLI Command Interface parser = ArgumentParser ( description = root_command . get_command_help (), ) parser . set_defaults ( cmd = root_command ) parser . set_defaults ( parser = parser ) root_command . configure_parser ( parser ) sub_commands = parser . add_subparsers ( title = \"subcommands\" , metavar = None , help = \"\" ) for provider in di_container . traverse (): provided = provider . provides try : is_command = issubclass ( provided , CliCommand ) except TypeError : continue if not is_command : continue logger . info ( f \"Initializing CliCommand: { provided } \" ) cmd : CliCommand = provider () subparser = sub_commands . add_parser ( name = cmd . get_command_name (), help = cmd . get_command_help (), ) cmd . configure_parser ( subparser ) subparser . set_defaults ( cmd = cmd ) args = parser . parse_args ( sys . argv [ 1 :]) matched_cmd : CliCommand = args . cmd matched_cmd . execute ( vars ( args )) cli_next \u00b6 def cli_next (): View Source def cli_next (): # Got tired of running into exceptions when this isn't initialized in time. pygame . init () logging_verbosity = int ( os . environ . get ( \"VERBOSITY\" , \"3\" )) if \"DEBUG\" in os . environ : logging_verbosity = 100 # 100 is higher than any log level we will ever have di_container = SeagullsDiContainer ( _logging_verbosity = logging_verbosity ) logging_client = di_container . logging_client () logging_client . configure_logging () root_command = di_container . root_command () # # Build the CLI Command Interface # parser = ArgumentParser( # description=root_command.get_command_help(), # ) # parser.set_defaults(cmd=root_command) # parser.set_defaults(parser=parser) # # root_command.configure_parser(parser) # # sub_commands = parser.add_subparsers(title=\"subcommands\", metavar=None, help=\"\") # # for provider in di_container.traverse(): # provided = provider.provides # try: # is_command = issubclass(provided, CliCommand) # except TypeError: # continue # # if not is_command: # continue # # logger.info(f\"Initializing CliCommand: {provided}\") # cmd: CliCommand = provider() # subparser = sub_commands.add_parser( # name=cmd.get_command_name(), # help=cmd.get_command_help(), # ) # cmd.configure_parser(subparser) # subparser.set_defaults(cmd=cmd) # # args = parser.parse_args(sys.argv[1:]) # matched_cmd: CliCommand = args.cmd # matched_cmd.execute(vars(args))","title":"Cli"},{"location":"api/seagulls/cli/#seagullscli","text":"View Source from ._main import main from ._next import cli_next __all__ = [ \"main\" , \"cli_next\" , ]","title":"seagulls.cli"},{"location":"api/seagulls/cli/#main","text":"def main (): View Source def main (): # Got tired of running into exceptions when this isn't initialized in time. pygame . init () logging_verbosity = int ( os . environ . get ( \"VERBOSITY\" , \"3\" )) if \"DEBUG\" in os . environ : logging_verbosity = 100 # 100 is higher than any log level we will ever have di_container = SeagullsDiContainer ( _logging_verbosity = logging_verbosity ) logging_client = di_container . logging_client () logging_client . configure_logging () root_command = di_container . root_command () # Build the CLI Command Interface parser = ArgumentParser ( description = root_command . get_command_help (), ) parser . set_defaults ( cmd = root_command ) parser . set_defaults ( parser = parser ) root_command . configure_parser ( parser ) sub_commands = parser . add_subparsers ( title = \"subcommands\" , metavar = None , help = \"\" ) for provider in di_container . traverse (): provided = provider . provides try : is_command = issubclass ( provided , CliCommand ) except TypeError : continue if not is_command : continue logger . info ( f \"Initializing CliCommand: { provided } \" ) cmd : CliCommand = provider () subparser = sub_commands . add_parser ( name = cmd . get_command_name (), help = cmd . get_command_help (), ) cmd . configure_parser ( subparser ) subparser . set_defaults ( cmd = cmd ) args = parser . parse_args ( sys . argv [ 1 :]) matched_cmd : CliCommand = args . cmd matched_cmd . execute ( vars ( args ))","title":"main"},{"location":"api/seagulls/cli/#cli_next","text":"def cli_next (): View Source def cli_next (): # Got tired of running into exceptions when this isn't initialized in time. pygame . init () logging_verbosity = int ( os . environ . get ( \"VERBOSITY\" , \"3\" )) if \"DEBUG\" in os . environ : logging_verbosity = 100 # 100 is higher than any log level we will ever have di_container = SeagullsDiContainer ( _logging_verbosity = logging_verbosity ) logging_client = di_container . logging_client () logging_client . configure_logging () root_command = di_container . root_command () # # Build the CLI Command Interface # parser = ArgumentParser( # description=root_command.get_command_help(), # ) # parser.set_defaults(cmd=root_command) # parser.set_defaults(parser=parser) # # root_command.configure_parser(parser) # # sub_commands = parser.add_subparsers(title=\"subcommands\", metavar=None, help=\"\") # # for provider in di_container.traverse(): # provided = provider.provides # try: # is_command = issubclass(provided, CliCommand) # except TypeError: # continue # # if not is_command: # continue # # logger.info(f\"Initializing CliCommand: {provided}\") # cmd: CliCommand = provider() # subparser = sub_commands.add_parser( # name=cmd.get_command_name(), # help=cmd.get_command_help(), # ) # cmd.configure_parser(subparser) # subparser.set_defaults(cmd=cmd) # # args = parser.parse_args(sys.argv[1:]) # matched_cmd: CliCommand = args.cmd # matched_cmd.execute(vars(args))","title":"cli_next"},{"location":"api/seagulls/debug/","text":"seagulls .debug \u00b6 Debug Tooling. View Source \"\"\" Debug Tooling. \"\"\" from ._debug_hud import DebugHud __all__ = [ \"DebugHud\" , ] DebugHud \u00b6 class ` DebugHud ` ( seagulls . engine . _game_object . GameObject ): UI Component to display FPS and other debug information during gameplay. View Source class DebugHud ( GameObject ): \"\"\" UI Component to display FPS and other debug information during gameplay. \"\"\" _game_clock : GameClock def __init__ ( self , game_clock : GameClock ): \"\"\" Initializes a Debug Hud where `game_clock` controls how we measure time. \"\"\" self . _game_clock = game_clock self . _background = Surface (( 1024 , 20 )) self . _background . fill (( 100 , 100 , 100 )) self . _background . set_alpha ( 100 ) self . _font = Font ( Path ( \"assets/fonts/ubuntu-mono-v10-latin-regular.ttf\" ), 14 ) def tick ( self ) -> None : \"\"\" Does nothing because Debug Huds do not need to perform any logic on tick(). \"\"\" pass def render ( self , surface : Surface ) -> None : \"\"\" Renders the debug information onto the passed in Surface object. \"\"\" fps = str ( int ( self . _game_clock . get_fps ())) . rjust ( 3 , \" \" ) time = self . _game_clock . get_time () img = self . _font . render ( f \"FPS: { fps } | MS: { time } \" , True , ( 20 , 20 , 20 ) ) text_height = img . get_height () padding = ( self . _background . get_height () - text_height ) / 2 surface . blit ( self . _background , ( 0 , 0 )) surface . blit ( img , ( 10 , padding )) DebugHud ( game_clock : seagulls . engine . _game_clock . GameClock ): Initializes a Debug Hud where game_clock controls how we measure time. View Source def __init__ ( self , game_clock : GameClock ): \"\"\" Initializes a Debug Hud where `game_clock` controls how we measure time. \"\"\" self . _game_clock = game_clock self . _background = Surface (( 1024 , 20 )) self . _background . fill (( 100 , 100 , 100 )) self . _background . set_alpha ( 100 ) self . _font = Font ( Path ( \"assets/fonts/ubuntu-mono-v10-latin-regular.ttf\" ), 14 ) def tick ( self ) -> None : Does nothing because Debug Huds do not need to perform any logic on tick(). View Source def tick ( self ) -> None : \"\"\" Does nothing because Debug Huds do not need to perform any logic on tick(). \"\"\" pass def render ( self , surface : pygame . Surface ) -> None : Renders the debug information onto the passed in Surface object. View Source def render ( self , surface : Surface ) -> None : \"\"\" Renders the debug information onto the passed in Surface object. \"\"\" fps = str ( int ( self . _game_clock . get_fps ())) . rjust ( 3 , \" \" ) time = self . _game_clock . get_time () img = self . _font . render ( f \"FPS: { fps } | MS: { time } \" , True , ( 20 , 20 , 20 ) ) text_height = img . get_height () padding = ( self . _background . get_height () - text_height ) / 2 surface . blit ( self . _background , ( 0 , 0 )) surface . blit ( img , ( 10 , padding ))","title":"Debug"},{"location":"api/seagulls/debug/#seagullsdebug","text":"Debug Tooling. View Source \"\"\" Debug Tooling. \"\"\" from ._debug_hud import DebugHud __all__ = [ \"DebugHud\" , ]","title":"seagulls.debug"},{"location":"api/seagulls/debug/#debughud","text":"class ` DebugHud ` ( seagulls . engine . _game_object . GameObject ): UI Component to display FPS and other debug information during gameplay. View Source class DebugHud ( GameObject ): \"\"\" UI Component to display FPS and other debug information during gameplay. \"\"\" _game_clock : GameClock def __init__ ( self , game_clock : GameClock ): \"\"\" Initializes a Debug Hud where `game_clock` controls how we measure time. \"\"\" self . _game_clock = game_clock self . _background = Surface (( 1024 , 20 )) self . _background . fill (( 100 , 100 , 100 )) self . _background . set_alpha ( 100 ) self . _font = Font ( Path ( \"assets/fonts/ubuntu-mono-v10-latin-regular.ttf\" ), 14 ) def tick ( self ) -> None : \"\"\" Does nothing because Debug Huds do not need to perform any logic on tick(). \"\"\" pass def render ( self , surface : Surface ) -> None : \"\"\" Renders the debug information onto the passed in Surface object. \"\"\" fps = str ( int ( self . _game_clock . get_fps ())) . rjust ( 3 , \" \" ) time = self . _game_clock . get_time () img = self . _font . render ( f \"FPS: { fps } | MS: { time } \" , True , ( 20 , 20 , 20 ) ) text_height = img . get_height () padding = ( self . _background . get_height () - text_height ) / 2 surface . blit ( self . _background , ( 0 , 0 )) surface . blit ( img , ( 10 , padding )) DebugHud ( game_clock : seagulls . engine . _game_clock . GameClock ): Initializes a Debug Hud where game_clock controls how we measure time. View Source def __init__ ( self , game_clock : GameClock ): \"\"\" Initializes a Debug Hud where `game_clock` controls how we measure time. \"\"\" self . _game_clock = game_clock self . _background = Surface (( 1024 , 20 )) self . _background . fill (( 100 , 100 , 100 )) self . _background . set_alpha ( 100 ) self . _font = Font ( Path ( \"assets/fonts/ubuntu-mono-v10-latin-regular.ttf\" ), 14 ) def tick ( self ) -> None : Does nothing because Debug Huds do not need to perform any logic on tick(). View Source def tick ( self ) -> None : \"\"\" Does nothing because Debug Huds do not need to perform any logic on tick(). \"\"\" pass def render ( self , surface : pygame . Surface ) -> None : Renders the debug information onto the passed in Surface object. View Source def render ( self , surface : Surface ) -> None : \"\"\" Renders the debug information onto the passed in Surface object. \"\"\" fps = str ( int ( self . _game_clock . get_fps ())) . rjust ( 3 , \" \" ) time = self . _game_clock . get_time () img = self . _font . render ( f \"FPS: { fps } | MS: { time } \" , True , ( 20 , 20 , 20 ) ) text_height = img . get_height () padding = ( self . _background . get_height () - text_height ) / 2 surface . blit ( self . _background , ( 0 , 0 )) surface . blit ( img , ( 10 , padding ))","title":"DebugHud"},{"location":"api/seagulls/engine/","text":"seagulls .engine \u00b6 Core Engine Components View Source \"\"\"Core Engine Components\"\"\" from ._collisions import CollidableObject , flag_from_string from ._game_clock import GameClock from ._game_controls import GameControls from ._game_object import GameObject , GameObjectsCollection from ._game_scene import IGameScene from ._game_scene_manager import IProvideGameScenes from ._game_session import IGameSession from ._game_session_manager import IProvideGameSessions from ._game_settings import GameSettings from ._pyagme import Color , PixelArray , Rect , Surface , Vector2 , Vector3 from ._surface_renderer import SurfaceRenderer __all__ = [ \"flag_from_string\" , \"CollidableObject\" , \"IGameScene\" , \"IProvideGameScenes\" , \"IProvideGameSessions\" , \"IGameSession\" , \"SurfaceRenderer\" , \"GameClock\" , \"GameControls\" , \"GameObject\" , \"GameObjectsCollection\" , \"GameSettings\" , \"Rect\" , \"Surface\" , \"Color\" , \"PixelArray\" , \"Vector2\" , \"Vector3\" , ] flag_from_string \u00b6 def flag_from_string ( value : str ) -> int : View Source def flag_from_string ( value : str ) -> int : if not isinstance ( value , str ): raise ValueError ( f \"Value must be a string of 0s and 1s: { value } \" ) return int ( value , 2 ) CollidableObject \u00b6 @dataclass ( frozen = True ) class ` CollidableObject ` : CollidableObject(layer: int, mask: int) View Source @dataclass ( frozen = True ) class CollidableObject : layer : int mask : int def filter_by_mask ( self , targets : Tuple [ \"CollidableObject\" , ... ]) -> Tuple [ \"CollidableObject\" , ... ]: result = [] for t in targets : if self . is_in_mask ( t ): result . append ( t ) return tuple ( result ) def is_in_mask ( self , target : \"CollidableObject\" ) -> bool : logger . debug ( f \"targeting items located in mask: { self . mask : b } \" ) logger . debug ( f \"target is located in layer: { target . layer : b } \" ) logger . debug ( f \"& result: { self . mask & target . layer : b } \" ) return self . mask & target . layer > 0 def __repr__ ( self ) -> str : return f \" { self . __class__ . __name__ } (layer= { self . layer : b } , mask= { self . mask : b } )\" CollidableObject ( layer : int , mask : int ): def filter_by_mask ( self , targets : Tuple [ seagulls . engine . _collisions . CollidableObject , ... ] ) -> Tuple [ seagulls . engine . _collisions . CollidableObject , ... ]: View Source def filter_by_mask ( self , targets : Tuple [ \"CollidableObject\" , ... ]) -> Tuple [ \"CollidableObject\" , ... ]: result = [] for t in targets : if self . is_in_mask ( t ): result . append ( t ) return tuple ( result ) def is_in_mask ( self , target : seagulls . engine . _collisions . CollidableObject ) -> bool : View Source def is_in_mask ( self , target : \"CollidableObject\" ) -> bool : logger . debug ( f \"targeting items located in mask: { self . mask : b } \" ) logger . debug ( f \"target is located in layer: { target . layer : b } \" ) logger . debug ( f \"& result: { self . mask & target . layer : b } \" ) return self . mask & target . layer > 0 IGameScene \u00b6 class ` IGameScene ` ( abc . ABC ): This class is for X and Y. View Source class IGameScene ( ABC ): \"\"\" This class is for X and Y. \"\"\" @abstractmethod def start ( self ) -> None : pass @abstractmethod def should_quit ( self ) -> bool : pass @abstractmethod def tick ( self ) -> None : pass @abstractmethod def start ( self ) -> None : View Source @abstractmethod def start ( self ) -> None : pass @abstractmethod def should_quit ( self ) -> bool : View Source @abstractmethod def should_quit ( self ) -> bool : pass @abstractmethod def tick ( self ) -> None : View Source @abstractmethod def tick ( self ) -> None : pass IProvideGameScenes \u00b6 class ` IProvideGameScenes ` ( abc . ABC ): Helper class that provides a standard way to create an ABC using inheritance. View Source class IProvideGameScenes ( ABC ): @abstractmethod def get_scene ( self ) -> IGameScene : pass @abstractmethod def get_scene ( self ) -> seagulls . engine . _game_scene . IGameScene : View Source @abstractmethod def get_scene ( self ) -> IGameScene : pass IProvideGameSessions \u00b6 class ` IProvideGameSessions ` ( abc . ABC ): Helper class that provides a standard way to create an ABC using inheritance. View Source class IProvideGameSessions ( ABC ): @abstractmethod def get_session ( self , scene : str ) -> IGameSession : pass @abstractmethod def get_session ( self , scene : str ) -> seagulls . engine . _game_session . IGameSession : View Source @abstractmethod def get_session ( self , scene : str ) -> IGameSession : pass IGameSession \u00b6 class ` IGameSession ` ( abc . ABC ): Helper class that provides a standard way to create an ABC using inheritance. View Source class IGameSession ( ABC ): @abstractmethod def start ( self ) -> None : pass @abstractmethod def wait_for_completion ( self ) -> None : pass @abstractmethod def stop ( self ) -> None : pass @abstractmethod def start ( self ) -> None : View Source @abstractmethod def start ( self ) -> None : pass @abstractmethod def wait_for_completion ( self ) -> None : View Source @abstractmethod def wait_for_completion ( self ) -> None : pass @abstractmethod def stop ( self ) -> None : View Source @abstractmethod def stop ( self ) -> None : pass SurfaceRenderer \u00b6 class ` SurfaceRenderer ` : View Source class SurfaceRenderer : def start ( self ) -> None : self . _get_surface () def render ( self , surface : Surface ) -> None : self . _get_surface () . blit ( surface , ( 0 , 0 )) pygame . display . flip () @lru_cache () def _get_surface ( self ) -> Surface : return pygame . display . set_mode (( 1024 , 600 )) SurfaceRenderer (): def start ( self ) -> None : View Source def start ( self ) -> None : self . _get_surface () def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : Surface ) -> None : self . _get_surface () . blit ( surface , ( 0 , 0 )) pygame . display . flip () GameClock \u00b6 class ` GameClock ` ( seagulls . engine . _game_object . GameObject ): Interface for anything representing an object in the scene. View Source class GameClock ( GameObject ): _clock : Clock _ticks : int _delta : int def __init__ ( self ): self . _clock = Clock () self . _ticks = 0 self . _delta = 0 def tick ( self ) -> None : self . _delta = self . _clock . tick () def render ( self , surface : Surface ) -> None : pass def get_time ( self ) -> int : return self . _delta def get_fps ( self ) -> float : return self . _clock . get_fps () GameClock (): View Source def __init__ ( self ): self . _clock = Clock () self . _ticks = 0 self . _delta = 0 def tick ( self ) -> None : View Source def tick ( self ) -> None : self . _delta = self . _clock . tick () def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : Surface ) -> None : pass def get_time ( self ) -> int : View Source def get_time ( self ) -> int : return self . _delta def get_fps ( self ) -> float : View Source def get_fps ( self ) -> float : return self . _clock . get_fps () GameControls \u00b6 class ` GameControls ` ( seagulls . engine . _game_object . GameObject ): Interface for anything representing an object in the scene. View Source class GameControls ( GameObject ): _events : List [ Event ] def __init__ ( self ): self . _events = [] def tick ( self ): self . _events = pygame . event . get () def should_quit ( self ) -> bool : for event in self . _events : if event . type == pygame . QUIT : return True if self . _is_key_down_event ( event , pygame . K_ESCAPE ): return True return False def should_fire ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_SPACE ): return True return False def is_left_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_LEFT ] def is_right_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_RIGHT ] def should_toggle_debug_hud ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_BACKQUOTE ): return True return False def is_click_initialized ( self ) -> bool : for event in self . _events : if not event . type == pygame . MOUSEBUTTONDOWN : continue return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] return False def is_mouse_down ( self ) -> bool : return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] def _is_key_down_event ( self , event : Event , key : int ) -> bool : return event . type == pygame . KEYDOWN and event . key == key def _is_key_up_event ( self , event : Event , key : int ) -> bool : return event . type == pygame . KEYUP and event . key == key def render ( self , surface : pygame . Surface ) -> None : pass GameControls (): View Source def __init__ ( self ): self . _events = [] def tick ( self ): View Source def tick ( self ): self . _events = pygame . event . get () def should_quit ( self ) -> bool : View Source def should_quit ( self ) -> bool : for event in self . _events : if event . type == pygame . QUIT : return True if self . _is_key_down_event ( event , pygame . K_ESCAPE ): return True return False def should_fire ( self ) -> bool : View Source def should_fire ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_SPACE ): return True return False def is_left_moving ( self ) -> bool : View Source def is_left_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_LEFT ] def is_right_moving ( self ) -> bool : View Source def is_right_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_RIGHT ] def should_toggle_debug_hud ( self ) -> bool : View Source def should_toggle_debug_hud ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_BACKQUOTE ): return True return False def is_click_initialized ( self ) -> bool : View Source def is_click_initialized ( self ) -> bool : for event in self . _events : if not event . type == pygame . MOUSEBUTTONDOWN : continue return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] return False def is_mouse_down ( self ) -> bool : View Source def is_mouse_down ( self ) -> bool : return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : pygame . Surface ) -> None : pass GameObject \u00b6 class ` GameObject ` ( abc . ABC ): Interface for anything representing an object in the scene. View Source class GameObject ( ABC ): \"\"\" Interface for anything representing an object in the scene. \"\"\" @abstractmethod def tick ( self ) -> None : pass @abstractmethod def render ( self , surface : Surface ) -> None : pass @abstractmethod def tick ( self ) -> None : View Source @abstractmethod def tick ( self ) -> None : pass @abstractmethod def render ( self , surface : pygame . Surface ) -> None : View Source @abstractmethod def render ( self , surface : Surface ) -> None : pass GameObjectsCollection \u00b6 class ` GameObjectsCollection ` : Data structure that allows you to keep track of objects in the scene. View Source class GameObjectsCollection : \"\"\" Data structure that allows you to keep track of objects in the scene. \"\"\" _game_objects : List [ GameObject ] def __init__ ( self ) -> None : self . _game_objects = [] def add ( self , game_object : GameObject ) -> None : self . _game_objects . append ( game_object ) def apply ( self , func : Callable [[ GameObject ], None ]) -> None : for game_object in self . _game_objects : func ( game_object ) GameObjectsCollection (): View Source def __init__ ( self ) -> None : self . _game_objects = [] def add ( self , game_object : seagulls . engine . _game_object . GameObject ) -> None : View Source def add ( self , game_object : GameObject ) -> None : self . _game_objects . append ( game_object ) def apply ( self , func : Callable [[ seagulls . engine . _game_object . GameObject ], NoneType ] ) -> None : View Source def apply ( self , func : Callable [[ GameObject ], None ]) -> None : for game_object in self . _game_objects : func ( game_object ) GameSettings \u00b6 class ` GameSettings ` : View Source class GameSettings : def get_setting ( self , name , default = None ) -> Any : data = self . _load_yaml () return data . get ( name , default ) @lru_cache () def _load_yaml ( self ) -> Dict [ str , Any ]: file = Path . home () / \".config/seagulls.yaml\" if not file . exists (): file . touch () return yaml . safe_load ( file . read_text ()) or {} GameSettings (): def get_setting ( self , name , default = None ) -> Any : View Source def get_setting ( self , name , default = None ) -> Any : data = self . _load_yaml () return data . get ( name , default ) Rect \u00b6 class ` Rect ` : Rect(left, top, width, height) -> Rect Rect((left, top), (width, height)) -> Rect Rect(object) -> Rect pygame object for storing rectangular coordinates Rect ( * args , ** kwargs ): def normalize ( unknown ): normalize() -> None correct negative sizes def clip ( unknown ): clip(Rect) -> Rect crops a rectangle inside another def clipline ( unknown ): clipline(x1, y1, x2, y2) -> ((cx1, cy1), (cx2, cy2)) clipline(x1, y1, x2, y2) -> () clipline((x1, y1), (x2, y2)) -> ((cx1, cy1), (cx2, cy2)) clipline((x1, y1), (x2, y2)) -> () clipline((x1, y1, x2, y2)) -> ((cx1, cy1), (cx2, cy2)) clipline((x1, y1, x2, y2)) -> () clipline(((x1, y1), (x2, y2))) -> ((cx1, cy1), (cx2, cy2)) clipline(((x1, y1), (x2, y2))) -> () crops a line inside a rectangle def clamp ( unknown ): clamp(Rect) -> Rect moves the rectangle inside another def clamp_ip ( unknown ): clamp_ip(Rect) -> None moves the rectangle inside another, in place def copy ( unknown ): copy() -> Rect copy the rectangle def fit ( unknown ): fit(Rect) -> Rect resize and move a rectangle with aspect ratio def move ( unknown ): move(x, y) -> Rect moves the rectangle def update ( unknown ): update(left, top, width, height) -> None update((left, top), (width, height)) -> None update(object) -> None sets the position and size of the rectangle def inflate ( unknown ): inflate(x, y) -> Rect grow or shrink the rectangle size def union ( unknown ): union(Rect) -> Rect joins two rectangles into one def unionall ( unknown ): unionall(Rect_sequence) -> Rect the union of many rectangles def move_ip ( unknown ): move_ip(x, y) -> None moves the rectangle, in place def inflate_ip ( unknown ): inflate_ip(x, y) -> None grow or shrink the rectangle size, in place def union_ip ( unknown ): union_ip(Rect) -> None joins two rectangles into one, in place def unionall_ip ( unknown ): unionall_ip(Rect_sequence) -> None the union of many rectangles, in place def collidepoint ( unknown ): collidepoint(x, y) -> bool collidepoint((x,y)) -> bool test if a point is inside a rectangle def colliderect ( unknown ): colliderect(Rect) -> bool test if two rectangles overlap def collidelist ( unknown ): collidelist(list) -> index test if one rectangle in a list intersects def collidelistall ( unknown ): collidelistall(list) -> indices test if all rectangles in a list intersect def collidedict ( unknown ): collidedict(dict) -> (key, value) collidedict(dict) -> None collidedict(dict, use_values=0) -> (key, value) collidedict(dict, use_values=0) -> None test if one rectangle in a dictionary intersects def collidedictall ( unknown ): collidedictall(dict) -> [(key, value), ...] collidedictall(dict, use_values=0) -> [(key, value), ...] test if all rectangles in a dictionary intersect def contains ( unknown ): contains(Rect) -> bool test if one rectangle is inside another x y w h width height top left bottom right centerx centery topleft topright bottomleft bottomright midtop midleft midbottom midright size center Surface \u00b6 class ` Surface ` : Surface((width, height), flags=0, depth=0, masks=None) -> Surface Surface((width, height), flags=0, Surface) -> Surface pygame object for representing images Surface ( * args , ** kwargs ): def get_at ( unknown ): get_at((x, y)) -> Color get the color value at a single pixel def set_at ( unknown ): set_at((x, y), Color) -> None set the color value for a single pixel def get_at_mapped ( unknown ): get_at_mapped((x, y)) -> Color get the mapped color value at a single pixel def map_rgb ( unknown ): map_rgb(Color) -> mapped_int convert a color into a mapped color value def unmap_rgb ( unknown ): unmap_rgb(mapped_int) -> Color convert a mapped integer color value into a Color def get_palette ( unknown ): get_palette() -> [RGB, RGB, RGB, ...] get the color index palette for an 8-bit Surface def get_palette_at ( unknown ): get_palette_at(index) -> RGB get the color for a single entry in a palette def set_palette ( unknown ): set_palette([RGB, RGB, RGB, ...]) -> None set the color palette for an 8-bit Surface def set_palette_at ( unknown ): set_palette_at(index, RGB) -> None set the color for a single index in an 8-bit Surface palette def lock ( unknown ): lock() -> None lock the Surface memory for pixel access def unlock ( unknown ): unlock() -> None unlock the Surface memory from pixel access def mustlock ( unknown ): mustlock() -> bool test if the Surface requires locking def get_locked ( unknown ): get_locked() -> bool test if the Surface is current locked def get_locks ( unknown ): get_locks() -> tuple Gets the locks for the Surface def set_colorkey ( unknown ): set_colorkey(Color, flags=0) -> None set_colorkey(None) -> None Set the transparent colorkey def get_colorkey ( unknown ): get_colorkey() -> RGB or None Get the current transparent colorkey def set_alpha ( unknown ): set_alpha(value, flags=0) -> None set_alpha(None) -> None set the alpha value for the full Surface image def get_alpha ( unknown ): get_alpha() -> int_value get the current Surface transparency value def get_blendmode ( unknown ): Return the surface's SDL 2 blend mode def copy ( unknown ): copy() -> Surface create a new copy of a Surface def convert ( unknown ): convert(Surface=None) -> Surface convert(depth, flags=0) -> Surface convert(masks, flags=0) -> Surface change the pixel format of an image def convert_alpha ( unknown ): convert_alpha(Surface) -> Surface convert_alpha() -> Surface change the pixel format of an image including per pixel alphas def set_clip ( unknown ): set_clip(rect) -> None set_clip(None) -> None set the current clipping area of the Surface def get_clip ( unknown ): get_clip() -> Rect get the current clipping area of the Surface def fill ( unknown ): fill(color, rect=None, special_flags=0) -> Rect fill Surface with a solid color def blit ( unknown ): blit(source, dest, area=None, special_flags=0) -> Rect draw one image onto another def blits ( unknown ): blits(blit_sequence=((source, dest), ...), doreturn=1) -> [Rect, ...] or None blits(((source, dest, area), ...)) -> [Rect, ...] blits(((source, dest, area, special_flags), ...)) -> [Rect, ...] draw many images onto another def scroll ( unknown ): scroll(dx=0, dy=0) -> None Shift the surface image in place def get_flags ( unknown ): get_flags() -> int get the additional flags used for the Surface def get_size ( unknown ): get_size() -> (width, height) get the dimensions of the Surface def get_width ( unknown ): get_width() -> width get the width of the Surface def get_height ( unknown ): get_height() -> height get the height of the Surface def get_rect ( unknown ): get_rect(**kwargs) -> Rect get the rectangular area of the Surface def get_pitch ( unknown ): get_pitch() -> int get the number of bytes used per Surface row def get_bitsize ( unknown ): get_bitsize() -> int get the bit depth of the Surface pixel format def get_bytesize ( unknown ): get_bytesize() -> int get the bytes used per Surface pixel def get_masks ( unknown ): get_masks() -> (R, G, B, A) the bitmasks needed to convert between a color and a mapped integer def get_shifts ( unknown ): get_shifts() -> (R, G, B, A) the bit shifts needed to convert between a color and a mapped integer def set_masks ( unknown ): set_masks((r,g,b,a)) -> None set the bitmasks needed to convert between a color and a mapped integer def set_shifts ( unknown ): set_shifts((r,g,b,a)) -> None sets the bit shifts needed to convert between a color and a mapped integer def get_losses ( unknown ): get_losses() -> (R, G, B, A) the significant bits used to convert between a color and a mapped integer def subsurface ( unknown ): subsurface(Rect) -> Surface create a new surface that references its parent def get_offset ( unknown ): get_offset() -> (x, y) find the position of a child subsurface inside a parent def get_abs_offset ( unknown ): get_abs_offset() -> (x, y) find the absolute position of a child subsurface inside its top level parent def get_parent ( unknown ): get_parent() -> Surface find the parent of a subsurface def get_abs_parent ( unknown ): get_abs_parent() -> Surface find the top level parent of a subsurface def get_bounding_rect ( unknown ): get_bounding_rect(min_alpha = 1) -> Rect find the smallest rect containing data def get_view ( unknown ): get_view(<kind>='2') -> BufferProxy return a buffer view of the Surface's pixels. def get_buffer ( unknown ): get_buffer() -> BufferProxy acquires a buffer object for the pixels of the Surface. Color \u00b6 class ` Color ` : Color(r, g, b) -> Color Color(r, g, b, a=255) -> Color Color(color_value) -> Color pygame object for color representations Color ( * args , ** kwargs ): def normalize ( unknown ): normalize() -> tuple Returns the normalized RGBA values of the Color. def correct_gamma ( unknown ): correct_gamma (gamma) -> Color Applies a certain gamma value to the Color. def set_length ( unknown ): set_length(len) -> None Set the number of elements in the Color to 1,2,3, or 4. def lerp ( unknown ): lerp(Color, float) -> Color returns a linear interpolation to the given Color. def premul_alpha ( unknown ): premul_alpha() -> Color returns a Color where the r,g,b components have been multiplied by the alpha. def update ( unknown ): update(r, g, b) -> None update(r, g, b, a=255) -> None update(color_value) -> None Sets the elements of the color r r -> int Gets or sets the red value of the Color. g g -> int Gets or sets the green value of the Color. b b -> int Gets or sets the blue value of the Color. a a -> int Gets or sets the alpha value of the Color. hsva hsva -> tuple Gets or sets the HSVA representation of the Color. hsla hsla -> tuple Gets or sets the HSLA representation of the Color. i1i2i3 i1i2i3 -> tuple Gets or sets the I1I2I3 representation of the Color. cmy cmy -> tuple Gets or sets the CMY representation of the Color. PixelArray \u00b6 class ` PixelArray ` : PixelArray(Surface) -> PixelArray pygame object for direct pixel access of surfaces PixelArray (): def compare ( unknown ): compare(array, distance=0, weights=(0.299, 0.587, 0.114)) -> PixelArray Compares the PixelArray with another one. def extract ( unknown ): extract(color, distance=0, weights=(0.299, 0.587, 0.114)) -> PixelArray Extracts the passed color from the PixelArray. def make_surface ( unknown ): make_surface() -> Surface Creates a new Surface from the current PixelArray. def close ( unknown ): transpose() -> PixelArray Closes the PixelArray, and releases Surface lock. def replace ( unknown ): replace(color, repcolor, distance=0, weights=(0.299, 0.587, 0.114)) -> None Replaces the passed color in the PixelArray with another one. def transpose ( unknown ): transpose() -> PixelArray Exchanges the x and y axis. surface surface -> Surface Gets the Surface the PixelArray uses. itemsize itemsize -> int Returns the byte size of a pixel array item shape shape -> tuple of int's Returns the array size. strides strides -> tuple of int's Returns byte offsets for each array dimension. ndim ndim -> int Returns the number of dimensions. Vector2 \u00b6 class ` Vector2 ` : Vector2() -> Vector2 Vector2(int) -> Vector2 Vector2(float) -> Vector2 Vector2(Vector2) -> Vector2 Vector2(x, y) -> Vector2 Vector2((x, y)) -> Vector2 a 2-Dimensional Vector Vector2 ( * args , ** kwargs ): def length ( unknown ): length() -> float returns the Euclidean length of the vector. def length_squared ( unknown ): length_squared() -> float returns the squared Euclidean length of the vector. def magnitude ( unknown ): magnitude() -> float returns the Euclidean magnitude of the vector. def magnitude_squared ( unknown ): magnitude_squared() -> float returns the squared magnitude of the vector. def rotate ( unknown ): rotate(angle) -> Vector2 rotates a vector by a given angle in degrees. def rotate_ip ( unknown ): rotate_ip(angle) -> None rotates the vector by a given angle in degrees in place. def rotate_rad ( unknown ): rotate_rad(angle) -> Vector2 rotates a vector by a given angle in radians. def rotate_ip_rad ( unknown ): rotate_ip_rad(angle) -> None rotates the vector by a given angle in radians in place. def slerp ( unknown ): slerp(Vector2, float) -> Vector2 returns a spherical interpolation to the given vector. def lerp ( unknown ): lerp(Vector2, float) -> Vector2 returns a linear interpolation to the given vector. def normalize ( unknown ): normalize() -> Vector2 returns a vector with the same direction but length 1. def normalize_ip ( unknown ): normalize_ip() -> None normalizes the vector in place so that its length is 1. def is_normalized ( unknown ): is_normalized() -> Bool tests if the vector is normalized i.e. has length == 1. def cross ( unknown ): cross(Vector2) -> Vector2 calculates the cross- or vector-product def dot ( unknown ): dot(Vector2) -> float calculates the dot- or scalar-product with the other vector def angle_to ( unknown ): angle_to(Vector2) -> float calculates the angle to a given vector in degrees. def update ( unknown ): update() -> None update(int) -> None update(float) -> None update(Vector2) -> None update(x, y) -> None update((x, y)) -> None Sets the coordinates of the vector. def scale_to_length ( unknown ): scale_to_length(float) -> None scales the vector to a given length. def reflect ( unknown ): reflect(Vector2) -> Vector2 returns a vector reflected of a given normal. def reflect_ip ( unknown ): reflect_ip(Vector2) -> None reflect the vector of a given normal in place. def distance_to ( unknown ): distance_to(Vector2) -> float calculates the Euclidean distance to a given vector. def distance_squared_to ( unknown ): distance_squared_to(Vector2) -> float calculates the squared Euclidean distance to a given vector. def elementwise ( unknown ): elementwise() -> VectorElementwiseProxy The next operation will be performed elementwise. def as_polar ( unknown ): as_polar() -> (r, phi) returns a tuple with radial distance and azimuthal angle. def from_polar ( unknown ): from_polar((r, phi)) -> None Sets x and y from a polar coordinates tuple. def project ( unknown ): project(Vector2) -> Vector2 projects a vector onto another. epsilon small value used in comparisons x y Vector3 \u00b6 class ` Vector3 ` : Vector3() -> Vector3 Vector3(int) -> Vector3 Vector3(float) -> Vector3 Vector3(Vector3) -> Vector3 Vector3(x, y, z) -> Vector3 Vector3((x, y, z)) -> Vector3 a 3-Dimensional Vector Vector3 ( * args , ** kwargs ): def length ( unknown ): length() -> float returns the Euclidean length of the vector. def length_squared ( unknown ): length_squared() -> float returns the squared Euclidean length of the vector. def magnitude ( unknown ): magnitude() -> float returns the Euclidean magnitude of the vector. def magnitude_squared ( unknown ): magnitude_squared() -> float returns the squared Euclidean magnitude of the vector. def rotate ( unknown ): rotate(angle, Vector3) -> Vector3 rotates a vector by a given angle in degrees. def rotate_ip ( unknown ): rotate_ip(angle, Vector3) -> None rotates the vector by a given angle in degrees in place. def rotate_rad ( unknown ): rotate_rad(angle, Vector3) -> Vector3 rotates a vector by a given angle in radians. def rotate_ip_rad ( unknown ): rotate_ip_rad(angle, Vector3) -> None rotates the vector by a given angle in radians in place. def rotate_x ( unknown ): rotate_x(angle) -> Vector3 rotates a vector around the x-axis by the angle in degrees. def rotate_x_ip ( unknown ): rotate_x_ip(angle) -> None rotates the vector around the x-axis by the angle in degrees in place. def rotate_x_rad ( unknown ): rotate_x_rad(angle) -> Vector3 rotates a vector around the x-axis by the angle in radians. def rotate_x_ip_rad ( unknown ): rotate_x_ip_rad(angle) -> None rotates the vector around the x-axis by the angle in radians in place. def rotate_y ( unknown ): rotate_y(angle) -> Vector3 rotates a vector around the y-axis by the angle in degrees. def rotate_y_ip ( unknown ): rotate_y_ip(angle) -> None rotates the vector around the y-axis by the angle in degrees in place. def rotate_y_rad ( unknown ): rotate_y_rad(angle) -> Vector3 rotates a vector around the y-axis by the angle in radians. def rotate_y_ip_rad ( unknown ): rotate_y_ip_rad(angle) -> None rotates the vector around the y-axis by the angle in radians in place. def rotate_z ( unknown ): rotate_z(angle) -> Vector3 rotates a vector around the z-axis by the angle in degrees. def rotate_z_ip ( unknown ): rotate_z_ip(angle) -> None rotates the vector around the z-axis by the angle in degrees in place. def rotate_z_rad ( unknown ): rotate_z_rad(angle) -> Vector3 rotates a vector around the z-axis by the angle in radians. def rotate_z_ip_rad ( unknown ): rotate_z_ip_rad(angle) -> None rotates the vector around the z-axis by the angle in radians in place. def slerp ( unknown ): slerp(Vector3, float) -> Vector3 returns a spherical interpolation to the given vector. def lerp ( unknown ): lerp(Vector3, float) -> Vector3 returns a linear interpolation to the given vector. def normalize ( unknown ): normalize() -> Vector3 returns a vector with the same direction but length 1. def normalize_ip ( unknown ): normalize_ip() -> None normalizes the vector in place so that its length is 1. def is_normalized ( unknown ): is_normalized() -> Bool tests if the vector is normalized i.e. has length == 1. def cross ( unknown ): cross(Vector3) -> Vector3 calculates the cross- or vector-product def dot ( unknown ): dot(Vector3) -> float calculates the dot- or scalar-product with the other vector def angle_to ( unknown ): angle_to(Vector3) -> float calculates the angle to a given vector in degrees. def update ( unknown ): update() -> None update(int) -> None update(float) -> None update(Vector3) -> None update(x, y, z) -> None update((x, y, z)) -> None Sets the coordinates of the vector. def scale_to_length ( unknown ): scale_to_length(float) -> None scales the vector to a given length. def reflect ( unknown ): reflect(Vector3) -> Vector3 returns a vector reflected of a given normal. def reflect_ip ( unknown ): reflect_ip(Vector3) -> None reflect the vector of a given normal in place. def distance_to ( unknown ): distance_to(Vector3) -> float calculates the Euclidean distance to a given vector. def distance_squared_to ( unknown ): distance_squared_to(Vector3) -> float calculates the squared Euclidean distance to a given vector. def elementwise ( unknown ): elementwise() -> VectorElementwiseProxy The next operation will be performed elementwise. def as_spherical ( unknown ): as_spherical() -> (r, theta, phi) returns a tuple with radial distance, inclination and azimuthal angle. def from_spherical ( unknown ): from_spherical((r, theta, phi)) -> None Sets x, y and z from a spherical coordinates 3-tuple. def project ( unknown ): project(Vector3) -> Vector3 projects a vector onto another. epsilon small value used in comparisons x y z","title":"Engine"},{"location":"api/seagulls/engine/#seagullsengine","text":"Core Engine Components View Source \"\"\"Core Engine Components\"\"\" from ._collisions import CollidableObject , flag_from_string from ._game_clock import GameClock from ._game_controls import GameControls from ._game_object import GameObject , GameObjectsCollection from ._game_scene import IGameScene from ._game_scene_manager import IProvideGameScenes from ._game_session import IGameSession from ._game_session_manager import IProvideGameSessions from ._game_settings import GameSettings from ._pyagme import Color , PixelArray , Rect , Surface , Vector2 , Vector3 from ._surface_renderer import SurfaceRenderer __all__ = [ \"flag_from_string\" , \"CollidableObject\" , \"IGameScene\" , \"IProvideGameScenes\" , \"IProvideGameSessions\" , \"IGameSession\" , \"SurfaceRenderer\" , \"GameClock\" , \"GameControls\" , \"GameObject\" , \"GameObjectsCollection\" , \"GameSettings\" , \"Rect\" , \"Surface\" , \"Color\" , \"PixelArray\" , \"Vector2\" , \"Vector3\" , ]","title":"seagulls.engine"},{"location":"api/seagulls/engine/#flag_from_string","text":"def flag_from_string ( value : str ) -> int : View Source def flag_from_string ( value : str ) -> int : if not isinstance ( value , str ): raise ValueError ( f \"Value must be a string of 0s and 1s: { value } \" ) return int ( value , 2 )","title":"flag_from_string"},{"location":"api/seagulls/engine/#collidableobject","text":"@dataclass ( frozen = True ) class ` CollidableObject ` : CollidableObject(layer: int, mask: int) View Source @dataclass ( frozen = True ) class CollidableObject : layer : int mask : int def filter_by_mask ( self , targets : Tuple [ \"CollidableObject\" , ... ]) -> Tuple [ \"CollidableObject\" , ... ]: result = [] for t in targets : if self . is_in_mask ( t ): result . append ( t ) return tuple ( result ) def is_in_mask ( self , target : \"CollidableObject\" ) -> bool : logger . debug ( f \"targeting items located in mask: { self . mask : b } \" ) logger . debug ( f \"target is located in layer: { target . layer : b } \" ) logger . debug ( f \"& result: { self . mask & target . layer : b } \" ) return self . mask & target . layer > 0 def __repr__ ( self ) -> str : return f \" { self . __class__ . __name__ } (layer= { self . layer : b } , mask= { self . mask : b } )\" CollidableObject ( layer : int , mask : int ): def filter_by_mask ( self , targets : Tuple [ seagulls . engine . _collisions . CollidableObject , ... ] ) -> Tuple [ seagulls . engine . _collisions . CollidableObject , ... ]: View Source def filter_by_mask ( self , targets : Tuple [ \"CollidableObject\" , ... ]) -> Tuple [ \"CollidableObject\" , ... ]: result = [] for t in targets : if self . is_in_mask ( t ): result . append ( t ) return tuple ( result ) def is_in_mask ( self , target : seagulls . engine . _collisions . CollidableObject ) -> bool : View Source def is_in_mask ( self , target : \"CollidableObject\" ) -> bool : logger . debug ( f \"targeting items located in mask: { self . mask : b } \" ) logger . debug ( f \"target is located in layer: { target . layer : b } \" ) logger . debug ( f \"& result: { self . mask & target . layer : b } \" ) return self . mask & target . layer > 0","title":"CollidableObject"},{"location":"api/seagulls/engine/#igamescene","text":"class ` IGameScene ` ( abc . ABC ): This class is for X and Y. View Source class IGameScene ( ABC ): \"\"\" This class is for X and Y. \"\"\" @abstractmethod def start ( self ) -> None : pass @abstractmethod def should_quit ( self ) -> bool : pass @abstractmethod def tick ( self ) -> None : pass @abstractmethod def start ( self ) -> None : View Source @abstractmethod def start ( self ) -> None : pass @abstractmethod def should_quit ( self ) -> bool : View Source @abstractmethod def should_quit ( self ) -> bool : pass @abstractmethod def tick ( self ) -> None : View Source @abstractmethod def tick ( self ) -> None : pass","title":"IGameScene"},{"location":"api/seagulls/engine/#iprovidegamescenes","text":"class ` IProvideGameScenes ` ( abc . ABC ): Helper class that provides a standard way to create an ABC using inheritance. View Source class IProvideGameScenes ( ABC ): @abstractmethod def get_scene ( self ) -> IGameScene : pass @abstractmethod def get_scene ( self ) -> seagulls . engine . _game_scene . IGameScene : View Source @abstractmethod def get_scene ( self ) -> IGameScene : pass","title":"IProvideGameScenes"},{"location":"api/seagulls/engine/#iprovidegamesessions","text":"class ` IProvideGameSessions ` ( abc . ABC ): Helper class that provides a standard way to create an ABC using inheritance. View Source class IProvideGameSessions ( ABC ): @abstractmethod def get_session ( self , scene : str ) -> IGameSession : pass @abstractmethod def get_session ( self , scene : str ) -> seagulls . engine . _game_session . IGameSession : View Source @abstractmethod def get_session ( self , scene : str ) -> IGameSession : pass","title":"IProvideGameSessions"},{"location":"api/seagulls/engine/#igamesession","text":"class ` IGameSession ` ( abc . ABC ): Helper class that provides a standard way to create an ABC using inheritance. View Source class IGameSession ( ABC ): @abstractmethod def start ( self ) -> None : pass @abstractmethod def wait_for_completion ( self ) -> None : pass @abstractmethod def stop ( self ) -> None : pass @abstractmethod def start ( self ) -> None : View Source @abstractmethod def start ( self ) -> None : pass @abstractmethod def wait_for_completion ( self ) -> None : View Source @abstractmethod def wait_for_completion ( self ) -> None : pass @abstractmethod def stop ( self ) -> None : View Source @abstractmethod def stop ( self ) -> None : pass","title":"IGameSession"},{"location":"api/seagulls/engine/#surfacerenderer","text":"class ` SurfaceRenderer ` : View Source class SurfaceRenderer : def start ( self ) -> None : self . _get_surface () def render ( self , surface : Surface ) -> None : self . _get_surface () . blit ( surface , ( 0 , 0 )) pygame . display . flip () @lru_cache () def _get_surface ( self ) -> Surface : return pygame . display . set_mode (( 1024 , 600 )) SurfaceRenderer (): def start ( self ) -> None : View Source def start ( self ) -> None : self . _get_surface () def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : Surface ) -> None : self . _get_surface () . blit ( surface , ( 0 , 0 )) pygame . display . flip ()","title":"SurfaceRenderer"},{"location":"api/seagulls/engine/#gameclock","text":"class ` GameClock ` ( seagulls . engine . _game_object . GameObject ): Interface for anything representing an object in the scene. View Source class GameClock ( GameObject ): _clock : Clock _ticks : int _delta : int def __init__ ( self ): self . _clock = Clock () self . _ticks = 0 self . _delta = 0 def tick ( self ) -> None : self . _delta = self . _clock . tick () def render ( self , surface : Surface ) -> None : pass def get_time ( self ) -> int : return self . _delta def get_fps ( self ) -> float : return self . _clock . get_fps () GameClock (): View Source def __init__ ( self ): self . _clock = Clock () self . _ticks = 0 self . _delta = 0 def tick ( self ) -> None : View Source def tick ( self ) -> None : self . _delta = self . _clock . tick () def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : Surface ) -> None : pass def get_time ( self ) -> int : View Source def get_time ( self ) -> int : return self . _delta def get_fps ( self ) -> float : View Source def get_fps ( self ) -> float : return self . _clock . get_fps ()","title":"GameClock"},{"location":"api/seagulls/engine/#gamecontrols","text":"class ` GameControls ` ( seagulls . engine . _game_object . GameObject ): Interface for anything representing an object in the scene. View Source class GameControls ( GameObject ): _events : List [ Event ] def __init__ ( self ): self . _events = [] def tick ( self ): self . _events = pygame . event . get () def should_quit ( self ) -> bool : for event in self . _events : if event . type == pygame . QUIT : return True if self . _is_key_down_event ( event , pygame . K_ESCAPE ): return True return False def should_fire ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_SPACE ): return True return False def is_left_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_LEFT ] def is_right_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_RIGHT ] def should_toggle_debug_hud ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_BACKQUOTE ): return True return False def is_click_initialized ( self ) -> bool : for event in self . _events : if not event . type == pygame . MOUSEBUTTONDOWN : continue return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] return False def is_mouse_down ( self ) -> bool : return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] def _is_key_down_event ( self , event : Event , key : int ) -> bool : return event . type == pygame . KEYDOWN and event . key == key def _is_key_up_event ( self , event : Event , key : int ) -> bool : return event . type == pygame . KEYUP and event . key == key def render ( self , surface : pygame . Surface ) -> None : pass GameControls (): View Source def __init__ ( self ): self . _events = [] def tick ( self ): View Source def tick ( self ): self . _events = pygame . event . get () def should_quit ( self ) -> bool : View Source def should_quit ( self ) -> bool : for event in self . _events : if event . type == pygame . QUIT : return True if self . _is_key_down_event ( event , pygame . K_ESCAPE ): return True return False def should_fire ( self ) -> bool : View Source def should_fire ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_SPACE ): return True return False def is_left_moving ( self ) -> bool : View Source def is_left_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_LEFT ] def is_right_moving ( self ) -> bool : View Source def is_right_moving ( self ) -> bool : return pygame . key . get_pressed ()[ pygame . K_RIGHT ] def should_toggle_debug_hud ( self ) -> bool : View Source def should_toggle_debug_hud ( self ) -> bool : for event in self . _events : if self . _is_key_down_event ( event , pygame . K_BACKQUOTE ): return True return False def is_click_initialized ( self ) -> bool : View Source def is_click_initialized ( self ) -> bool : for event in self . _events : if not event . type == pygame . MOUSEBUTTONDOWN : continue return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] return False def is_mouse_down ( self ) -> bool : View Source def is_mouse_down ( self ) -> bool : return pygame . mouse . get_pressed ( num_buttons = 3 )[ 0 ] def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : pygame . Surface ) -> None : pass","title":"GameControls"},{"location":"api/seagulls/engine/#gameobject","text":"class ` GameObject ` ( abc . ABC ): Interface for anything representing an object in the scene. View Source class GameObject ( ABC ): \"\"\" Interface for anything representing an object in the scene. \"\"\" @abstractmethod def tick ( self ) -> None : pass @abstractmethod def render ( self , surface : Surface ) -> None : pass @abstractmethod def tick ( self ) -> None : View Source @abstractmethod def tick ( self ) -> None : pass @abstractmethod def render ( self , surface : pygame . Surface ) -> None : View Source @abstractmethod def render ( self , surface : Surface ) -> None : pass","title":"GameObject"},{"location":"api/seagulls/engine/#gameobjectscollection","text":"class ` GameObjectsCollection ` : Data structure that allows you to keep track of objects in the scene. View Source class GameObjectsCollection : \"\"\" Data structure that allows you to keep track of objects in the scene. \"\"\" _game_objects : List [ GameObject ] def __init__ ( self ) -> None : self . _game_objects = [] def add ( self , game_object : GameObject ) -> None : self . _game_objects . append ( game_object ) def apply ( self , func : Callable [[ GameObject ], None ]) -> None : for game_object in self . _game_objects : func ( game_object ) GameObjectsCollection (): View Source def __init__ ( self ) -> None : self . _game_objects = [] def add ( self , game_object : seagulls . engine . _game_object . GameObject ) -> None : View Source def add ( self , game_object : GameObject ) -> None : self . _game_objects . append ( game_object ) def apply ( self , func : Callable [[ seagulls . engine . _game_object . GameObject ], NoneType ] ) -> None : View Source def apply ( self , func : Callable [[ GameObject ], None ]) -> None : for game_object in self . _game_objects : func ( game_object )","title":"GameObjectsCollection"},{"location":"api/seagulls/engine/#gamesettings","text":"class ` GameSettings ` : View Source class GameSettings : def get_setting ( self , name , default = None ) -> Any : data = self . _load_yaml () return data . get ( name , default ) @lru_cache () def _load_yaml ( self ) -> Dict [ str , Any ]: file = Path . home () / \".config/seagulls.yaml\" if not file . exists (): file . touch () return yaml . safe_load ( file . read_text ()) or {} GameSettings (): def get_setting ( self , name , default = None ) -> Any : View Source def get_setting ( self , name , default = None ) -> Any : data = self . _load_yaml () return data . get ( name , default )","title":"GameSettings"},{"location":"api/seagulls/engine/#rect","text":"class ` Rect ` : Rect(left, top, width, height) -> Rect Rect((left, top), (width, height)) -> Rect Rect(object) -> Rect pygame object for storing rectangular coordinates Rect ( * args , ** kwargs ): def normalize ( unknown ): normalize() -> None correct negative sizes def clip ( unknown ): clip(Rect) -> Rect crops a rectangle inside another def clipline ( unknown ): clipline(x1, y1, x2, y2) -> ((cx1, cy1), (cx2, cy2)) clipline(x1, y1, x2, y2) -> () clipline((x1, y1), (x2, y2)) -> ((cx1, cy1), (cx2, cy2)) clipline((x1, y1), (x2, y2)) -> () clipline((x1, y1, x2, y2)) -> ((cx1, cy1), (cx2, cy2)) clipline((x1, y1, x2, y2)) -> () clipline(((x1, y1), (x2, y2))) -> ((cx1, cy1), (cx2, cy2)) clipline(((x1, y1), (x2, y2))) -> () crops a line inside a rectangle def clamp ( unknown ): clamp(Rect) -> Rect moves the rectangle inside another def clamp_ip ( unknown ): clamp_ip(Rect) -> None moves the rectangle inside another, in place def copy ( unknown ): copy() -> Rect copy the rectangle def fit ( unknown ): fit(Rect) -> Rect resize and move a rectangle with aspect ratio def move ( unknown ): move(x, y) -> Rect moves the rectangle def update ( unknown ): update(left, top, width, height) -> None update((left, top), (width, height)) -> None update(object) -> None sets the position and size of the rectangle def inflate ( unknown ): inflate(x, y) -> Rect grow or shrink the rectangle size def union ( unknown ): union(Rect) -> Rect joins two rectangles into one def unionall ( unknown ): unionall(Rect_sequence) -> Rect the union of many rectangles def move_ip ( unknown ): move_ip(x, y) -> None moves the rectangle, in place def inflate_ip ( unknown ): inflate_ip(x, y) -> None grow or shrink the rectangle size, in place def union_ip ( unknown ): union_ip(Rect) -> None joins two rectangles into one, in place def unionall_ip ( unknown ): unionall_ip(Rect_sequence) -> None the union of many rectangles, in place def collidepoint ( unknown ): collidepoint(x, y) -> bool collidepoint((x,y)) -> bool test if a point is inside a rectangle def colliderect ( unknown ): colliderect(Rect) -> bool test if two rectangles overlap def collidelist ( unknown ): collidelist(list) -> index test if one rectangle in a list intersects def collidelistall ( unknown ): collidelistall(list) -> indices test if all rectangles in a list intersect def collidedict ( unknown ): collidedict(dict) -> (key, value) collidedict(dict) -> None collidedict(dict, use_values=0) -> (key, value) collidedict(dict, use_values=0) -> None test if one rectangle in a dictionary intersects def collidedictall ( unknown ): collidedictall(dict) -> [(key, value), ...] collidedictall(dict, use_values=0) -> [(key, value), ...] test if all rectangles in a dictionary intersect def contains ( unknown ): contains(Rect) -> bool test if one rectangle is inside another x y w h width height top left bottom right centerx centery topleft topright bottomleft bottomright midtop midleft midbottom midright size center","title":"Rect"},{"location":"api/seagulls/engine/#surface","text":"class ` Surface ` : Surface((width, height), flags=0, depth=0, masks=None) -> Surface Surface((width, height), flags=0, Surface) -> Surface pygame object for representing images Surface ( * args , ** kwargs ): def get_at ( unknown ): get_at((x, y)) -> Color get the color value at a single pixel def set_at ( unknown ): set_at((x, y), Color) -> None set the color value for a single pixel def get_at_mapped ( unknown ): get_at_mapped((x, y)) -> Color get the mapped color value at a single pixel def map_rgb ( unknown ): map_rgb(Color) -> mapped_int convert a color into a mapped color value def unmap_rgb ( unknown ): unmap_rgb(mapped_int) -> Color convert a mapped integer color value into a Color def get_palette ( unknown ): get_palette() -> [RGB, RGB, RGB, ...] get the color index palette for an 8-bit Surface def get_palette_at ( unknown ): get_palette_at(index) -> RGB get the color for a single entry in a palette def set_palette ( unknown ): set_palette([RGB, RGB, RGB, ...]) -> None set the color palette for an 8-bit Surface def set_palette_at ( unknown ): set_palette_at(index, RGB) -> None set the color for a single index in an 8-bit Surface palette def lock ( unknown ): lock() -> None lock the Surface memory for pixel access def unlock ( unknown ): unlock() -> None unlock the Surface memory from pixel access def mustlock ( unknown ): mustlock() -> bool test if the Surface requires locking def get_locked ( unknown ): get_locked() -> bool test if the Surface is current locked def get_locks ( unknown ): get_locks() -> tuple Gets the locks for the Surface def set_colorkey ( unknown ): set_colorkey(Color, flags=0) -> None set_colorkey(None) -> None Set the transparent colorkey def get_colorkey ( unknown ): get_colorkey() -> RGB or None Get the current transparent colorkey def set_alpha ( unknown ): set_alpha(value, flags=0) -> None set_alpha(None) -> None set the alpha value for the full Surface image def get_alpha ( unknown ): get_alpha() -> int_value get the current Surface transparency value def get_blendmode ( unknown ): Return the surface's SDL 2 blend mode def copy ( unknown ): copy() -> Surface create a new copy of a Surface def convert ( unknown ): convert(Surface=None) -> Surface convert(depth, flags=0) -> Surface convert(masks, flags=0) -> Surface change the pixel format of an image def convert_alpha ( unknown ): convert_alpha(Surface) -> Surface convert_alpha() -> Surface change the pixel format of an image including per pixel alphas def set_clip ( unknown ): set_clip(rect) -> None set_clip(None) -> None set the current clipping area of the Surface def get_clip ( unknown ): get_clip() -> Rect get the current clipping area of the Surface def fill ( unknown ): fill(color, rect=None, special_flags=0) -> Rect fill Surface with a solid color def blit ( unknown ): blit(source, dest, area=None, special_flags=0) -> Rect draw one image onto another def blits ( unknown ): blits(blit_sequence=((source, dest), ...), doreturn=1) -> [Rect, ...] or None blits(((source, dest, area), ...)) -> [Rect, ...] blits(((source, dest, area, special_flags), ...)) -> [Rect, ...] draw many images onto another def scroll ( unknown ): scroll(dx=0, dy=0) -> None Shift the surface image in place def get_flags ( unknown ): get_flags() -> int get the additional flags used for the Surface def get_size ( unknown ): get_size() -> (width, height) get the dimensions of the Surface def get_width ( unknown ): get_width() -> width get the width of the Surface def get_height ( unknown ): get_height() -> height get the height of the Surface def get_rect ( unknown ): get_rect(**kwargs) -> Rect get the rectangular area of the Surface def get_pitch ( unknown ): get_pitch() -> int get the number of bytes used per Surface row def get_bitsize ( unknown ): get_bitsize() -> int get the bit depth of the Surface pixel format def get_bytesize ( unknown ): get_bytesize() -> int get the bytes used per Surface pixel def get_masks ( unknown ): get_masks() -> (R, G, B, A) the bitmasks needed to convert between a color and a mapped integer def get_shifts ( unknown ): get_shifts() -> (R, G, B, A) the bit shifts needed to convert between a color and a mapped integer def set_masks ( unknown ): set_masks((r,g,b,a)) -> None set the bitmasks needed to convert between a color and a mapped integer def set_shifts ( unknown ): set_shifts((r,g,b,a)) -> None sets the bit shifts needed to convert between a color and a mapped integer def get_losses ( unknown ): get_losses() -> (R, G, B, A) the significant bits used to convert between a color and a mapped integer def subsurface ( unknown ): subsurface(Rect) -> Surface create a new surface that references its parent def get_offset ( unknown ): get_offset() -> (x, y) find the position of a child subsurface inside a parent def get_abs_offset ( unknown ): get_abs_offset() -> (x, y) find the absolute position of a child subsurface inside its top level parent def get_parent ( unknown ): get_parent() -> Surface find the parent of a subsurface def get_abs_parent ( unknown ): get_abs_parent() -> Surface find the top level parent of a subsurface def get_bounding_rect ( unknown ): get_bounding_rect(min_alpha = 1) -> Rect find the smallest rect containing data def get_view ( unknown ): get_view(<kind>='2') -> BufferProxy return a buffer view of the Surface's pixels. def get_buffer ( unknown ): get_buffer() -> BufferProxy acquires a buffer object for the pixels of the Surface.","title":"Surface"},{"location":"api/seagulls/engine/#color","text":"class ` Color ` : Color(r, g, b) -> Color Color(r, g, b, a=255) -> Color Color(color_value) -> Color pygame object for color representations Color ( * args , ** kwargs ): def normalize ( unknown ): normalize() -> tuple Returns the normalized RGBA values of the Color. def correct_gamma ( unknown ): correct_gamma (gamma) -> Color Applies a certain gamma value to the Color. def set_length ( unknown ): set_length(len) -> None Set the number of elements in the Color to 1,2,3, or 4. def lerp ( unknown ): lerp(Color, float) -> Color returns a linear interpolation to the given Color. def premul_alpha ( unknown ): premul_alpha() -> Color returns a Color where the r,g,b components have been multiplied by the alpha. def update ( unknown ): update(r, g, b) -> None update(r, g, b, a=255) -> None update(color_value) -> None Sets the elements of the color r r -> int Gets or sets the red value of the Color. g g -> int Gets or sets the green value of the Color. b b -> int Gets or sets the blue value of the Color. a a -> int Gets or sets the alpha value of the Color. hsva hsva -> tuple Gets or sets the HSVA representation of the Color. hsla hsla -> tuple Gets or sets the HSLA representation of the Color. i1i2i3 i1i2i3 -> tuple Gets or sets the I1I2I3 representation of the Color. cmy cmy -> tuple Gets or sets the CMY representation of the Color.","title":"Color"},{"location":"api/seagulls/engine/#pixelarray","text":"class ` PixelArray ` : PixelArray(Surface) -> PixelArray pygame object for direct pixel access of surfaces PixelArray (): def compare ( unknown ): compare(array, distance=0, weights=(0.299, 0.587, 0.114)) -> PixelArray Compares the PixelArray with another one. def extract ( unknown ): extract(color, distance=0, weights=(0.299, 0.587, 0.114)) -> PixelArray Extracts the passed color from the PixelArray. def make_surface ( unknown ): make_surface() -> Surface Creates a new Surface from the current PixelArray. def close ( unknown ): transpose() -> PixelArray Closes the PixelArray, and releases Surface lock. def replace ( unknown ): replace(color, repcolor, distance=0, weights=(0.299, 0.587, 0.114)) -> None Replaces the passed color in the PixelArray with another one. def transpose ( unknown ): transpose() -> PixelArray Exchanges the x and y axis. surface surface -> Surface Gets the Surface the PixelArray uses. itemsize itemsize -> int Returns the byte size of a pixel array item shape shape -> tuple of int's Returns the array size. strides strides -> tuple of int's Returns byte offsets for each array dimension. ndim ndim -> int Returns the number of dimensions.","title":"PixelArray"},{"location":"api/seagulls/engine/#vector2","text":"class ` Vector2 ` : Vector2() -> Vector2 Vector2(int) -> Vector2 Vector2(float) -> Vector2 Vector2(Vector2) -> Vector2 Vector2(x, y) -> Vector2 Vector2((x, y)) -> Vector2 a 2-Dimensional Vector Vector2 ( * args , ** kwargs ): def length ( unknown ): length() -> float returns the Euclidean length of the vector. def length_squared ( unknown ): length_squared() -> float returns the squared Euclidean length of the vector. def magnitude ( unknown ): magnitude() -> float returns the Euclidean magnitude of the vector. def magnitude_squared ( unknown ): magnitude_squared() -> float returns the squared magnitude of the vector. def rotate ( unknown ): rotate(angle) -> Vector2 rotates a vector by a given angle in degrees. def rotate_ip ( unknown ): rotate_ip(angle) -> None rotates the vector by a given angle in degrees in place. def rotate_rad ( unknown ): rotate_rad(angle) -> Vector2 rotates a vector by a given angle in radians. def rotate_ip_rad ( unknown ): rotate_ip_rad(angle) -> None rotates the vector by a given angle in radians in place. def slerp ( unknown ): slerp(Vector2, float) -> Vector2 returns a spherical interpolation to the given vector. def lerp ( unknown ): lerp(Vector2, float) -> Vector2 returns a linear interpolation to the given vector. def normalize ( unknown ): normalize() -> Vector2 returns a vector with the same direction but length 1. def normalize_ip ( unknown ): normalize_ip() -> None normalizes the vector in place so that its length is 1. def is_normalized ( unknown ): is_normalized() -> Bool tests if the vector is normalized i.e. has length == 1. def cross ( unknown ): cross(Vector2) -> Vector2 calculates the cross- or vector-product def dot ( unknown ): dot(Vector2) -> float calculates the dot- or scalar-product with the other vector def angle_to ( unknown ): angle_to(Vector2) -> float calculates the angle to a given vector in degrees. def update ( unknown ): update() -> None update(int) -> None update(float) -> None update(Vector2) -> None update(x, y) -> None update((x, y)) -> None Sets the coordinates of the vector. def scale_to_length ( unknown ): scale_to_length(float) -> None scales the vector to a given length. def reflect ( unknown ): reflect(Vector2) -> Vector2 returns a vector reflected of a given normal. def reflect_ip ( unknown ): reflect_ip(Vector2) -> None reflect the vector of a given normal in place. def distance_to ( unknown ): distance_to(Vector2) -> float calculates the Euclidean distance to a given vector. def distance_squared_to ( unknown ): distance_squared_to(Vector2) -> float calculates the squared Euclidean distance to a given vector. def elementwise ( unknown ): elementwise() -> VectorElementwiseProxy The next operation will be performed elementwise. def as_polar ( unknown ): as_polar() -> (r, phi) returns a tuple with radial distance and azimuthal angle. def from_polar ( unknown ): from_polar((r, phi)) -> None Sets x and y from a polar coordinates tuple. def project ( unknown ): project(Vector2) -> Vector2 projects a vector onto another. epsilon small value used in comparisons x y","title":"Vector2"},{"location":"api/seagulls/engine/#vector3","text":"class ` Vector3 ` : Vector3() -> Vector3 Vector3(int) -> Vector3 Vector3(float) -> Vector3 Vector3(Vector3) -> Vector3 Vector3(x, y, z) -> Vector3 Vector3((x, y, z)) -> Vector3 a 3-Dimensional Vector Vector3 ( * args , ** kwargs ): def length ( unknown ): length() -> float returns the Euclidean length of the vector. def length_squared ( unknown ): length_squared() -> float returns the squared Euclidean length of the vector. def magnitude ( unknown ): magnitude() -> float returns the Euclidean magnitude of the vector. def magnitude_squared ( unknown ): magnitude_squared() -> float returns the squared Euclidean magnitude of the vector. def rotate ( unknown ): rotate(angle, Vector3) -> Vector3 rotates a vector by a given angle in degrees. def rotate_ip ( unknown ): rotate_ip(angle, Vector3) -> None rotates the vector by a given angle in degrees in place. def rotate_rad ( unknown ): rotate_rad(angle, Vector3) -> Vector3 rotates a vector by a given angle in radians. def rotate_ip_rad ( unknown ): rotate_ip_rad(angle, Vector3) -> None rotates the vector by a given angle in radians in place. def rotate_x ( unknown ): rotate_x(angle) -> Vector3 rotates a vector around the x-axis by the angle in degrees. def rotate_x_ip ( unknown ): rotate_x_ip(angle) -> None rotates the vector around the x-axis by the angle in degrees in place. def rotate_x_rad ( unknown ): rotate_x_rad(angle) -> Vector3 rotates a vector around the x-axis by the angle in radians. def rotate_x_ip_rad ( unknown ): rotate_x_ip_rad(angle) -> None rotates the vector around the x-axis by the angle in radians in place. def rotate_y ( unknown ): rotate_y(angle) -> Vector3 rotates a vector around the y-axis by the angle in degrees. def rotate_y_ip ( unknown ): rotate_y_ip(angle) -> None rotates the vector around the y-axis by the angle in degrees in place. def rotate_y_rad ( unknown ): rotate_y_rad(angle) -> Vector3 rotates a vector around the y-axis by the angle in radians. def rotate_y_ip_rad ( unknown ): rotate_y_ip_rad(angle) -> None rotates the vector around the y-axis by the angle in radians in place. def rotate_z ( unknown ): rotate_z(angle) -> Vector3 rotates a vector around the z-axis by the angle in degrees. def rotate_z_ip ( unknown ): rotate_z_ip(angle) -> None rotates the vector around the z-axis by the angle in degrees in place. def rotate_z_rad ( unknown ): rotate_z_rad(angle) -> Vector3 rotates a vector around the z-axis by the angle in radians. def rotate_z_ip_rad ( unknown ): rotate_z_ip_rad(angle) -> None rotates the vector around the z-axis by the angle in radians in place. def slerp ( unknown ): slerp(Vector3, float) -> Vector3 returns a spherical interpolation to the given vector. def lerp ( unknown ): lerp(Vector3, float) -> Vector3 returns a linear interpolation to the given vector. def normalize ( unknown ): normalize() -> Vector3 returns a vector with the same direction but length 1. def normalize_ip ( unknown ): normalize_ip() -> None normalizes the vector in place so that its length is 1. def is_normalized ( unknown ): is_normalized() -> Bool tests if the vector is normalized i.e. has length == 1. def cross ( unknown ): cross(Vector3) -> Vector3 calculates the cross- or vector-product def dot ( unknown ): dot(Vector3) -> float calculates the dot- or scalar-product with the other vector def angle_to ( unknown ): angle_to(Vector3) -> float calculates the angle to a given vector in degrees. def update ( unknown ): update() -> None update(int) -> None update(float) -> None update(Vector3) -> None update(x, y, z) -> None update((x, y, z)) -> None Sets the coordinates of the vector. def scale_to_length ( unknown ): scale_to_length(float) -> None scales the vector to a given length. def reflect ( unknown ): reflect(Vector3) -> Vector3 returns a vector reflected of a given normal. def reflect_ip ( unknown ): reflect_ip(Vector3) -> None reflect the vector of a given normal in place. def distance_to ( unknown ): distance_to(Vector3) -> float calculates the Euclidean distance to a given vector. def distance_squared_to ( unknown ): distance_squared_to(Vector3) -> float calculates the squared Euclidean distance to a given vector. def elementwise ( unknown ): elementwise() -> VectorElementwiseProxy The next operation will be performed elementwise. def as_spherical ( unknown ): as_spherical() -> (r, theta, phi) returns a tuple with radial distance, inclination and azimuthal angle. def from_spherical ( unknown ): from_spherical((r, theta, phi)) -> None Sets x, y and z from a spherical coordinates 3-tuple. def project ( unknown ): project(Vector3) -> Vector3 projects a vector onto another. epsilon small value used in comparisons x y z","title":"Vector3"},{"location":"api/seagulls/examples/","text":"seagulls .examples \u00b6 View Source from ._main_menu_scene import MainMenuScene from ._scene_manager import ExampleSceneManager from ._session import AsyncGameSession , BlockingGameSession from ._simple_stars_background import SimpleStarsBackground from ._simple_rpg_background import SimpleRpgBackground from ._window_scene import WindowScene from ._game_state import GameState __all__ = [ \"MainMenuScene\" , \"AsyncGameSession\" , \"BlockingGameSession\" , \"ExampleSceneManager\" , \"SimpleStarsBackground\" , \"SimpleRpgBackground\" , \"WindowScene\" , \"GameState\" ] MainMenuScene \u00b6 class ` MainMenuScene ` ( seagulls . engine . _game_scene . IGameScene ): This class is for X and Y. View Source class MainMenuScene ( IGameScene ): _surface_renderer : SurfaceRenderer _game_controls : GameControls _asset_manager : AssetManager _game_objects : GameObjectsCollection _space_shooter_menu_button : SpaceShooterMenuButton _seagulls_menu_button : SeagullsMenuButton _rpg_menu_button : RpgMenuButton _should_quit : Event _game_state : GameState _space_shooter_scene : IGameScene _seagulls_scene : IGameScene _rpg_scene : IGameScene def __init__ ( self , surface_renderer : SurfaceRenderer , asset_manager : AssetManager , background : GameObject , game_controls : GameControls , game_state : GameState , space_shooter_scene : IGameScene , seagulls_scene : IGameScene , rpg_scene : IGameScene ,): self . _surface_renderer = surface_renderer self . _asset_manager = asset_manager self . _game_controls = game_controls self . _game_state = game_state self . _space_shooter_scene = space_shooter_scene self . _seagulls_scene = seagulls_scene self . _rpg_scene = rpg_scene self . _game_objects = GameObjectsCollection () self . _game_objects . add ( background ) self . _space_shooter_menu_button = SpaceShooterMenuButton ( asset_manager = asset_manager , game_controls = game_controls , ) self . _seagulls_menu_button = SeagullsMenuButton ( asset_manager = asset_manager , game_controls = game_controls , ) self . _rpg_menu_button = RpgMenuButton ( asset_manager = asset_manager , game_controls = game_controls , ) self . _game_objects . add ( self . _space_shooter_menu_button ) self . _game_objects . add ( self . _seagulls_menu_button ) self . _game_objects . add ( self . _rpg_menu_button ) self . _game_objects . add ( self . _game_controls ) self . _should_quit = Event () def start ( self ) -> None : self . _surface_renderer . start () self . tick () def should_quit ( self ) -> bool : return self . _should_quit . is_set () def tick ( self ) -> None : self . _game_objects . apply ( lambda x : x . tick ()) if self . _space_shooter_menu_button . should_switch : logger . debug ( \"SWITCHING SCENE TO SPACE SHOOTER\" ) self . _change_scene ( self . _space_shooter_scene ) if self . _seagulls_menu_button . should_switch : logger . debug ( \"SWITCHING SCENE TO SEAGULLS\" ) self . _change_scene ( self . _seagulls_scene ) if self . _rpg_menu_button . should_switch : logger . debug ( \"SWITCHING SCENE TO RPG\" ) self . _change_scene ( self . _rpg_scene ) if self . _game_controls . should_quit (): logger . debug ( \"QUIT EVENT DETECTED\" ) self . _should_quit . set () self . _render () def _change_scene ( self , next_scene : IGameScene ) -> None : self . _game_state . active_scene = next_scene self . _game_state . game_state_changed = True def _render ( self ) -> None : background = Surface (( 1024 , 600 )) self . _game_objects . apply ( lambda x : x . render ( background )) self . _surface_renderer . render ( background ) MainMenuScene ( surface_renderer : seagulls . engine . _surface_renderer . SurfaceRenderer , asset_manager : seagulls . assets . _manager . AssetManager , background : seagulls . engine . _game_object . GameObject , game_controls : seagulls . engine . _game_controls . GameControls , game_state : seagulls . examples . _game_state . GameState , space_shooter_scene : seagulls . engine . _game_scene . IGameScene , seagulls_scene : seagulls . engine . _game_scene . IGameScene , rpg_scene : seagulls . engine . _game_scene . IGameScene ): View Source def __init__ ( self , surface_renderer : SurfaceRenderer , asset_manager : AssetManager , background : GameObject , game_controls : GameControls , game_state : GameState , space_shooter_scene : IGameScene , seagulls_scene : IGameScene , rpg_scene : IGameScene ,): self . _surface_renderer = surface_renderer self . _asset_manager = asset_manager self . _game_controls = game_controls self . _game_state = game_state self . _space_shooter_scene = space_shooter_scene self . _seagulls_scene = seagulls_scene self . _rpg_scene = rpg_scene self . _game_objects = GameObjectsCollection () self . _game_objects . add ( background ) self . _space_shooter_menu_button = SpaceShooterMenuButton ( asset_manager = asset_manager , game_controls = game_controls , ) self . _seagulls_menu_button = SeagullsMenuButton ( asset_manager = asset_manager , game_controls = game_controls , ) self . _rpg_menu_button = RpgMenuButton ( asset_manager = asset_manager , game_controls = game_controls , ) self . _game_objects . add ( self . _space_shooter_menu_button ) self . _game_objects . add ( self . _seagulls_menu_button ) self . _game_objects . add ( self . _rpg_menu_button ) self . _game_objects . add ( self . _game_controls ) self . _should_quit = Event () def start ( self ) -> None : View Source def start ( self ) -> None : self . _surface_renderer . start () self . tick () def should_quit ( self ) -> bool : View Source def should_quit ( self ) -> bool : return self . _should_quit . is_set () def tick ( self ) -> None : View Source def tick ( self ) -> None : self . _game_objects . apply ( lambda x : x . tick ()) if self . _space_shooter_menu_button . should_switch : logger . debug ( \"SWITCHING SCENE TO SPACE SHOOTER\" ) self . _change_scene ( self . _space_shooter_scene ) if self . _seagulls_menu_button . should_switch : logger . debug ( \"SWITCHING SCENE TO SEAGULLS\" ) self . _change_scene ( self . _seagulls_scene ) if self . _rpg_menu_button . should_switch : logger . debug ( \"SWITCHING SCENE TO RPG\" ) self . _change_scene ( self . _rpg_scene ) if self . _game_controls . should_quit (): logger . debug ( \"QUIT EVENT DETECTED\" ) self . _should_quit . set () self . _render () AsyncGameSession \u00b6 class ` AsyncGameSession ` ( seagulls . engine . _game_session . IGameSession ): Helper class that provides a standard way to create an ABC using inheritance. View Source class AsyncGameSession ( IGameSession ): _scene_manager : IProvideGameScenes _thread : Thread _stopped : Event def __init__ ( self , scene_manager : IProvideGameScenes ) -> None : self . _scene_manager = scene_manager self . _thread = Thread ( target = self . _thread_target ) self . _stopped = Event () def start ( self ) -> None : logger . debug ( f \"starting game session\" ) self . _thread . start () def wait_for_completion ( self ) -> None : logger . debug ( f \"waiting for completion\" ) while not self . _stopped . is_set (): time . sleep ( 0.1 ) logger . debug ( f \"done waiting for completion\" ) def stop ( self ) -> None : logger . debug ( f \"stopping game session\" ) self . _stopped . set () self . _thread . join () def _thread_target ( self ) -> None : pygame . display . set_caption ( \"Our Game\" ) scene = self . _scene_manager . get_scene () scene . start () while not self . _stopped . is_set () and not scene . should_quit (): scene . tick () logger . debug ( \"exiting game session\" ) self . _stopped . set () AsyncGameSession ( scene_manager : seagulls . engine . _game_scene_manager . IProvideGameScenes ): View Source def __init__ ( self , scene_manager : IProvideGameScenes ) -> None : self . _scene_manager = scene_manager self . _thread = Thread ( target = self . _thread_target ) self . _stopped = Event () def start ( self ) -> None : View Source def start ( self ) -> None : logger . debug ( f \"starting game session\" ) self . _thread . start () def wait_for_completion ( self ) -> None : View Source def wait_for_completion ( self ) -> None : logger . debug ( f \"waiting for completion\" ) while not self . _stopped . is_set (): time . sleep ( 0.1 ) logger . debug ( f \"done waiting for completion\" ) def stop ( self ) -> None : View Source def stop ( self ) -> None : logger . debug ( f \"stopping game session\" ) self . _stopped . set () self . _thread . join () BlockingGameSession \u00b6 class ` BlockingGameSession ` ( seagulls . engine . _game_session . IGameSession ): Helper class that provides a standard way to create an ABC using inheritance. View Source class BlockingGameSession ( IGameSession ): _scene_manager : IProvideGameScenes def __init__ ( self , scene_manager : IProvideGameScenes ) -> None : self . _scene_manager = scene_manager def start ( self ) -> None : logger . debug ( f \"starting game session\" ) pygame . display . set_caption ( \"Our Game\" ) scene = self . _scene_manager . get_scene () scene . start () while not scene . should_quit (): scene . tick () logger . debug ( \"exiting game session\" ) def wait_for_completion ( self ) -> None : pass def stop ( self ) -> None : pass BlockingGameSession ( scene_manager : seagulls . engine . _game_scene_manager . IProvideGameScenes ): View Source def __init__ ( self , scene_manager : IProvideGameScenes ) -> None : self . _scene_manager = scene_manager def start ( self ) -> None : View Source def start ( self ) -> None : logger . debug ( f \"starting game session\" ) pygame . display . set_caption ( \"Our Game\" ) scene = self . _scene_manager . get_scene () scene . start () while not scene . should_quit (): scene . tick () logger . debug ( \"exiting game session\" ) def wait_for_completion ( self ) -> None : View Source def wait_for_completion ( self ) -> None : pass def stop ( self ) -> None : View Source def stop ( self ) -> None : pass ExampleSceneManager \u00b6 class ` ExampleSceneManager ` ( seagulls . engine . _game_scene_manager . IProvideGameScenes ): Helper class that provides a standard way to create an ABC using inheritance. View Source class ExampleSceneManager ( IProvideGameScenes ): _scene : MainMenuScene def __init__ ( self , scene : MainMenuScene ): self . _scene = scene def get_scene ( self ) -> IGameScene : return self . _scene ExampleSceneManager ( scene : seagulls . examples . _main_menu_scene . MainMenuScene ): View Source def __init__ ( self , scene : MainMenuScene ): self . _scene = scene def get_scene ( self ) -> seagulls . engine . _game_scene . IGameScene : View Source def get_scene ( self ) -> IGameScene : return self . _scene SimpleStarsBackground \u00b6 class ` SimpleStarsBackground ` ( seagulls . engine . _game_object . GameObject ): Interface for anything representing an object in the scene. View Source class SimpleStarsBackground ( GameObject ): _asset_manager : AssetManager def __init__ ( self , asset_manager : AssetManager ): self . _asset_manager = asset_manager def tick ( self ) -> None : pass def render ( self , surface : Surface ) -> None : background = self . _get_cached_background () surface . blit ( background , ( 0 , 0 )) @lru_cache () def _get_cached_background ( self ) -> Surface : return self . _asset_manager . load_sprite ( \"environment/environment-stars\" ) . copy () SimpleStarsBackground ( asset_manager : seagulls . assets . _manager . AssetManager ): View Source def __init__ ( self , asset_manager : AssetManager ): self . _asset_manager = asset_manager def tick ( self ) -> None : View Source def tick ( self ) -> None : pass def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : Surface ) -> None : background = self . _get_cached_background () surface . blit ( background , ( 0 , 0 )) SimpleRpgBackground \u00b6 class ` SimpleRpgBackground ` ( seagulls . engine . _game_object . GameObject ): Interface for anything representing an object in the scene. View Source class SimpleRpgBackground ( GameObject ): _asset_manager : AssetManager _game_board : GameBoard def __init__ ( self , asset_manager : AssetManager ): self . _asset_manager = asset_manager self . _game_board = GameBoard () def tick ( self ) -> None : pass def render ( self , surface : Surface ) -> None : background = self . _get_cached_background () surface . blit ( background , ( 0 , 0 )) @lru_cache () def _get_cached_background ( self ) -> Surface : surface = Surface (( 1024 , 600 )) top_left_corner = self . _asset_manager . load_sprite ( \"environment/rpg-environment/island-top-left-corner\" ) . copy () top_island_edge = self . _asset_manager . load_sprite ( \"environment/rpg-environment/island-top-edge\" ) . copy () top_right_corner = self . _asset_manager . load_sprite ( \"environment/rpg-environment/island-top-right-corner\" ) . copy () island_water = self . _asset_manager . load_sprite ( \"environment/rpg-environment/island-water\" ) . copy () bottom_left_corner = self . _asset_manager . load_sprite ( \"environment/rpg-environment/island-bottom-left-corner\" ) . copy () bottom_island_edge = self . _asset_manager . load_sprite ( \"environment/rpg-environment/island-bottom-edge\" ) . copy () bottom_right_corner = self . _asset_manager . load_sprite ( \"environment/rpg-environment/island-bottom-right-corner\" ) . copy () island_left_edge = self . _asset_manager . load_sprite ( \"environment/rpg-environment/island-left-edge\" ) . copy () island_right_edge = self . _asset_manager . load_sprite ( \"environment/rpg-environment/island-right-edge\" ) . copy () island_grass = self . _asset_manager . load_sprite ( \"environment/rpg-environment/island-grass\" ) . copy () island_red_home = self . _asset_manager . load_sprite ( \"environment/rpg-environment/island-red-home\" ) . copy () island_blue_home = self . _asset_manager . load_sprite ( \"environment/rpg-environment/island-blue-home\" ) . copy () island_tree = self . _asset_manager . load_sprite ( \"environment/rpg-environment/island-tree\" ) . copy () for y in range ( int ( 600 / 16 )): for x in range ( int ( 1024 / 16 )): if y == 0 : if x == 0 : surface . blit ( top_left_corner , ( x * 16 , y * 16 )) elif x == 63 : surface . blit ( top_right_corner , ( x * 16 , y * 16 )) else : surface . blit ( top_island_edge , ( x * 16 , y * 16 )) elif y == 35 : if x == 0 : surface . blit ( bottom_left_corner , ( x * 16 , y * 16 )) elif x == 63 : surface . blit ( bottom_right_corner , ( x * 16 , y * 16 )) else : surface . blit ( bottom_island_edge , ( x * 16 , y * 16 )) elif y == 36 : surface . blit ( island_water , ( x * 16 , y * 16 )) elif x == 0 : surface . blit ( island_left_edge , ( x * 16 , y * 16 )) elif x == 63 : surface . blit ( island_right_edge , ( x * 16 , y * 16 )) else : random_number = random . randint ( 0 , 100 ) if random_number < 92 : surface . blit ( island_grass , ( x * 16 , y * 16 )) elif random_number < 93 : if len ( self . _game_board . get_neighbors ( x * 16 , y * 16 , 16 )) == 0 : surface . blit ( island_red_home , ( x * 16 , y * 16 )) self . _game_board . set_tile ( x * 16 , y * 16 , Tile ()) else : surface . blit ( island_grass , ( x * 16 , y * 16 )) elif random_number < 94 : if len ( self . _game_board . get_neighbors ( x * 16 , y * 16 , 16 )) == 0 : surface . blit ( island_blue_home , ( x * 16 , y * 16 )) self . _game_board . set_tile ( x * 16 , y * 16 , Tile ()) else : surface . blit ( island_grass , ( x * 16 , y * 16 )) else : surface . blit ( island_tree , ( x * 16 , y * 16 )) return surface SimpleRpgBackground ( asset_manager : seagulls . assets . _manager . AssetManager ): View Source def __init__ ( self , asset_manager : AssetManager ): self . _asset_manager = asset_manager self . _game_board = GameBoard () def tick ( self ) -> None : View Source def tick ( self ) -> None : pass def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : Surface ) -> None : background = self . _get_cached_background () surface . blit ( background , ( 0 , 0 )) WindowScene \u00b6 class ` WindowScene ` ( seagulls . engine . _game_scene . IGameScene ): This class is for X and Y. View Source class WindowScene ( IGameScene ): _active_scene : IGameScene _game_state : GameState def __init__ ( self , active_scene : IGameScene , game_state : GameState ): self . _active_scene = active_scene self . _game_state = game_state self . _game_state . active_scene = active_scene def start ( self ) -> None : self . _active_scene . start () def should_quit ( self ) -> bool : return self . _active_scene . should_quit () def tick ( self ) -> None : if self . _game_state . game_state_changed : self . _update_scene () self . _active_scene . start () self . _active_scene . tick () def _update_scene ( self ) -> None : self . _active_scene = self . _game_state . active_scene self . _game_state . game_state_changed = False WindowScene ( active_scene : seagulls . engine . _game_scene . IGameScene , game_state : seagulls . examples . _game_state . GameState ): View Source def __init__ ( self , active_scene : IGameScene , game_state : GameState ): self . _active_scene = active_scene self . _game_state = game_state self . _game_state . active_scene = active_scene def start ( self ) -> None : View Source def start ( self ) -> None : self . _active_scene . start () def should_quit ( self ) -> bool : View Source def should_quit ( self ) -> bool : return self . _active_scene . should_quit () def tick ( self ) -> None : View Source def tick ( self ) -> None : if self . _game_state . game_state_changed : self . _update_scene () self . _active_scene . start () self . _active_scene . tick () GameState \u00b6 class ` GameState ` : View Source class GameState : active_scene : Optional [ IGameScene ] = None game_state_changed : bool = False GameState (): active_scene : Optional [ seagulls . engine . _game_scene . IGameScene ] = None game_state_changed : bool = False","title":"Examples"},{"location":"api/seagulls/examples/#seagullsexamples","text":"View Source from ._main_menu_scene import MainMenuScene from ._scene_manager import ExampleSceneManager from ._session import AsyncGameSession , BlockingGameSession from ._simple_stars_background import SimpleStarsBackground from ._simple_rpg_background import SimpleRpgBackground from ._window_scene import WindowScene from ._game_state import GameState __all__ = [ \"MainMenuScene\" , \"AsyncGameSession\" , \"BlockingGameSession\" , \"ExampleSceneManager\" , \"SimpleStarsBackground\" , \"SimpleRpgBackground\" , \"WindowScene\" , \"GameState\" ]","title":"seagulls.examples"},{"location":"api/seagulls/examples/#mainmenuscene","text":"class ` MainMenuScene ` ( seagulls . engine . _game_scene . IGameScene ): This class is for X and Y. View Source class MainMenuScene ( IGameScene ): _surface_renderer : SurfaceRenderer _game_controls : GameControls _asset_manager : AssetManager _game_objects : GameObjectsCollection _space_shooter_menu_button : SpaceShooterMenuButton _seagulls_menu_button : SeagullsMenuButton _rpg_menu_button : RpgMenuButton _should_quit : Event _game_state : GameState _space_shooter_scene : IGameScene _seagulls_scene : IGameScene _rpg_scene : IGameScene def __init__ ( self , surface_renderer : SurfaceRenderer , asset_manager : AssetManager , background : GameObject , game_controls : GameControls , game_state : GameState , space_shooter_scene : IGameScene , seagulls_scene : IGameScene , rpg_scene : IGameScene ,): self . _surface_renderer = surface_renderer self . _asset_manager = asset_manager self . _game_controls = game_controls self . _game_state = game_state self . _space_shooter_scene = space_shooter_scene self . _seagulls_scene = seagulls_scene self . _rpg_scene = rpg_scene self . _game_objects = GameObjectsCollection () self . _game_objects . add ( background ) self . _space_shooter_menu_button = SpaceShooterMenuButton ( asset_manager = asset_manager , game_controls = game_controls , ) self . _seagulls_menu_button = SeagullsMenuButton ( asset_manager = asset_manager , game_controls = game_controls , ) self . _rpg_menu_button = RpgMenuButton ( asset_manager = asset_manager , game_controls = game_controls , ) self . _game_objects . add ( self . _space_shooter_menu_button ) self . _game_objects . add ( self . _seagulls_menu_button ) self . _game_objects . add ( self . _rpg_menu_button ) self . _game_objects . add ( self . _game_controls ) self . _should_quit = Event () def start ( self ) -> None : self . _surface_renderer . start () self . tick () def should_quit ( self ) -> bool : return self . _should_quit . is_set () def tick ( self ) -> None : self . _game_objects . apply ( lambda x : x . tick ()) if self . _space_shooter_menu_button . should_switch : logger . debug ( \"SWITCHING SCENE TO SPACE SHOOTER\" ) self . _change_scene ( self . _space_shooter_scene ) if self . _seagulls_menu_button . should_switch : logger . debug ( \"SWITCHING SCENE TO SEAGULLS\" ) self . _change_scene ( self . _seagulls_scene ) if self . _rpg_menu_button . should_switch : logger . debug ( \"SWITCHING SCENE TO RPG\" ) self . _change_scene ( self . _rpg_scene ) if self . _game_controls . should_quit (): logger . debug ( \"QUIT EVENT DETECTED\" ) self . _should_quit . set () self . _render () def _change_scene ( self , next_scene : IGameScene ) -> None : self . _game_state . active_scene = next_scene self . _game_state . game_state_changed = True def _render ( self ) -> None : background = Surface (( 1024 , 600 )) self . _game_objects . apply ( lambda x : x . render ( background )) self . _surface_renderer . render ( background ) MainMenuScene ( surface_renderer : seagulls . engine . _surface_renderer . SurfaceRenderer , asset_manager : seagulls . assets . _manager . AssetManager , background : seagulls . engine . _game_object . GameObject , game_controls : seagulls . engine . _game_controls . GameControls , game_state : seagulls . examples . _game_state . GameState , space_shooter_scene : seagulls . engine . _game_scene . IGameScene , seagulls_scene : seagulls . engine . _game_scene . IGameScene , rpg_scene : seagulls . engine . _game_scene . IGameScene ): View Source def __init__ ( self , surface_renderer : SurfaceRenderer , asset_manager : AssetManager , background : GameObject , game_controls : GameControls , game_state : GameState , space_shooter_scene : IGameScene , seagulls_scene : IGameScene , rpg_scene : IGameScene ,): self . _surface_renderer = surface_renderer self . _asset_manager = asset_manager self . _game_controls = game_controls self . _game_state = game_state self . _space_shooter_scene = space_shooter_scene self . _seagulls_scene = seagulls_scene self . _rpg_scene = rpg_scene self . _game_objects = GameObjectsCollection () self . _game_objects . add ( background ) self . _space_shooter_menu_button = SpaceShooterMenuButton ( asset_manager = asset_manager , game_controls = game_controls , ) self . _seagulls_menu_button = SeagullsMenuButton ( asset_manager = asset_manager , game_controls = game_controls , ) self . _rpg_menu_button = RpgMenuButton ( asset_manager = asset_manager , game_controls = game_controls , ) self . _game_objects . add ( self . _space_shooter_menu_button ) self . _game_objects . add ( self . _seagulls_menu_button ) self . _game_objects . add ( self . _rpg_menu_button ) self . _game_objects . add ( self . _game_controls ) self . _should_quit = Event () def start ( self ) -> None : View Source def start ( self ) -> None : self . _surface_renderer . start () self . tick () def should_quit ( self ) -> bool : View Source def should_quit ( self ) -> bool : return self . _should_quit . is_set () def tick ( self ) -> None : View Source def tick ( self ) -> None : self . _game_objects . apply ( lambda x : x . tick ()) if self . _space_shooter_menu_button . should_switch : logger . debug ( \"SWITCHING SCENE TO SPACE SHOOTER\" ) self . _change_scene ( self . _space_shooter_scene ) if self . _seagulls_menu_button . should_switch : logger . debug ( \"SWITCHING SCENE TO SEAGULLS\" ) self . _change_scene ( self . _seagulls_scene ) if self . _rpg_menu_button . should_switch : logger . debug ( \"SWITCHING SCENE TO RPG\" ) self . _change_scene ( self . _rpg_scene ) if self . _game_controls . should_quit (): logger . debug ( \"QUIT EVENT DETECTED\" ) self . _should_quit . set () self . _render ()","title":"MainMenuScene"},{"location":"api/seagulls/examples/#asyncgamesession","text":"class ` AsyncGameSession ` ( seagulls . engine . _game_session . IGameSession ): Helper class that provides a standard way to create an ABC using inheritance. View Source class AsyncGameSession ( IGameSession ): _scene_manager : IProvideGameScenes _thread : Thread _stopped : Event def __init__ ( self , scene_manager : IProvideGameScenes ) -> None : self . _scene_manager = scene_manager self . _thread = Thread ( target = self . _thread_target ) self . _stopped = Event () def start ( self ) -> None : logger . debug ( f \"starting game session\" ) self . _thread . start () def wait_for_completion ( self ) -> None : logger . debug ( f \"waiting for completion\" ) while not self . _stopped . is_set (): time . sleep ( 0.1 ) logger . debug ( f \"done waiting for completion\" ) def stop ( self ) -> None : logger . debug ( f \"stopping game session\" ) self . _stopped . set () self . _thread . join () def _thread_target ( self ) -> None : pygame . display . set_caption ( \"Our Game\" ) scene = self . _scene_manager . get_scene () scene . start () while not self . _stopped . is_set () and not scene . should_quit (): scene . tick () logger . debug ( \"exiting game session\" ) self . _stopped . set () AsyncGameSession ( scene_manager : seagulls . engine . _game_scene_manager . IProvideGameScenes ): View Source def __init__ ( self , scene_manager : IProvideGameScenes ) -> None : self . _scene_manager = scene_manager self . _thread = Thread ( target = self . _thread_target ) self . _stopped = Event () def start ( self ) -> None : View Source def start ( self ) -> None : logger . debug ( f \"starting game session\" ) self . _thread . start () def wait_for_completion ( self ) -> None : View Source def wait_for_completion ( self ) -> None : logger . debug ( f \"waiting for completion\" ) while not self . _stopped . is_set (): time . sleep ( 0.1 ) logger . debug ( f \"done waiting for completion\" ) def stop ( self ) -> None : View Source def stop ( self ) -> None : logger . debug ( f \"stopping game session\" ) self . _stopped . set () self . _thread . join ()","title":"AsyncGameSession"},{"location":"api/seagulls/examples/#blockinggamesession","text":"class ` BlockingGameSession ` ( seagulls . engine . _game_session . IGameSession ): Helper class that provides a standard way to create an ABC using inheritance. View Source class BlockingGameSession ( IGameSession ): _scene_manager : IProvideGameScenes def __init__ ( self , scene_manager : IProvideGameScenes ) -> None : self . _scene_manager = scene_manager def start ( self ) -> None : logger . debug ( f \"starting game session\" ) pygame . display . set_caption ( \"Our Game\" ) scene = self . _scene_manager . get_scene () scene . start () while not scene . should_quit (): scene . tick () logger . debug ( \"exiting game session\" ) def wait_for_completion ( self ) -> None : pass def stop ( self ) -> None : pass BlockingGameSession ( scene_manager : seagulls . engine . _game_scene_manager . IProvideGameScenes ): View Source def __init__ ( self , scene_manager : IProvideGameScenes ) -> None : self . _scene_manager = scene_manager def start ( self ) -> None : View Source def start ( self ) -> None : logger . debug ( f \"starting game session\" ) pygame . display . set_caption ( \"Our Game\" ) scene = self . _scene_manager . get_scene () scene . start () while not scene . should_quit (): scene . tick () logger . debug ( \"exiting game session\" ) def wait_for_completion ( self ) -> None : View Source def wait_for_completion ( self ) -> None : pass def stop ( self ) -> None : View Source def stop ( self ) -> None : pass","title":"BlockingGameSession"},{"location":"api/seagulls/examples/#examplescenemanager","text":"class ` ExampleSceneManager ` ( seagulls . engine . _game_scene_manager . IProvideGameScenes ): Helper class that provides a standard way to create an ABC using inheritance. View Source class ExampleSceneManager ( IProvideGameScenes ): _scene : MainMenuScene def __init__ ( self , scene : MainMenuScene ): self . _scene = scene def get_scene ( self ) -> IGameScene : return self . _scene ExampleSceneManager ( scene : seagulls . examples . _main_menu_scene . MainMenuScene ): View Source def __init__ ( self , scene : MainMenuScene ): self . _scene = scene def get_scene ( self ) -> seagulls . engine . _game_scene . IGameScene : View Source def get_scene ( self ) -> IGameScene : return self . _scene","title":"ExampleSceneManager"},{"location":"api/seagulls/examples/#simplestarsbackground","text":"class ` SimpleStarsBackground ` ( seagulls . engine . _game_object . GameObject ): Interface for anything representing an object in the scene. View Source class SimpleStarsBackground ( GameObject ): _asset_manager : AssetManager def __init__ ( self , asset_manager : AssetManager ): self . _asset_manager = asset_manager def tick ( self ) -> None : pass def render ( self , surface : Surface ) -> None : background = self . _get_cached_background () surface . blit ( background , ( 0 , 0 )) @lru_cache () def _get_cached_background ( self ) -> Surface : return self . _asset_manager . load_sprite ( \"environment/environment-stars\" ) . copy () SimpleStarsBackground ( asset_manager : seagulls . assets . _manager . AssetManager ): View Source def __init__ ( self , asset_manager : AssetManager ): self . _asset_manager = asset_manager def tick ( self ) -> None : View Source def tick ( self ) -> None : pass def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : Surface ) -> None : background = self . _get_cached_background () surface . blit ( background , ( 0 , 0 ))","title":"SimpleStarsBackground"},{"location":"api/seagulls/examples/#simplerpgbackground","text":"class ` SimpleRpgBackground ` ( seagulls . engine . _game_object . GameObject ): Interface for anything representing an object in the scene. View Source class SimpleRpgBackground ( GameObject ): _asset_manager : AssetManager _game_board : GameBoard def __init__ ( self , asset_manager : AssetManager ): self . _asset_manager = asset_manager self . _game_board = GameBoard () def tick ( self ) -> None : pass def render ( self , surface : Surface ) -> None : background = self . _get_cached_background () surface . blit ( background , ( 0 , 0 )) @lru_cache () def _get_cached_background ( self ) -> Surface : surface = Surface (( 1024 , 600 )) top_left_corner = self . _asset_manager . load_sprite ( \"environment/rpg-environment/island-top-left-corner\" ) . copy () top_island_edge = self . _asset_manager . load_sprite ( \"environment/rpg-environment/island-top-edge\" ) . copy () top_right_corner = self . _asset_manager . load_sprite ( \"environment/rpg-environment/island-top-right-corner\" ) . copy () island_water = self . _asset_manager . load_sprite ( \"environment/rpg-environment/island-water\" ) . copy () bottom_left_corner = self . _asset_manager . load_sprite ( \"environment/rpg-environment/island-bottom-left-corner\" ) . copy () bottom_island_edge = self . _asset_manager . load_sprite ( \"environment/rpg-environment/island-bottom-edge\" ) . copy () bottom_right_corner = self . _asset_manager . load_sprite ( \"environment/rpg-environment/island-bottom-right-corner\" ) . copy () island_left_edge = self . _asset_manager . load_sprite ( \"environment/rpg-environment/island-left-edge\" ) . copy () island_right_edge = self . _asset_manager . load_sprite ( \"environment/rpg-environment/island-right-edge\" ) . copy () island_grass = self . _asset_manager . load_sprite ( \"environment/rpg-environment/island-grass\" ) . copy () island_red_home = self . _asset_manager . load_sprite ( \"environment/rpg-environment/island-red-home\" ) . copy () island_blue_home = self . _asset_manager . load_sprite ( \"environment/rpg-environment/island-blue-home\" ) . copy () island_tree = self . _asset_manager . load_sprite ( \"environment/rpg-environment/island-tree\" ) . copy () for y in range ( int ( 600 / 16 )): for x in range ( int ( 1024 / 16 )): if y == 0 : if x == 0 : surface . blit ( top_left_corner , ( x * 16 , y * 16 )) elif x == 63 : surface . blit ( top_right_corner , ( x * 16 , y * 16 )) else : surface . blit ( top_island_edge , ( x * 16 , y * 16 )) elif y == 35 : if x == 0 : surface . blit ( bottom_left_corner , ( x * 16 , y * 16 )) elif x == 63 : surface . blit ( bottom_right_corner , ( x * 16 , y * 16 )) else : surface . blit ( bottom_island_edge , ( x * 16 , y * 16 )) elif y == 36 : surface . blit ( island_water , ( x * 16 , y * 16 )) elif x == 0 : surface . blit ( island_left_edge , ( x * 16 , y * 16 )) elif x == 63 : surface . blit ( island_right_edge , ( x * 16 , y * 16 )) else : random_number = random . randint ( 0 , 100 ) if random_number < 92 : surface . blit ( island_grass , ( x * 16 , y * 16 )) elif random_number < 93 : if len ( self . _game_board . get_neighbors ( x * 16 , y * 16 , 16 )) == 0 : surface . blit ( island_red_home , ( x * 16 , y * 16 )) self . _game_board . set_tile ( x * 16 , y * 16 , Tile ()) else : surface . blit ( island_grass , ( x * 16 , y * 16 )) elif random_number < 94 : if len ( self . _game_board . get_neighbors ( x * 16 , y * 16 , 16 )) == 0 : surface . blit ( island_blue_home , ( x * 16 , y * 16 )) self . _game_board . set_tile ( x * 16 , y * 16 , Tile ()) else : surface . blit ( island_grass , ( x * 16 , y * 16 )) else : surface . blit ( island_tree , ( x * 16 , y * 16 )) return surface SimpleRpgBackground ( asset_manager : seagulls . assets . _manager . AssetManager ): View Source def __init__ ( self , asset_manager : AssetManager ): self . _asset_manager = asset_manager self . _game_board = GameBoard () def tick ( self ) -> None : View Source def tick ( self ) -> None : pass def render ( self , surface : pygame . Surface ) -> None : View Source def render ( self , surface : Surface ) -> None : background = self . _get_cached_background () surface . blit ( background , ( 0 , 0 ))","title":"SimpleRpgBackground"},{"location":"api/seagulls/examples/#windowscene","text":"class ` WindowScene ` ( seagulls . engine . _game_scene . IGameScene ): This class is for X and Y. View Source class WindowScene ( IGameScene ): _active_scene : IGameScene _game_state : GameState def __init__ ( self , active_scene : IGameScene , game_state : GameState ): self . _active_scene = active_scene self . _game_state = game_state self . _game_state . active_scene = active_scene def start ( self ) -> None : self . _active_scene . start () def should_quit ( self ) -> bool : return self . _active_scene . should_quit () def tick ( self ) -> None : if self . _game_state . game_state_changed : self . _update_scene () self . _active_scene . start () self . _active_scene . tick () def _update_scene ( self ) -> None : self . _active_scene = self . _game_state . active_scene self . _game_state . game_state_changed = False WindowScene ( active_scene : seagulls . engine . _game_scene . IGameScene , game_state : seagulls . examples . _game_state . GameState ): View Source def __init__ ( self , active_scene : IGameScene , game_state : GameState ): self . _active_scene = active_scene self . _game_state = game_state self . _game_state . active_scene = active_scene def start ( self ) -> None : View Source def start ( self ) -> None : self . _active_scene . start () def should_quit ( self ) -> bool : View Source def should_quit ( self ) -> bool : return self . _active_scene . should_quit () def tick ( self ) -> None : View Source def tick ( self ) -> None : if self . _game_state . game_state_changed : self . _update_scene () self . _active_scene . start () self . _active_scene . tick ()","title":"WindowScene"},{"location":"api/seagulls/examples/#gamestate","text":"class ` GameState ` : View Source class GameState : active_scene : Optional [ IGameScene ] = None game_state_changed : bool = False GameState (): active_scene : Optional [ seagulls . engine . _game_scene . IGameScene ] = None game_state_changed : bool = False","title":"GameState"},{"location":"api/seagulls/foo/","text":"seagulls .foo \u00b6","title":"Foo"},{"location":"api/seagulls/foo/#seagullsfoo","text":"","title":"seagulls.foo"},{"location":"api/seagulls/foo/test/","text":"seagulls . foo .test \u00b6 This is the comment for the module. View Source \"\"\" This is the comment for the module. \"\"\" from functools import lru_cache from typing import Optional some_variable = 10 \"\"\" Just commenting about `some_variable`. \"\"\" def some_function ( arg1 : str , arg2 : int ) -> Optional [ str ]: \"\"\" This is the documentation for `some_function`. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Args: arg1: docs for `some_function()` arg arg1. arg2: docs for `some_function()` arg arg2. Returns: docs for `some_function()` return value \"\"\" return \"my value\" class SomeClass ( str ): \"\"\" Documentation for `SomeClass`. \"\"\" some_property : str \"\"\" Documentation for `SomeClass.some_property`. \"\"\" def __init__ ( self , arg1 : str ): \"\"\" This is the documentation for `SomeClass.__init__()`. Args: arg1: The docs for arg1 arg in `SomeClass.__init__()`. \"\"\" super () . __init__ () pass @lru_cache () def some_method ( self ) -> None : \"\"\" This is the documentation for `SomeClass.some_method()`. \"\"\" pass some_variable \u00b6 some_variable = 10 Just commenting about some_variable . some_function \u00b6 def some_function ( arg1 : str , arg2 : int ) -> Optional [ str ]: This is the documentation for some_function . Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Args \u00b6 arg1: docs for some_function() arg arg1. arg2: docs for some_function() arg arg2. Returns \u00b6 > docs for some_function() return value View Source def some_function ( arg1 : str , arg2 : int ) -> Optional [ str ]: \"\"\" This is the documentation for `some_function`. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Args: arg1: docs for `some_function()` arg arg1. arg2: docs for `some_function()` arg arg2. Returns: docs for `some_function()` return value \"\"\" return \"my value\" SomeClass \u00b6 class ` SomeClass ` ( builtins . str ): Documentation for SomeClass . View Source class SomeClass ( str ): \"\"\" Documentation for `SomeClass`. \"\"\" some_property : str \"\"\" Documentation for `SomeClass.some_property`. \"\"\" def __init__ ( self , arg1 : str ): \"\"\" This is the documentation for `SomeClass.__init__()`. Args: arg1: The docs for arg1 arg in `SomeClass.__init__()`. \"\"\" super () . __init__ () pass @lru_cache () def some_method ( self ) -> None : \"\"\" This is the documentation for `SomeClass.some_method()`. \"\"\" pass SomeClass ( arg1 : str ): This is the documentation for SomeClass.__init__() . Args \u00b6 arg1: The docs for arg1 arg in SomeClass.__init__() . View Source def __init__ ( self , arg1 : str ): \"\"\" This is the documentation for `SomeClass.__init__()`. Args: arg1: The docs for arg1 arg in `SomeClass.__init__()`. \"\"\" super () . __init__ () pass some_property : str Documentation for SomeClass.some_property . @lru_cache () def some_method ( self ) -> None : This is the documentation for SomeClass.some_method() . View Source @lru_cache () def some_method ( self ) -> None : \"\"\" This is the documentation for `SomeClass.some_method()`. \"\"\" pass Inherited Members \u00b6 ('builtins', 'str') - encode - replace - split - rsplit - join - capitalize - casefold - title - center - count - expandtabs - find - partition - index - ljust - lower - lstrip - rfind - rindex - rjust - rstrip - rpartition - splitlines - strip - swapcase - translate - upper - startswith - endswith - removeprefix - removesuffix - isascii - islower - isupper - istitle - isspace - isdecimal - isdigit - isnumeric - isalpha - isalnum - isidentifier - isprintable - zfill - format - format_map - maketrans","title":"Test"},{"location":"api/seagulls/foo/test/#seagullsfootest","text":"This is the comment for the module. View Source \"\"\" This is the comment for the module. \"\"\" from functools import lru_cache from typing import Optional some_variable = 10 \"\"\" Just commenting about `some_variable`. \"\"\" def some_function ( arg1 : str , arg2 : int ) -> Optional [ str ]: \"\"\" This is the documentation for `some_function`. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Args: arg1: docs for `some_function()` arg arg1. arg2: docs for `some_function()` arg arg2. Returns: docs for `some_function()` return value \"\"\" return \"my value\" class SomeClass ( str ): \"\"\" Documentation for `SomeClass`. \"\"\" some_property : str \"\"\" Documentation for `SomeClass.some_property`. \"\"\" def __init__ ( self , arg1 : str ): \"\"\" This is the documentation for `SomeClass.__init__()`. Args: arg1: The docs for arg1 arg in `SomeClass.__init__()`. \"\"\" super () . __init__ () pass @lru_cache () def some_method ( self ) -> None : \"\"\" This is the documentation for `SomeClass.some_method()`. \"\"\" pass","title":"seagulls.foo.test"},{"location":"api/seagulls/foo/test/#some_variable","text":"some_variable = 10 Just commenting about some_variable .","title":"some_variable"},{"location":"api/seagulls/foo/test/#some_function","text":"def some_function ( arg1 : str , arg2 : int ) -> Optional [ str ]: This is the documentation for some_function . Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text.","title":"some_function"},{"location":"api/seagulls/foo/test/#args","text":"arg1: docs for some_function() arg arg1. arg2: docs for some_function() arg arg2.","title":"Args"},{"location":"api/seagulls/foo/test/#returns","text":"> docs for some_function() return value View Source def some_function ( arg1 : str , arg2 : int ) -> Optional [ str ]: \"\"\" This is the documentation for `some_function`. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Some more text. Args: arg1: docs for `some_function()` arg arg1. arg2: docs for `some_function()` arg arg2. Returns: docs for `some_function()` return value \"\"\" return \"my value\"","title":"Returns"},{"location":"api/seagulls/foo/test/#someclass","text":"class ` SomeClass ` ( builtins . str ): Documentation for SomeClass . View Source class SomeClass ( str ): \"\"\" Documentation for `SomeClass`. \"\"\" some_property : str \"\"\" Documentation for `SomeClass.some_property`. \"\"\" def __init__ ( self , arg1 : str ): \"\"\" This is the documentation for `SomeClass.__init__()`. Args: arg1: The docs for arg1 arg in `SomeClass.__init__()`. \"\"\" super () . __init__ () pass @lru_cache () def some_method ( self ) -> None : \"\"\" This is the documentation for `SomeClass.some_method()`. \"\"\" pass SomeClass ( arg1 : str ): This is the documentation for SomeClass.__init__() .","title":"SomeClass"},{"location":"api/seagulls/foo/test/#args_1","text":"arg1: The docs for arg1 arg in SomeClass.__init__() . View Source def __init__ ( self , arg1 : str ): \"\"\" This is the documentation for `SomeClass.__init__()`. Args: arg1: The docs for arg1 arg in `SomeClass.__init__()`. \"\"\" super () . __init__ () pass some_property : str Documentation for SomeClass.some_property . @lru_cache () def some_method ( self ) -> None : This is the documentation for SomeClass.some_method() . View Source @lru_cache () def some_method ( self ) -> None : \"\"\" This is the documentation for `SomeClass.some_method()`. \"\"\" pass","title":"Args"},{"location":"api/seagulls/foo/test/#inherited-members","text":"('builtins', 'str') - encode - replace - split - rsplit - join - capitalize - casefold - title - center - count - expandtabs - find - partition - index - ljust - lower - lstrip - rfind - rindex - rjust - rstrip - rpartition - splitlines - strip - swapcase - translate - upper - startswith - endswith - removeprefix - removesuffix - isascii - islower - isupper - istitle - isspace - isdecimal - isdigit - isnumeric - isalpha - isalnum - isidentifier - isprintable - zfill - format - format_map - maketrans","title":"Inherited Members"}]}